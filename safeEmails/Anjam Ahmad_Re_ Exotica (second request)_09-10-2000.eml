MIME-Version: 1.0
Message-ID: <B164C11EE096994EF398A35948255A0DC46B0593@Felienne-Pro>
X-Priority: 3 (Normal)
Cc: VinceJKaminski
To: SharadAgnihotri
From: "Anjam" <Ahmad>
Return-Path: Ahmad
Subject: Re_ Exotica (second request)
Date: Mon, 09 Oct 2000 22:40:00 +0200
Content-Type: multipart/mixed;
	 boundary="------------000506070003020302060604"

This is a multi-part message in MIME format.

--------------000506070003020302060604
Content-Type: multipart/alternative;
	 boundary="------------080601030505060605050503"

This is a multi-part message in MIME format.

--------------080601030505060605050503
Content-Transfer-Encoding: quoted-printable
Content-Type: text/plain; format="flowed"

Please see attached:









  =20


	Enron Europe
=09
	From:  Sharad Agnihotri                           09/10/2000 11:56
=09

To: Anjam Ahmad/LON/ECT@ECT
cc: Steven Leppard/LON/ECT@ECT, Vince J Kaminski/HOU/ECT@ECT=20

Subject: Exotica (second request)

Anjam,

I have tried to call you on your mobile but with no success.
Please make sure you send me the exotica code.

Sharad


***********
EDRM Enron Email Data Set has been produced in EML, PST and NSF format by ZL=
 Technologies, Inc. This Data Set is licensed under a Creative Commons Attri=
bution 3.0 United States License <http://creativecommons.org/licenses/by/3.0=
/us/> . To provide attribution, please cite to "ZL Technologies, Inc. (http:=
//www.zlti.com)."
***********

--------------080601030505060605050503--

--------------000506070003020302060604
Content-Type: text/plain; name="Xcoltree.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Xcoltree.c"

/*------------------------------------------------------------------------
 *    file: opoptree.c
 *                    =20
 *     Binomial tree algorithm for evaluating extendible collar.
 *
 *     23nov93  original version -psg
 *
 *------------------------------------------------------------------------*/

#include	<stdio.h>
#include	<math.h>
#include	<malloc.h>

#define		max(A, B)	( (A) > (B) ? (A) : (B) )
#define		DAYSYR	365.25


double opoptree( s, rates, vol2, tmat2, vol, spread, tmat, cap, floor, r, ns=
teps, nmonths)

double	*s,		/* beginning prices			*/
	*rates,		/* interest rates 			*/
	*vol2,		/* volatility at time "tmat"		*/
	*tmat2,		/* time to maturity of underlying option (years) */
	vol,		/* present volatility			*/
	spread,		/* used as offer-mid and mid-bid vol    */
	cap,    	/* cap strike price			*/
	floor, 		/* floor strike  price			*/
	r,		/* interest rate			*/
	tmat;		/* time to maturity of overlying option	 (years) */

int	nsteps,		/* number of time steps			*/
	nmonths;	/* number of months in collar		*/

{
	int	node();

	int	nnodes,		/* number of tree nodes			*/
		i,		/* index for number of "up" steps 	*/
		j,		/* index for time step 			*/
		n;		/* vector index for node(j,i)		*/

	double tstep,		/* time for step to next node		*/
		q,
		*price,		/* price at each node			*/
		*value;		/* option value at each node		*/

	double	x,		/* ln(s)				*/
		vvt,		/* vol*vol*tstep =3D variance in time tstep */
		mu,		/* mu*k =3D mean change in x for tstep 	*/
		h,		/* change in log(s) for each step 	*/
		prob;		/* probability that dx =3D h,
				   1-prob is probability that dx =3D -h	*/


	double	option, finalval;
	double	collarval();

#ifdef	DEBUG

for( i=3D0; i<nmonths; i++)
printf("%9f %9f %9f %9f\n",  s[i], rates[i], vol2[i], tmat2[i]);
printf("\n");

printf("%9f %9f %9f %9f %9f %9f %d %d\n", vol, spread, tmat, cap, floor, r, =
nsteps, nmonths);
#endif

	q =3D r;

/**  Calculate tree parameters **/

	/***  x      =3D log(s); ***/
	x      =3D 0.0;		/* normalize tree to start price=3D$1.00	*/
	tstep  =3D tmat/nsteps;
	vvt    =3D vol*vol*tstep;
	mu     =3D (r-q)/(vol*vol) - 0.5;
	h      =3D sqrt( vvt + (mu*mu*vvt*vvt) );
	prob   =3D 0.5 * (1.0 + mu*vvt/h );
=09
/**  Allocate memory for tree nodes, intermediate values...  **/

	nnodes =3D node( nsteps+1, -(nsteps+1) );
	price  =3D (double *)malloc((unsigned) (nnodes)*sizeof(double));
	value  =3D (double *)malloc((unsigned) (nnodes)*sizeof(double));
=09
/**  Find underlying option values on overlying expiration date **/

	j =3D nsteps;
	for( i=3D-j; i<=3Dj; i+=3D2 )
	{
		n =3D node(j,i);
		price[n] =3D exp( x + i*h );
		value[n] =3D collarval( (double)price[n], s, rates, vol2, tmat2, tmat, cap=
, floor, r, spread, nmonths);=20
		value[n] =3D max( value[n], 0.0);
#ifdef DEBUG
printf("value %7g  price %7g\n", value[n], price[n]);
#endif
	}

/**  Use backward iteration to populate all node values. **/

	for( j=3Dnsteps-1; j>=3D0; j-- )
	for( i=3D-j; i<=3Dj; i+=3D2 )
	{
		n =3D node(j,i);
		price[n] =3D exp( x + i*h );
		option   =3D exp(-r*tstep) * ( prob*value[ node(j+1,i+1) ]
			 + (1.-prob) * value[ node(j+1, i-1) ] );

		/** American style
		swap     =3D strike - price[n];
		value[n] =3D max( swap, option );=20
		*************************/

		/** European style **/
		value[n] =3D option;=20

#ifdef DEBUG
		printf("%3d %3d %3d  price %8.2f  value %8.2f\n", j, i, node(j,i), price[n=
ode(j,i)], value[node(j,i)] );
#endif

	}

#ifdef DEBUG
	printf("Option value is %8.3f\n", value[0] );
#endif

	finalval =3D value[0];
=09
	free(price);
	free(value);
	return( finalval );
}

node(j, i)
int j,i;
{
	int k;

	k =3D (j*(j+2)+i) / 2 ;
	return(k);
}

/*-------------------------------------------------------

	function collarval()

-------------------------------------------------------*/
double collarval( price, s, rates, vol2, tmat2, tmat, cap, floor, r, spread,=
 nmonths)

double	price,		/* unscaled price of underlying		*/
	*s,		/* forward prices			*/
	*rates,		/* zero rates for each underlying option*/
	*vol2,		/* volatility at time "tmat"		*/
	*tmat2,		/* time to maturity of underlying option*/
	tmat,		/* time to maturity of overlying option	*/
	cap,    	/* cap strike price			*/
	floor, 		/* floor strike  price			*/
	r,		/* interest rate			*/
	spread;		/* volatility mid-bid spread		*/

{
double	cvalue=3D0.0,
	time,
	fwd,
	rate;
double	euroopt();
int	n;

	/** value a collar with a producer **/

	for(n=3D0; n<nmonths; n++)
	{
	    time    =3D tmat2[n] - tmat;
	    rate =3D (rates[n]*tmat2[n] - r*tmat) /time;
	    fwd     =3D price*s[n];

	    cvalue +=3D euroopt( fwd,   (double)cap, time, rate, rate, (double)(vol=
2[n]-spread), 1, 0)
		     - euroopt( fwd, (double)floor, time, rate, rate, (double)(vol2[n]+spr=
ead), 0, 0);
	}
	return( cvalue/(double)nmonths );

}/*collarval*/
#undef DAYSYR

--------------000506070003020302060604
Content-Type: text/plain; name="Amerbin.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Amerbin.c"

/*------------------------------------------------------------------------
 *    file: amerb.c=20
 *                    =20
 *     PURPOSE: Binomial tree algorithm
 *
 *	This version to value American option.
 *
 *------------------------------------------------------------------------*/

#include	<stdio.h>
#include 	<malloc.h>
#include	<math.h>
#include 	"nrutil.h"
#include    <stdlib.h>

//#define MAIN=20

#define	EPS	0.0001	/* for greeks */
#define PREMIUM		0
#define DELTA		1
#define GAMMA		2
#define VEGA		3
#define RHO		4
#define THETA		5
#define DELTAVEGA	6
#define CHARM		7

#define NR_END 1
#define FREE_ARG char*

double *dvector(long nl, long nh)
/* allocate a double vector with subscript range v[nl..nh] */
{
	double *v;

	v=3D(double *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(double)));
	if (!v) fprintf(stderr,"allocation failure in dvector()");
	return v-nl+NR_END;
}

void free_dvector(double *v, long nl, long nh)
/* free a double vector allocated with dvector() */
{
	free((FREE_ARG) (v+nl-NR_END));
}


/******************************************************
 *
 *	function amerb()
 *
 *	American option=20
 ******************************************************/
void amerb(double s, double strike, double tmat, double r,=20
		   double q, double vol, int callflag,=20
		   double *result, int dorisk, int nsteps)
{
	int	i,		/* index for number of "up" steps 	*/
		//ret,
		step;		/* index for time step			*/

	double	tstep,		/* time step size 			*/
		convert,	/* exercise value			*/
		*price,		/* underlying price 			*/
		df,		/* discount factor applicable to each time step */
		//*val,
		*vspot;		/* option value at each node		*/

	double	x,		/* ln(s)				*/
		vvt,		/* vol*vol*tstep =3D variance in time tstep */
		mu,		/* mu*k =3D mean change in x for tstep 	*/
		h,		/* change in log(s) for each step 	*/
		prob;		/* probability that dx =3D h,
				   1-prob is probability that dx =3D -h	*/

	double  u, option;
	double  newresult[9];

/**  Calculate tree parameters **/

	x      =3D log(s);
	tstep  =3D tmat/nsteps;
	vvt    =3D vol*vol*tstep;
	mu     =3D (r-q)/(vol*vol) - 0.5;
	h      =3D sqrt( vvt + (mu*mu*vvt*vvt) );
	prob   =3D 0.5 * (1.0 + mu*vvt/h );
	df     =3D exp(-r*tstep);
=09
/**  Allocate memory for tree nodes, intermediate values...  **/

/**	A single array is used for constructing and rolling back through the tre=
e.  **/

fprintf(stderr,"alloc vspot\n");
    vspot  =3D dvector(-nsteps, nsteps);
	price  =3D dvector(-nsteps, nsteps);
//	val    =3D (double *)calloc((unsigned)(nsteps*2+1),sizeof(double));
//	price  =3D (double *)calloc((unsigned)(nsteps*2+1),sizeof(double));
//	vspot  =3D val - nsteps;
//	price  =3D price-nsteps;

/**  Now the value array can be indexed from -step to step. **/
/**  Note "step" indexes the time step through the tree.  "i" is the index f=
or "up" or "down" (negetive i)=20
	price movements **/
=09
/**  Populate price levels. **/
	for( i=3D-nsteps; i<=3Dnsteps; i++  )
	{
		price[i] =3D exp( x + i*h );
	}
/**  Populate terminal option payoffs. **/

	step =3D nsteps;
	for( i=3D-step; i<=3Dstep; i+=3D2 )
	{
		if( callflag )
		  convert  =3D price[i]-strike;
		else
		  convert  =3D strike-price[i];
		vspot[i] =3D max( 0.0, convert);=20
	}

/**  Use backward iteration to populate node values. **/
/**  Don't roll all the way back to the zeroth time step so we can save two =
tree layers for
	calculating the greeks. **/

	for( step=3Dnsteps-1; step>0; step-- )
	{
	  for( i=3D-step; i<=3Dstep; i+=3D2 )
	  {
		option   =3D df * ( prob*vspot[i+1] + (1.-prob)*vspot[i-1] );

		if( callflag )
		  convert  =3D price[i]-strike;
		else
		  convert  =3D strike-price[i];

		vspot[i] =3D max( convert, option);=20
	  }
	}

/* Premium is now deposited in root node. Next, do the greeks by
     finite differencing about the root node. */

/* NEW WAY OF GETTING GREEKS -- as Vince suggested. */

	u =3D exp(h);

	result[PREMIUM] =3D df * ( prob*vspot[1] + (1.-prob)*vspot[-1] );
	result[DELTA] =3D (vspot[1] - vspot[-1])/s/(u-1/u);
=09
	if (dorisk)  {
		result[GAMMA] =3D ((vspot[2]-vspot[0])/s/(u*u-1) -
		   (vspot[0]-vspot[-2])/s/(1-1/u/u))/(s*(u*u-1/u/u)/2);
		result[THETA] =3D (vspot[0]-result[PREMIUM])/2/tstep;
		result[CHARM] =3D ( ((vspot[2]-vspot[-2])/s/(u*u-1/(u*u))) - result[DELTA]=
) / tstep; =20

		amerb(s, strike, tmat, r, q, vol+EPS, callflag, newresult, 0, nsteps);
		result[VEGA]	=3D (newresult[PREMIUM]-result[PREMIUM])/EPS;
		result[DELTAVEGA] =3D (newresult[DELTA]-result[DELTA])/EPS;
		amerb(s, strike, tmat, r+EPS, q+EPS, vol, callflag, newresult, 0, nsteps);
		result[RHO]	=3D (newresult[PREMIUM]-result[PREMIUM])/EPS;
	}
=09
	//free(val);
    //fprintf(stderr, "free %d\n", ret);
	//free(price+nsteps);

	free_dvector(vspot,-nsteps,nsteps);
	free_dvector(price,-nsteps,nsteps);


	return;
}





#ifdef MAIN

double ImpVol_Amerb(double prem, double spot, double strike, double tenor,=20
		   double rate, double yield, double maxvol, int callflag, int steps,=20
		   double accuracy);


main(argc,argv)
    int argc; char **argv;
{
	double	result[9];
	double  impvol, s, strike, r, q, vol, tmat;
	int	nsteps, callflag;

	s      =3D 2;	/* stock price */
	strike =3D 2;
	r      =3D 0.06;
	q      =3D 0.0;
	vol    =3D .2;
	tmat   =3D 1;
	nsteps =3D 30;
	callflag=3D1;=20

	amerb(s, strike, tmat, r, q, vol, callflag, result, 1, nsteps);

	fprintf(stdout, "%7.2f %7.2f %7.2f %7.2f %7.2f %2d %3d  ", s, strike, r, q,=
 vol, callflag, nsteps);
	fprintf(stdout, " %8.3f  %8.3f  %8.3f",  result[0], result[1], result[2]);

	impvol =3D ImpVol_Amerb(result[0], s, strike, tmat,  r, q, 0.9, callflag, n=
steps, 0.001);
	fprintf(stdout, "   impvol  %8.3f\n",  impvol);

}/** main **/
#endif

#undef EPS

/*
Uses Brent's method of finding root, which seems to take=20
far fewer iteration steps (by about a factor of 3) than
the bisection method.=20
*/

#define MAX_ITER 1000
#define NRANSI
#define EPS 3.0e-8

double amer_prem( int callflag, double s, double strike, double tmat, double=
 vol, double r, double q, int nsteps)
{
	double res[9];=09
	amerb(s, strike, tmat, r, q, vol, callflag, res, 0, nsteps);
	return( res[0] );
}

double zbrent_amer(double (*amer_prem)( int, double, double, double, double,=
 double, double, int),
	     double x1, double x2, double tol,
	     int callflag,    double spot, double strike,
	    double tenor, double actual_premium,
	    double rate, double yield, int steps, int maxiter)
{
	int iter;
	double a=3Dx1,b=3Dx2,c=3Dx2,d,e,min1,min2;
	double fa=3D(*amer_prem)(callflag,   spot, strike, tenor, a, rate, yield, s=
teps)-actual_premium,
	       fb=3D(*amer_prem)(callflag,   spot, strike, tenor, b, rate, yield, s=
teps)-actual_premium,
	       fc,p,q,r,s,tol1,xm;

	if ((fa > 0.0 && fb > 0.0) || (fa < 0.0 && fb < 0.0))
	/*		nrerror("Root must be bracketed in zbrent"); */
		return(-1.0);
	fc=3Dfb;
	for (iter=3D1;iter<=3D maxiter/* ITMAX */;iter++) {
/*	printf("%d\n", iter); */
		if ((fb > 0.0 && fc > 0.0) || (fb < 0.0 && fc < 0.0)) {
			c=3Da;
			fc=3Dfa;
			e=3Dd=3Db-a;
		}
		if (fabs(fc) < fabs(fb)) {
			a=3Db;
			b=3Dc;
			c=3Da;
			fa=3Dfb;
			fb=3Dfc;
			fc=3Dfa;
		}
		tol1=3D2.0*EPS*fabs(b)+0.5*tol;
		xm=3D0.5*(c-b);
		if (fabs(xm) <=3D tol1 || fb =3D=3D 0.0) return b;
		if (fabs(e) >=3D tol1 && fabs(fa) > fabs(fb)) {
			s=3Dfb/fa;
			if (a =3D=3D c) {
				p=3D2.0*xm*s;
				q=3D1.0-s;
			} else {
				q=3Dfa/fc;
				r=3Dfb/fc;
				p=3Ds*(2.0*xm*q*(q-r)-(b-a)*(r-1.0));
				q=3D(q-1.0)*(r-1.0)*(s-1.0);
			}
			if (p > 0.0) q =3D -q;
			p=3Dfabs(p);
			min1=3D3.0*xm*q-fabs(tol1*q);
			min2=3Dfabs(e*q);
			if (2.0*p < (min1 < min2 ? min1 : min2)) {
				e=3Dd;
				d=3Dp/q;
			} else {
				d=3Dxm;
				e=3Dd;
			}
		} else {
			d=3Dxm;
			e=3Dd;
		}
		a=3Db;
		fa=3Dfb;
		if (fabs(d) > tol1)
			b +=3D d;
		else
			b +=3D SIGN(tol1,xm);
		fb=3D(*amer_prem)(callflag,   spot, strike, tenor, b, rate, yield, steps)-=
actual_premium;
	}
	/* nrerror("Maximum number of iterations exceeded in zbrent"); */
	return (-2.0);
}
#undef EPS
#undef NRANSI

double ImpVol_Amerb(double prem, double spot, double strike, double tenor,=20
		   double rate, double yield, double maxvol, int callflag, int steps,=20
		   double accuracy)
/* computes the implied volatility of american option though a binomial tree=
 pricer */
{
	double impv;

	impv =3D zbrent_amer(amer_prem, accuracy/10., maxvol, accuracy, callflag, s=
pot,
					 strike, tenor, prem, rate, yield, steps, MAX_ITER);
	return (impv);
}


--------------000506070003020302060604
Content-Type: text/plain; name="Amerbin.h"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Amerbin.h"

#include <stdio.h>
#include <math.h>
#include <ctype.h>
#include "nrutil.h"

#define TRUE 1
#define FALSE 0
#define SUCCESS 1
#define FAILURE 0

#define BI_TREE_SIZE(n) ((n+2)*(n+1)/2)=20
#define TRI_TREE_SIZE(n) ((n+1)*(n+1))
/* Nodes in a bi(tri)nomial tree of _n steps. */


#define ABS(x) ( (x)>0 ? (x) : (-x))
#define SGN(x) ( (x)>0 ? (1) : (-1))
#define EFF_HT(a,b) (((a)+(b))/2)
/* When used as second index in referencing a node on a binomial tree e.g.,
   _bi_tree[a][EFF_HT(a,b)], this function returns the correct
   address corresponding to the height and time in question. =20
*/

typedef struct {
  int       branches; /* For a bionomial (trinomial) tree this is 2 (3). */
  double    **node;   /* An array pointers to variable length columns. */

  double    t_step;   /* The length of a time step. */
  double    rate;     /* Risk free rate. */
  int       border;   /* Usually 2; the constructed tree actually extends ba=
ck beyond
			 the nominal root node by this many time steps.
			 The effective border will be _border/2*2 for
			 a binomial tree. Useful for getting greeks.
			 RECENT NOTE: ACCORDING TO VINCE, IT'S ADEQUATE TO
			 ALWAYS SET BORDER TO 0 AND TO USE POINTS AT T=3D1 AND
			 T=3D2 FOR GAMMA AND DELTA, RESP.
		      */
  double    sigma;    /* Ann. volatility. */
  int       t_root;   /* If the tree can be said to "grow" by 1 (2) time
			 steps depending on wheter it's binomial (trinomial),
			 then t_root is that time at which the actual tree
			 (i.e. the one for which  extensions indicated by
			 _border are ignored) consists of a single root node -- typically, this i=
s 0.
              	       */
  int       t_min;     /* If _t_min is > _t_root and <=3D _t_root + _steps, =
then
			  no space is allocated for any nodes corresponding
			  to times < _t_min. Useful for situations in which
			  keeping anything more than the latest couple of steps is
			  too costly in terms of memory.
		       */
  int       steps;     /* Time associated with terminal nodes is
			  _t_root + _steps.
		       */
} tree_t;

void do_error(char error_text[]);
void allocate_tree(tree_t *tree);
void delete_tree(tree_t  *tree);
void set(tree_t *t, int i, int j, double val);
double get(tree_t *t, int i, int j);
#if 0
void print_tree(tree_t *t, int i_min, int i_max, int c);
void print_itree(tree_t *t, int i_min, int i_max, int c);
#endif
void amerb(double spot, double strike, double tenor, double rate,=20
		   double yield, double sigma, int callflag,=20
		   double *result, int dorisk, int steps);
--------------000506070003020302060604
Content-Type: text/plain; name="Ameropt.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Ameropt.c"

/* -------------------------------------------------------------------------=
-
 *
 *	American Option Calculations
 *
 *	Method of Baron-Adesy and Whaley, J. of Fin., June, 1987.
 *
 *	the quantity  b =3D r - yield
 *
 *	Lower bound =3D 0.1 Basis point set for r and q on 18Mar96 - Krishna=20
 *
 *------------------------------------------------------------------------- =
*/

#include <math.h>
#include <stdio.h>
#include "option.h"

#define FACTOR 	1.3
#define NTRY 	50
#define	EPS	0.0001
#define	GUESSEPS	0.001

#define PUT	0
#define CALL	1

#define LO	0
#define HI	1

#define NORISK	0

#define ITMAX 100
#define NEWEPS 3.0e-8
			/** next, set tolerance of result to 0.0001 cents **/
#define TOL 1.0e-6

#define ARGS	vol, strike, rate, brate, time, prem, callflag
#define DECARGS double vol, double strike, double rate, double brate, double=
 time, double prem, int callflag

double cumnorm(double), call(double, double, double, double, double, double)=
, put(double, double, double, double, double, double);
void euro( double s, double k, double time, double r, double q, double vol, =
int callflag, Optresults *out, int risk );

static int amercall ( double *guess, double fwd, double strike, double time,=
 double r, double q, double vol, Optresults *out, int dorisk );
static int amerput ( double *guess, double fwd, double strike, double time, =
double r, double q, double vol, Optresults *out, int dorisk );
static double amcallroot( double sstar, double vol, double k, double r, doub=
le b, double time, double dummy, int dum);
static double amputroot( double sstar, double vol, double k, double r, doubl=
e b, double time, double dummy, int dum);
static int fwdbrac(double (*func)(), double *sp, DECARGS );
static int findfwd ( double (*func)(), double *sp, DECARGS );
static double amimpvol ( double vol, double fwd, double k, double r, double =
b, double time, double prem, int callflag);

/*------------------------------------
 *      Amer
 *----------------------------------- */
void amer( double fwd, double strike, double time, double r, double q, doubl=
e vol, int callflag, Optresults *out, int dorisk)
{
	double	sign;
	double	guess[2];
	int	status;

	if( callflag )
		sign =3D 1.0;
	else
		sign =3D -1.0;

	if( time <=3D 0.0  || vol<=3D 0.0 ){
		out->Premium[0] =3D sign*(fwd-strike)*( sign*(fwd-strike) > 0.0);
		if( time<=3D 0.0 )out->Delta[0] =3D 0.0;
		else		out->Delta[0] =3D sign*( (sign*(fwd-strike)) > 0.0);
		out->Gamma[0] =3D 0.0;
		out->Charm[0] =3D 0.0;
		out->DeltaVega[0] =3D 0.0;
		out->Vega[0] =3D 0.0;
		out->Rho[0] =3D 0.0;
		out->Theta[0] =3D 0.0;
	}

	/** if interest rate is zero, then american price is same as european **/
	else if( r =3D=3D 0.0)
		euro( fwd, strike, time, r, q, vol, callflag, out, 0);

	else	/** the "real" American option case **/
	{
		/* the following lower bounds for r and q set by Krishna on 18Mar96 */
		sign =3D	0.1*EPS;
		if (r<sign)=20
			r =3D sign;
		if (q<sign)=20
			q =3D sign;
		if (callflag )
		{
        		/** find critical commodity price **/
			guess[HI] =3D strike*2.0;
			guess[LO] =3D strike;
			status =3D amercall( guess, fwd, strike, time, r, q, vol, out, dorisk );
		} else {
        		/** find guess for critical commodity price **/
			guess[HI] =3D strike;
			guess[LO] =3D strike/1.4;
			status =3D amerput ( guess, fwd, strike, time, r, q, vol, out, dorisk );
		}
	}
}

double amervol( double fwd, double strike, double r, double q, double time, =
double prem, int callflag)
{
	int	status;
	double 	guess[2];

	if( time <=3D 0.0  )
		return( 0.0 );
	else if( callflag &&  prem =3D=3D fwd-strike  )
		return( 0.0 );
	else if( !callflag &&  prem =3D=3D strike-fwd )
		return( 0.0 );

        /** assumes that guess has already been initialized **/
	guess[LO] =3D 0.12;
	guess[HI] =3D 0.18;

	status =3D fwdbrac( &amimpvol, guess, fwd, strike, r, r-q, time, prem, call=
flag);
	if( status )
		return( -1.0 );
	status =3D findfwd( &amimpvol, guess, fwd, strike, r, r-q, time, prem, call=
flag);
	if( status )
		return( -1.0 );
	else
		return( guess[LO] );
}

/*------------------------------------
 *      amerput
 *----------------------------------- */
int amerput ( double *guess, double fwd, double strike, double time, double =
r, double q, double vol,=20
		Optresults *out, int dorisk )
{
	double	cfwd, b, fn, m, kay, q1, Nnegd1;
	double	amerprem, vegaprem, vegadelt, thetaprem, thetadelt, rhoprem, dummy;
	int	status, dum;

        /** assumes that guess has already been initialized **/
	guess[LO] -=3D GUESSEPS;
	guess[HI] +=3D GUESSEPS;

	b =3D r - q;
	dummy =3D 0.0;
	dum =3D 0;
	status =3D fwdbrac( &amputroot, guess, vol, strike, r, r-q, time, dummy, du=
m);
	status =3D findfwd( &amputroot, guess, vol, strike, r, r-q, time, dummy, du=
m);
	if( status )
		return( status );
	cfwd =3D guess[LO];

	if( fwd <=3D cfwd )		/* fwd <=3D critical price */
	{
		out->Premium[0] =3D strike-fwd;
		out->Delta[0] =3D -1.0;
		out->Gamma[0] =3D 0.0;
		out->Charm[0] =3D 0.0;
		out->DeltaVega[0] =3D 0.0;
		out->Vega[0] =3D 0.0;
		out->Rho[0] =3D 0.0;
		out->Theta[0] =3D 0.0;
		return( 0 );		/* return 0 means success */
	}
=09
	/** remaining case is where fwd > critical price **/

	fn  =3D 1.0 - 2.0*b/(vol*vol);	/* one minus "n" */
	m  =3D 2.0*r/(vol*vol);
	kay =3D 1.0 - exp( -r*time );
	q1 =3D ( fn - sqrt( fn*fn + 4.0*m/kay )) / 2.0;
	Nnegd1 =3D cumnorm( -(log(cfwd/strike)+(b+vol*vol/2.0)* time) / (vol*sqrt(t=
ime)) );

	amerprem =3D (exp(time*(b-r))*Nnegd1 - 1.0) * pow( fwd/cfwd, q1) * cfwd/q1;

	if( dorisk )
	{
		amerput ( guess, fwd, strike, time, r, q, vol+EPS, out, 0);
		vegaprem =3D out->Premium[0];
		vegadelt =3D out->Delta[0];
		amerput ( guess, fwd, strike, time-EPS, r, q, vol, out, 0);
		thetaprem =3D out->Premium[0];
		thetadelt =3D out->Delta[0];
		amerput ( guess, fwd, strike, time, r+EPS, q+EPS, vol, out, 0);
		rhoprem =3D out->Premium[0];

		euro( fwd, strike, time, r, q, vol, PUT, out, 0);
		out->Premium[0] +=3D amerprem;
		out->Delta[0]	+=3D q1 * amerprem/fwd;
		out->Gamma[0]	+=3D q1 * (q1-1.0) * amerprem/(fwd*fwd);
		out->Charm[0]	=3D (thetadelt - out->Delta[0])/EPS;
		out->DeltaVega[0] =3D (vegadelt - out->Delta[0])/EPS;
		out->Vega[0]	=3D (vegaprem - out->Premium[0])/EPS;
		out->Rho[0]	=3D (rhoprem - out->Premium[0])/EPS;
		out->Theta[0]	=3D (thetaprem - out->Premium[0])/EPS;

	} else {		/** do premium, delta only **/
		euro( fwd, strike, time, r, q, vol, PUT, out, 0);
		out->Premium[0] +=3D amerprem;
		out->Delta[0]	+=3D q1 * amerprem/fwd;
	}
	return( status );
}

/*------------------------------------
 *      AmerCall
 *-----------------------------------*/=20
int amercall ( double *guess, double fwd, double strike, double time, double=
 r, double q, double vol,
		Optresults *out, int dorisk )
{
	double	cfwd, b, fn, m, kay, q2, Nd1;
	double	amerprem, vegaprem, vegadelt, thetaprem, thetadelt, rhoprem, dummy;
	int	dum, status;

        /** assumes that guess has already been initialized **/
	guess[LO] -=3D GUESSEPS;
	guess[HI] +=3D GUESSEPS;

	b =3D r - q;
	dummy =3D 0.0;
	dum =3D 0;
	status =3D fwdbrac( &amcallroot, guess, vol, strike, r, r-q, time, dummy, d=
um);
	status =3D findfwd( &amcallroot, guess, vol, strike, r, r-q, time, dummy, d=
um);
	if( status )
		return( status );	/* something went wrong */
	cfwd =3D guess[LO];

	if( fwd >=3D cfwd )		/* fwd >=3D critical price */
	{
		out->Premium[0] =3D fwd-strike;
		out->Delta[0] =3D 1.0;
		out->Gamma[0] =3D 0.0;
		out->Charm[0] =3D 0.0;
		out->DeltaVega[0] =3D 0.0;
		out->Vega[0] =3D 0.0;
		out->Rho[0] =3D 0.0;
		out->Theta[0] =3D 0.0;
		return( 0 );		/* return 0 means success */
	}
=09
	/** remaining case is where fwd < critical price **/
	fn  =3D 1.0 - 2.0*b/(vol*vol);	/* one minus "n" */
	m  =3D 2.0*r/(vol*vol);
	kay =3D 1.0 - exp( -r*time );
	q2 =3D ( fn + sqrt( fn*fn + 4.0*m/kay )) / 2.0;
	Nd1 =3D cumnorm( (log(cfwd/strike)+(b+vol*vol/2.0)* time) / (vol*sqrt(time)=
) );
	amerprem =3D ( 1.0 - exp(time*(b-r)) * Nd1 ) * pow( fwd/cfwd, q2) * cfwd/q2=
;

	if( dorisk )
	{
		amercall( guess, fwd, strike, time, r, q, vol+EPS, out, 0);
		vegaprem =3D out->Premium[0];
		vegadelt =3D out->Delta[0];
		amercall( guess, fwd, strike, time-EPS, r, q, vol, out, 0);
		thetaprem =3D out->Premium[0];
		thetadelt =3D out->Delta[0];
		amercall( guess, fwd, strike, time, r+EPS, q+EPS, vol, out, 0);
		rhoprem =3D out->Premium[0];

		euro( fwd, strike, time, r, q, vol, CALL, out, 0);
		out->Premium[0] +=3D amerprem;
		out->Delta[0]	+=3D q2 * amerprem/fwd;
		out->Gamma[0]	+=3D q2 * (q2-1.0) * amerprem/(fwd*fwd);
		out->Charm[0]	=3D (thetadelt - out->Delta[0])/EPS;
		out->DeltaVega[0] =3D (vegadelt - out->Delta[0])/EPS;
		out->Vega[0]	=3D (vegaprem - out->Premium[0])/EPS;
		out->Rho[0]	=3D (rhoprem - out->Premium[0])/EPS;
		out->Theta[0]	=3D (thetaprem - out->Premium[0])/EPS;

	} else {		/** do premium, delta only **/
		euro( fwd, strike, time, r, q, vol, CALL, out, 0);
		out->Premium[0] +=3D amerprem;
		out->Delta[0]	+=3D q2 * amerprem/fwd;
		out->Gamma[0]	+=3D q2 * (q2-1.0) * amerprem/(fwd*fwd);
	}
	return( status );
}

/*-------------------------------------------------------
 *	amerroot.c
 *
 *-----------------------------------------------------*/
double	amcallroot( double sstar, double vol, double k, double r, double b, d=
ouble time, double dummy, int dum)
{
	double fn, m, kay, q2;
	double result, Nd1star;

	fn  =3D 1.0 - 2.0*b/(vol*vol);	/* one minus "n" */
	m  =3D 2.0*r/(vol*vol);
	kay =3D 1.0 - exp( -r*time );

	q2 =3D ( fn + sqrt( fn*fn + 4.0*m/kay )) / 2.0;
	Nd1star =3D cumnorm( (log(sstar/k)+(b+vol*vol/2.0)* time) / (vol*sqrt(time)=
) );

	result =3D call( sstar, k, time, r, r-b, vol) +=20
		( 1.0 - exp(time*(b-r)) * Nd1star ) * sstar/q2
		+ k - sstar ;

	/** return -result so that function increases with sstar **/
	return( -result );
}

double	amputroot( double sstar, double vol, double k, double r, double b, do=
uble time, double dummy, int dum)
{
	double fn, m, kay, q1;
	double result, Nnegd1;

	fn  =3D 1.0 - 2.0*b/(vol*vol);	/* one minus "n" */
	m  =3D 2.0*r/(vol*vol);
	kay =3D 1.0 - exp( -r*time );

	q1 =3D ( fn - sqrt( fn*fn + 4.0*m/kay )) / 2.0;
	Nnegd1 =3D cumnorm( -(log(sstar/k)+(b+vol*vol/2.0)* time) / (vol*sqrt(time)=
) );

	result =3D put( sstar, k, time, r, r-b, vol) -=20
		( 1.0 - exp(time*(b-r)) * Nnegd1 ) * sstar/q1
		- k + sstar ;

	return( result );
}

/*-------------------------------------------------------
 *	amimpvol.c=20
 *
 *-----------------------------------------------------*/
double	amimpvol ( double vol, double fwd, double k, double r, double b, doub=
le time, double prem, int callflag)
{
	Optresults opt;
	double	newprem, delt, dummy;
=09
	opt.Premium =3D &newprem;
	opt.Delta   =3D &delt;
	opt.Gamma   =3D &dummy;
	opt.Charm   =3D &dummy;
	opt.DeltaVega=3D&dummy;
	opt.Vega    =3D &dummy;
	opt.Rho     =3D &dummy;
	opt.Theta   =3D &dummy;

	amer( fwd, k, time, r, r-b, vol, callflag, &opt, NORISK);
	return( newprem - prem );
}

/*----------------------------------------------------------------------
 *
 *	fwdbrac.c
 *
 *	Brackets critical price for American option approximation.
 *
 *--------------------------------------------------------------------*/

int fwdbrac(double (*func)(), double *sp, DECARGS )
{
	int j;
	double f1,f2;

	if (sp[HI] =3D=3D sp[LO])=20
		if( sp[HI] =3D=3D 0.0 )
			sp[HI] +=3D EPS;
		else
			sp[HI] =3D sp[LO] * FACTOR;

	f1=3D(*func)(sp[LO], ARGS);
	f2=3D(*func)(sp[HI], ARGS);

	for (j=3D1;j<=3DNTRY;j++) {
		if (f1*f2 < 0.0) return 0; /* return 0 means success */

		/* func() is increasing function of s */
		if ( f1 < 0.0 )
		{
			sp[HI] +=3D FACTOR*(sp[HI]-sp[LO]);
			f1=3D(*func)(sp[HI], ARGS);
		}
		else
		{
			sp[LO] -=3D FACTOR*(sp[HI]-sp[LO]);
			if( sp[LO] <=3D 0.0 ) {
				if( sp[LO] > EPS ) sp[LO]  =3D EPS;
				else		   sp[LO] *=3D 0.1;
			}
			f2=3D(*func)(sp[LO], ARGS);
		}
	}
	return -1;
}


int findfwd ( double (*func)(), double *sp, DECARGS )=20
{
	int iter;
	double a,b,c,d,e,min1,min2;
	double fa,fb,fc,p,q,r,s,tol1,xm;

	a =3D sp[LO];
	b =3D sp[HI];

	fa=3D(*func)( a, ARGS );
	fb=3D(*func)( b, ARGS );

	/** Root must be bracketed. **/
	if (fb*fa > 0.0) return(-10);

	fc=3Dfb;
	for (iter=3D1;iter<=3DITMAX;iter++) {
		if (fb*fc > 0.0) {
			c=3Da;
			fc=3Dfa;
			e=3Dd=3Db-a;
		}
		if (fabs(fc) < fabs(fb)) {
			a=3Db;
			b=3Dc;
			c=3Da;
			fa=3Dfb;
			fb=3Dfc;
			fc=3Dfa;
		}
		tol1=3D2.0*NEWEPS*fabs(b)+0.5*TOL;
		xm=3D0.5*(c-b);
		if (fabs(xm) <=3D tol1 || fb =3D=3D 0.0) {
			/** set both input guesses to the answer **/
			sp[LO] =3D sp[HI] =3D b;
			/** return 0 means success **/
			return 0;
		}
		if (fabs(e) >=3D tol1 && fabs(fa) > fabs(fb)) {
			s=3Dfb/fa;
			if (a =3D=3D c) {
				p=3D2.0*xm*s;
				q=3D1.0-s;
			} else {
				q=3Dfa/fc;
				r=3Dfb/fc;
				p=3Ds*(2.0*xm*q*(q-r)-(b-a)*(r-1.0));
				q=3D(q-1.0)*(r-1.0)*(s-1.0);
			}
			if (p > 0.0)  q =3D -q;
			p=3Dfabs(p);
			min1=3D3.0*xm*q-fabs(tol1*q);
			min2=3Dfabs(e*q);
			if (2.0*p < (min1 < min2 ? min1 : min2)) {
				e=3Dd;
				d=3Dp/q;
			} else {
				d=3Dxm;
				e=3Dd;
			}
		} else {
			d=3Dxm;
			e=3Dd;
		}
		a=3Db;
		fa=3Dfb;
		if (fabs(d) > tol1)
			b +=3D d;
		else
			b +=3D (xm > 0.0 ? fabs(tol1) : -fabs(tol1));

		fb=3D(*func)( b, ARGS );
	}
	return(-11);
	/** Maximum number of iterations exceeded without finding root **/
}

#undef ITMAX
#undef EPS
#undef NEWEPS
#undef FACTOR
#undef NTRY
#undef LO
#undef HI
#undef ARGS
#undef DECARGS


--------------000506070003020302060604
Content-Type: text/plain; name="Annualst.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Annualst.c"

/*---------------------------------------------------
 *
 *	file: annualstrip.c
 *
 *	One Year Strip of Daily Call Options
 *	subject to daily, monthly, yearly take constraints.
 *
 *	V0.0	11sep93	 psg
 *
 *	Calculates premium
 *
 * 	s         spot prices    =20
 * 	k         strike prices =20
 * 	r         interest rates
 * 	vol       annualized volatilities
 *	tosetdate days to beginning of period (days to forward start)
 * 	begin     days from beginning of period to beginning of strip
 * 	end       days from beginning of period to end of strip
 *	dailyqty  maximum daily swing quantity
 *	annoptq   maximum annual option qty.
 *  callflag  1=3Dcall 0=3Dput
 *	maxmon    number of months in the strip
 *
 *	bidflag is tens digit of "flag"
 *	bidflag   0 =3D max value strip
 *	          1 =3D ave value strip
 *	          2 =3D min value strip
 *
 *	risk is ones unit of "flag" and indicates return value type:
 *	risk	0 =3D premium
 *			1 =3D delta of forward start options
 *			2 =3D delta of fixed strike  options

    COPYRIGHT C 1993, BY ENRON GAS SERVICES, ALL RIGHTS RESERVED.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON GAS SERVICES.
-----------------------------------------------------*/

#include  <math.h>

#define   MAXDAYS	366

double annualstrip2( s, k, r, vol, tosetdate, begin, end, dailyqty,
                     annoptq, callflag, maxmon, flag  )
double *s, *k, *r, *vol, *tosetdate, *begin, *end, *dailyqty;
double annoptq;
int    callflag, maxmon, flag;
{
    double time, disc;
    double callr(), putr();
	void shellsort(int, double *, int *);

    double fwd=3D0.0, total, qty, dayval[MAXDAYS], greek[MAXDAYS][7];
    double fwdpr[MAXDAYS];
    double  dayqty[MAXDAYS];
    int    bidflag, risk, riskminus;
    int    nd, day, maxday, m, n[MAXDAYS];


    bidflag =3D flag/10;
    risk    =3D flag%10;

    /****  Find the value of each day allowed by the daily and monthly takes=
 ****/

    day =3D 0;
    if( callflag )
    {
        for( m=3D0; m<maxmon; m++)
        {
    	    disc =3D exp(-r[m]*tosetdate[m]/365.25);

            for( time=3Dend[m]; time>=3D(begin[m]+1.0); time-=3D1.0)
	    {
	        dayval[day] =3D disc*callr( s[m], k[m], time, r[m], r[m], vol[m], &=
(greek[day][0]) );
		fwdpr[day]    =3D s[m];
	        dayqty[day++] =3D dailyqty[m];
	    }
            if( time > begin[m] )
	    {
	        dayval[day] =3D disc*callr( s[m], k[m], time, r[m], r[m], vol[m], &=
(greek[day][0]) );
		fwdpr[day]    =3D s[m];
	        dayqty[day++] =3D dailyqty[m] * (time-begin[m]);
	    }
	    maxday =3D day - 1;
        }
    } else {
        for( m=3D0; m<maxmon; m++)
        {
    	    disc =3D exp(-r[m]*tosetdate[m]/365.25);

            for( time=3Dend[m]; time>=3D(begin[m]+1.0); time-=3D1.0)
	    {
	        dayval[day] =3D disc*putr( s[m], k[m], time, r[m], r[m], vol[m], &(=
greek[day][0]) );
		fwdpr[day]    =3D s[m];	=09
	        dayqty[day++] =3D dailyqty[m];
	    }
            if( time > begin[m] )
	    {
	        dayval[day] =3D disc*putr( s[m], k[m], time, r[m], r[m], vol[m], &(=
greek[day][0]) );
		fwdpr[day]    =3D s[m];
	        dayqty[day++] =3D dailyqty[m] * (time-begin[m]);
	    }
	    maxday =3D day - 1;
        }
    }

    /****  Order the daily options by value ****/

shellsort( maxday, dayval, n);
=20
/****  Add up the daily option quantities until we fill the maximum possible=
 strip.  ****/

    qty =3D annoptq;
    total =3D 0.0;

    if( risk<2 ){				/** calc premium and delta **/
      if( bidflag =3D=3D 0 )			/** find maximum value strip **/
      {
	day =3D maxday-1;
	while( day>=3D0  &&  qty>0 )
	{
	    nd =3D n[day];
	    if( dayqty[nd] < qty )
	    {
		total +=3D dayqty[nd]*dayval[nd];
		fwd   +=3D dayqty[nd]*greek[nd][0];
		qty   -=3D dayqty[nd];
	    }
	    else
	    {
		total +=3D qty*dayval[nd];
		fwd   +=3D qty*fwdpr[day];
		qty    =3D 0.0;
	    }
	    day--;
	}
      }/** bidflag=3D=3D0 **/

      else if( bidflag =3D=3D 1 )			/** find average value strip **/
      {
	day =3D 0;
	qty =3D 0.0;
	while( day<maxday )
	{
	    total +=3D dayqty[day]*dayval[day];
	    fwd   +=3D dayqty[day]*fwdpr[day];
	    qty   +=3D dayqty[day++];
	}
	total *=3D annoptq/qty;
      }/** bidflag=3D=3D1 **/

      else if( bidflag =3D=3D 2 )			/** find minimum value strip **/
      {
        day =3D 0;
        while( day<maxday &&  qty>0 )
        {
	  nd =3D n[day];
	  if( dayqty[nd] < qty )
	  {
		total +=3D dayqty[nd]*dayval[nd];
		fwd   +=3D dayqty[nd]*fwdpr[day];
		qty   -=3D dayqty[nd];
	  }
	  else
	  {
		total +=3D qty*dayval[nd];
		fwd   +=3D qty*fwdpr[day];
		qty    =3D 0.0;
	  }
	  day++;
        }
      }/** bidflag=3D=3D2 **/
      if( risk=3D=3D0 )
      	return( total );
      else /** risk=3D=3D1 **/
	return( total/fwd );
    } else {					/** risk>1 **/
	/** Note: for delta of fixed strike option, risk=3D2 and riskminus=3D0 **/

      riskminus =3D risk - 2;
      if( bidflag =3D=3D 0 )			/** find maximum value strip **/
      {
	day =3D maxday-1;
	while( day>=3D0  &&  qty>0 )
	{
	    nd =3D n[day];
	    if( dayqty[nd] < qty )
	    {
		total +=3D dayqty[nd]*greek[nd][riskminus];
		qty   -=3D dayqty[nd];
	    }
	    else
	    {
		total +=3D qty*greek[nd][riskminus];
		qty    =3D 0.0;
	    }
	    day--;
	}
      }/** bidflag=3D=3D0 **/

      else if( bidflag =3D=3D 1 )			/** find average value strip **/
      {
	day =3D 0;
	qty =3D 0.0;
	while( day<maxday )
	{
	    total +=3D dayqty[day]*dayval[day];
	    qty   +=3D dayqty[day++];
	}
	total *=3D annoptq/qty;
      }/** bidflag=3D=3D1 **/

      else if( bidflag =3D=3D 2 )			/** find minimum value strip **/
      {
        day =3D 0;
        while( day<maxday &&  qty>0 )
        {
	    nd =3D n[day];
	    if( dayqty[nd] < qty )
	    {
		total +=3D dayqty[nd]*greek[nd][riskminus];
		qty   -=3D dayqty[nd];
	    }
	    else
	    {
		total +=3D qty*greek[nd][riskminus];
		qty    =3D 0.0;
	    }
	    day++;
        }
      }/** bidflag=3D=3D2 **/
      total /=3D annoptq;
      return( total );
    }
}

/***********************
main()
{
double s[2], k[2], r[2], vol[2], tosetdate[2], begin[2], end[2], dailyqty[2]=
;
double annoptq;
int    callflag, maxmon, flag;
double annualstrip2();


s[0]=3D 2.00;
s[1]=3D 2.20;
k[0]=3D 2.00;
k[1]=3D 2.20;
r[0]=3D 0.03;
r[1]=3D 0.04;
vol[0]=3D 0.25;
vol[1]=3D 0.30;
tosetdate[0] =3D 22;
tosetdate[1] =3D 51;
begin[0]=3D 20;
begin[1]=3D 20;
end[0]=3D 31;
end[1]=3D 32;
dailyqty[0] =3D 10000;
dailyqty[1] =3D 10000;
annoptq =3D  120000;
callflag =3D 1;
maxmon=3D2;
flag=3D1;

annualstrip2( s, k, r, vol, tosetdate, begin, end, dailyqty,
                     annoptq, callflag, maxmon, flag  );
flag=3D0;
annualstrip2( s, k, r, vol, tosetdate, begin, end, dailyqty,
                     annoptq, callflag, maxmon, flag  );
}
*************/

--------------000506070003020302060604
Content-Type: text/plain; name="Asgeompu.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Asgeompu.c"

/*--------------------------------------------------------

  file: /usr/user/stinsong/util/optlibsrc/asgeomput.c

  V0.0  30apr1993
  V0.1   6may1993  corrected case where drift rate (r) !=3D 0 -psg

  B/S Geometric Average Model -- Put=20
  Drift rate =3D 0 version for commodity futures.

  Uses a  closed form solution for the Asian option
  on the geometric average.

  NB. Returns the NON-DISCOUNTED option value.

  inputs:
     s    spot price
     k    strike price
     expd days to expiration
     toave  days to start of averaging
     r    rate of return on underlying
            ( =3D 0.0 for commodity futures )
     vol1 annual volatility

    COPYRIGHT C 1993, BY ENRON GAS SERVICES, ALL RIGHTS RESERVED.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON GAS SERVICES.
---------------------------------------------------------*/

#include  <math.h>

double asgeomput( s, k, expd, toave, r, vol1 )
double s, k, expd, toave, r, vol1;
{
    double time, dst, rv, negd1, negd, Nd, Nd1, putg;
    double cumnorm();
    time =3D expd/365.25;
    toave /=3D 365.25;
    rv =3D 0.5*r*(time+toave) + (vol1*vol1*(time+5.*toave)/12.);
    negd =3D -(log(s/k)+ rv ) / (vol1*sqrt((time+2*toave)/3) );
    dst =3D 0.5*( r*(time+toave) - (vol1*vol1/6.)*(time-toave) );
    negd1 =3D negd + vol1*sqrt((time+2*toave)/3);
    Nd=3D cumnorm(negd);
    Nd1 =3D cumnorm(negd1);
    putg =3D k*Nd1 - exp(dst)*s*Nd ;=20
    return(putg);
}

--------------000506070003020302060604
Content-Type: text/plain; name="AsianStrip.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="AsianStrip.c"

/*--------------------------------------------------------------------------=
--

  file: AsianStrip.c

  analytical approximation for premium, finite-diff greeks. -psg


----------------------------------------------------------------------------=
-*/

#include	<stdio.h>
#include	<math.h>
#include    <stdlib.h>
#include	"nrutil.h"

#define	fmax(A, B)	((A) > (B) ? (A) : (B))
#define	fmin(A, B)	((A) < (B) ? (A) : (B))


#define	DllImport	__declspec(dllimport)
#define DllExport	__declspec(dllexport)

#define		EPS	0.0001

#define		PREMIUM	0
#define		DELTA	1
#define		GAMMA	2
#define		VEGA	3
#define		RHO		4


// function prototypes
double asianstr2 (
				  double *s,=20
				  double k,=20
				  double r,=20
				  double *vlin,=20
				  double rhoc,=20
				  double setprice,
				  int	 *settles,=20
				  int	 setdays,=20
				  double *sta,=20
				  double *toend,=20
				  double expd,
				  int	 flag,=20
				  int	 nassets
				 );


double AsianStrip(
			double *fwd,	 /* forward prices 			*/
			double Strike,	 /* strike price 			*/
			double IntRt, 	 /* interest rate to expiry	*/
			double *vol,	 /* volatilities			*/
			double Rho,		 /* correlation				*/
			double SetPr,	 /* average price to date	*/
			int    *settles, /* number of price samples for each asset */
			int    setdays,	 /* number of price samples determined	   */
			double ExpDt, 	 /* calendar days to expiration		*/
			double *begin,	 /* days to beging avg				*/
			double *end,	 /* days to end avg					*/
			int    flag,	 /* 0 =3D put, 1 =3D call,				*/
			int    nmonths,	 /* number of forward prices in avg	*/
			int    risk, 	 /* specify return value type		*/
			int	   retmonth	 /* return month for greeks			*/
						   )
{
    double	prem, value, retval;
    double  prems, deltanew;
    double	*shift;
    int		cflag, i;

    cflag =3D flag%10;
    prem =3D  asianstr2(
						fwd, Strike, IntRt, vol, Rho, SetPr, settles,=20
						setdays, begin, end, ExpDt, cflag, nmonths
					 );
    switch (risk)
    {
        case (PREMIUM):
		{
			retval =3D prem;
			break;
		}
=09
		case (RHO):
		{
			retval =3D (asianstr2 (
							   fwd, Strike, IntRt+EPS, vol, Rho, SetPr, settles,=20
							   setdays, begin, end, ExpDt, cflag, nmonths
							    )
					  - prem) / EPS;
			break;
		}
       =20
		case (VEGA):
		{
			vol[retmonth-1] *=3D (1.0 + EPS);
			retval =3D (asianstr2 (
									fwd, Strike, IntRt, vol, Rho, SetPr, settles,=20
									setdays, begin, end, ExpDt, cflag, nmonths
								)=20
					  - prem) / (vol[retmonth-1]*EPS);

			// step back -- Zimin 7/11/97
			vol[retmonth-1] /=3D (1.0 + EPS);
			break;
		}
       =20
		case (DELTA):   =20
        case (GAMMA):
		{
			fwd[retmonth-1] +=3D EPS;
			retval =3D (asianstr2 (=20
									fwd, Strike, IntRt, vol, Rho, SetPr, settles,=20
									setdays, begin, end, ExpDt, cflag, nmonths
								 )
					  - prem) / EPS;
			fwd[retmonth-1] -=3D EPS;
			if (risk =3D=3D GAMMA )
			{
				shift =3D dvector(0, nmonths-1);
				for (i =3D 0; i < nmonths; i++)
				{
					shift[i] =3D fwd[i] + EPS;
				}
    			value =3D asianstr2 (
								shift, Strike, IntRt, vol, Rho, SetPr, settles,=20
								setdays, begin, end, ExpDt, cflag, nmonths
								  );
 =20
				shift[retmonth-1] +=3D EPS;
    			prems =3D asianstr2 (
									shift, Strike, IntRt, vol, Rho, SetPr, settles,=20
									setdays, begin, end, ExpDt, cflag, nmonths
								  );
				deltanew =3D (prems - value) / EPS;
				retval =3D (deltanew - retval) / EPS;
				free_dvector(shift, 0, nmonths-1);
			}
			break;
		}
	}
	return retval;
}
#undef EPS

--------------000506070003020302060604
Content-Type: text/plain; name="Astr2.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Astr2.c"

/*-------------------------------------------------------------

  file: asianstr2.c

  modify asianstr.c to update to flexible time inputs

   =20
------------------------------------------------------------------------*/

#include  <malloc.h>
#include  <stdio.h>
#include  <math.h>

double asianstr2(
	double	*s,		/* price of Underlying 	 		*/
	double	k,		/* Strike               		*/
	double	r,		/* annualized cost of money, for discounting */
	double	*volin,		/* annualized volatility, eg. 0.30 	*/
	double	rhoc,		/* contemporaneous correlation 		*/
	double	setprice,	/* Ave. price of underlying already set, if into averaging=
 period */
	int	*settles,	/* number of price samples from each asset */
	int	setdays,
	double	*sta,		/* time (years) until next point in average */
	double	*toend,		/* time (years) until end of averaging 		*/
	double	expd, 		/* settlement date of option (used for discounting) */
	int     flag,		/* 1=3DCall, 0=3DPut  */
	int	nassets		/* number of elements in *s, *volin, *sta, *toend vectors */
	)
{
	double          kold, unsetprice, vol, prem, nfac;
	double          rho, avg =3D 0.0, vara =3D 0.0, endavg =3D 0.0;
	double		*sig;
	int             *newsettles, days, asset, daysleft, totdays=3D0, newm, i, j=
;
	double          euroopt();
	int		off;

	for (i =3D 0; i < nassets; i++) {
		totdays +=3D settles[i];
		if( totdays > setdays ){
			if( sta[i] < 0.0 )
				sta[i] =3D 0.0;
		}
		if (toend[i] > endavg)
			endavg =3D toend[i];
	};
	daysleft =3D totdays - setdays;

	if( endavg <=3D 0.0 )				/* the averaging period is completely over */
	{
		avg =3D setprice;
		if (flag)	/** call **/
		{
			if( avg > k ) 	prem =3D avg - k;
			else		prem =3D 0.0;
		}
		else		/** put  **/
		{
			if( avg < k ) 	prem =3D k - avg ;
			else		prem =3D 0.0;
		}
		if (expd > 0.0 )
			prem *=3D exp(-r*expd);
	}
	else if (setdays =3D=3D 0.0)			/* if averaging period has not started */
	{
		sig =3D (double*) calloc( (unsigned)nassets, sizeof(double) );
		for (i =3D 0; i <nassets; i++) {

			nfac =3D (settles[i]-0.5)/settles[i];
			avg +=3D settles[i] * s[i];

			sig[i] =3D settles[i] * s[i] * volin[i] * sqrt(nfac*(toend[i]-sta[i])/3.0=
 + sta[i]);
			vara +=3D sig[i] * sig[i];

			for (j =3D 0; j < i; j++) {
				if (toend[i] < toend[j])
					rho =3D rhoc * sqrt(toend[i] / toend[j]);
				else
					rho =3D rhoc * sqrt(toend[j] / toend[i]);
				vara +=3D 2.0 * sig[i] * sig[j] * rho;
			}
		}
		avg /=3D totdays;
		vol =3D sqrt(vara/endavg)/(totdays*avg);

		if (flag)
			prem =3D euroopt(avg, k, endavg, r, r, vol, 1, 0);
		else
			prem =3D euroopt(avg, k, endavg, r, r, vol, 0, 0);

		if (expd !=3D endavg)
			prem *=3D exp(-r*(expd-endavg));
		free((char *) sig);

	} else if ( setdays > 0 )	/* else, we are in averaging period 	*/
	{
		newsettles=3D (int *) calloc( (unsigned)nassets, sizeof(int) );
		days =3D 0;
		newm =3D 0;
		unsetprice =3D 0.0;

		for (asset=3D0; asset<nassets; asset++) {
			if (setdays >=3D days)	/* some prices for this asset have set */
			{	 	 				=09
				days +=3D settles[asset];
				if (setdays < days)/* all days for asset have set */
				{
					newsettles[newm++] =3D days - setdays;
					unsetprice +=3D s[asset]*(days - setdays);
				}
			} else				/* no days for this component have set	*/
			{
				newsettles[newm++] =3D settles[asset];
				unsetprice +=3D s[asset]*settles[asset];
			}
		}

		/* adjust strike price for option decomposition */
		kold =3D k;
		k    =3D ( totdays*kold - setdays*setprice ) / (totdays-setdays) ;
		if( k < 0.0 ){	/** if effective strike is negative, then treat as a forwar=
d **/
			avg =3D ( setprice*setdays+ unsetprice) / totdays;
			if (flag)	/** call **/
			{
				if( avg > kold )prem =3D avg - kold;
				else		prem =3D 0.0;
			}
			else		/** put  **/
			{
				if( avg < kold )prem =3D kold - avg ;
				else		prem =3D 0.0;
			}
			if (expd > 0.0 )
				prem *=3D exp(-r*expd);
		} else {	/** k>0 so value as an option **/

			off =3D nassets - newm;
			prem =3D asianstr2( s+off, k, r, volin+off, rhoc, setprice, newsettles, 0=
, sta+off, toend+off, expd, flag, newm);
			prem *=3D (double)(totdays-setdays)/(double)totdays;
			/* removed next two lines, in consultation with stinson,
			since this gets done in the recursive call -- vs
			if (expd !=3D endavg)
				prem *=3D exp(r * (endavg-expd)); */
		}
		free((char *) newsettles);
	}
	return( prem );
}

--------------000506070003020302060604
Content-Type: text/plain; name="Astripo.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Astripo.c"

/*-------------------------------------------------------------

  file: asianstrip_opt.c

  analytical approximation for premium, finite-diff greeks. -psg


------------------------------------------------------------------------*/

#include  <stdio.h>
#include  <math.h>
#include  <malloc.h>
#include  "option.h"

#define EPS			0.0001

double asianstr2( double *s, double k, double r, double	*volin, double rhoc,=
 double setprice,
		 int *settles, int setdays, double *sta, double	*toend, double expd,
		 int flag, int nassets);


void asianstrip2(	double fwd[],	/* forward prices 		*/
			double Strike,	/* strike price 		*/
			double IntRt, 	/* interest rate to expiry	*/
			double vol[],	/* volatilities			*/
			double Rho,	/* correlation			*/
			double SetPr,	/* average price to date	*/
			int    settles[], /* number of price samples for each asset */
			int    setdays, /* number of price samples determined */
			double ExpDt, 	/* calendar days to expiration	*/
			double begin[],	/* days to beging avg		*/
			double end[],	/* days to end avg		*/
			int    flag,	/* 0 =3D put, */
					/* 1 =3D call,*/
			int    nmonths, /* number of forward prices (assets) in avg */
			int    risk, 	 /* specify return value type, see enum above */
			Optresults *out)/* structure containing results	*/

{
    double	prem, value, epsilon;
    double      prems, deltanew;
    double	*shift;
    int		cflag, i;

    cflag =3D flag%10;
    prem =3D asianstr2(fwd, Strike, IntRt, vol, Rho, SetPr, settles, setdays=
, begin, end, ExpDt, cflag, nmonths);
    out->Premium[0] =3D prem;

    switch( risk )
    {
        case ( OPT_PREMIUM ):
	{
		break;
	}
	case ( OPT_ETA ):
	{
		out->Eta[0] =3D (asianstr2( fwd, Strike, IntRt, vol, Rho+EPS, SetPr, settl=
es, setdays, begin, end, ExpDt, cflag, nmonths)=20
			- prem )/EPS;
		break;
	}
	case ( OPT_RHO ):
	{
	out->Rho[0] =3D (asianstr2( fwd, Strike, IntRt+EPS, vol, Rho, SetPr, settle=
s, setdays, begin, end, ExpDt, cflag, nmonths)
			- prem )/EPS;
		break;
	}
        case ( OPT_THETA ):
	{
		break;
	}
        case ( OPT_VEGA ):
	{
		for( i=3D0; i<nmonths; i++)
		{
			epsilon =3D vol[i]*EPS;
			vol[i] +=3D epsilon;
			out->Vega[i] =3D (asianstr2( fwd, Strike, IntRt, vol, Rho, SetPr, settles=
, setdays, begin, end, ExpDt, cflag, nmonths)=20
					- prem )/epsilon;
			vol[i] -=3D epsilon;
		}
		break;
	}
        case ( OPT_DELTA ):   =20
        case ( OPT_GAMMA ):
	{
    		epsilon =3D 0.0;
    		for( i=3D0; i<nmonths; i++)
			epsilon +=3D fwd[i]*EPS;
    		epsilon /=3D (double)nmonths;

		for( i=3D0; i<nmonths; i++){
			fwd[i] +=3D epsilon;
			out->Delta[i] =3D (asianstr2( fwd, Strike, IntRt, vol, Rho, SetPr, settle=
s, setdays, begin, end, ExpDt, cflag, nmonths)
					- prem)/ epsilon;
			fwd[i] -=3D epsilon;
		}
		if( risk =3D=3D OPT_GAMMA ){
		    shift    =3D (double *) calloc( (unsigned)nmonths, sizeof(double) );
		    for( i=3D0; i<nmonths; i++)
			shift[i] =3D fwd[i] + epsilon;
    		    value =3D asianstr2(shift, Strike, IntRt, vol, Rho, SetPr, settles=
, setdays, begin, end, ExpDt, cflag, nmonths);
		    for( i=3D0; i<nmonths; i++){
			shift[i] +=3D epsilon;
    			prems =3D asianstr2(shift, Strike, IntRt, vol, Rho, SetPr, settles, s=
etdays, begin, end, ExpDt, cflag, nmonths);
			deltanew =3D (prems - value)/epsilon;
			out->Gamma[i] =3D (deltanew - out->Delta[i]) / epsilon;
			shift[i] -=3D epsilon;
		    }
		    free( (char *) shift);
		}
		break;
	}
    }/* switch */

}
#undef EPS

--------------000506070003020302060604
Content-Type: text/plain; name="Baropt.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Baropt.c"

/*-------------------------------------------------------------

  file: baropt.c

      rvalues[] =3D  premium,   	   [0]

 Not Implemented!! delta           [1]
 Not Implemented!! gamma           [2]
 Not Implemented!! lambda (vega)   [3]
 Not Implemented!! rho             [4]
 Not Implemented!! theta           [5]
 Not Implemented!! uncert          [6]
 Not Implemented!! geom. avg.      [7]
 Not Implemented!! Monte-Carlo prem[8]  ie. without control-variates

    COPYRIGHT C 1993, BY ENRON GAS SERVICES, ALL RIGHTS RESERVED.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON GAS SERVICES.
------------------------------------------------------------------------*/

#include  <stdio.h>
#include  <math.h>
#include  <stdlib.h>=20

#define MAXTS           3010	/* max number of time steps + 10 */
#define MAXPER          3000.	/* maximum number of periods used in simulatio=
n */
#define DAYSYR			365.25	/* calendar days in a year */
#define DELTAEPS		0.005
#define VOLEPS          0.001

void baropt(s, k, r, volin, ko, rebate, expd, stako, endko, max, callput, in=
out, rvalues)
	double          s,	/* price of Underlying 	 */
	                k,	/* Strike               */
	                r,	/* annualized cost of money, for discounting */
	                volin,	/* annualized volatility, eg. 0.30 	 */
	                ko,	/* outstrike (knock-out price) */
	                rebate,	/* rebate issued when option is knocked out */
	                expd,	/* days until option expiration */
	                stako,	/* days until start of knock-out period */
	                endko,	/* days until end of ko peroid */
	               *rvalues;/* return values, see above explanation */
	int             max,	/* number of Monte-Carlo iterations, also seed */
	                callput,/* 1 if call,  0 if put */
	                inout;	/* 1 if in,    0 if out */
{
	int             updown,	/* 1 if up-and-in/out, 0 if down-and-in/out option =
*/
					kostep,	stasim, endsim, delt, i, n, j, seed;
	double          out[MAXTS], opt, sum, a3, avg, t, halfvar;
	double          pv;
	double          vol0,	/* volatility over start days */
	                vol,	/* volatility over ave period steps */
	                halfvar0, kolimit;
	double          pr, suma, sumg, sumd, fd;
	double          cvput(), asgeomput();
	void            getrvs2();

	/* ADDED FOR CALCULATION OF RISK PARAMETERS * */
	double          time, va3, vpr, voldelt, voldsq, sdsq =3D 0.0;
	double          vsum =3D 0.0, vsumd =3D 0.0;
	double          sumdlo =3D 0.0, sumdhi =3D 0.0;

	voldelt =3D 1.0 + VOLEPS;
	voldsq =3D voldelt * voldelt;

	seed =3D max;
	srand(seed);

	if( ko > s )
		updown =3D 1;
	else
		updown =3D 0;

	/*
	 * if aver period is longer than MAXPER days, then divide averaging
	 * period into MAXPER time steps
	 */

	stasim =3D (int) stako;
	endsim =3D (int) endko;

	if (stasim > 0.0) {	/* if averaging and ko period have not started */
		if (endsim - stasim > MAXPER)
			t =3D (endsim - stasim) / MAXPER;
		else
			t =3D 1.0;
		delt =3D (int) ((endsim - stasim) / t);
		vol0 =3D volin / sqrt(DAYSYR / (stasim));
		halfvar0 =3D vol0 * vol0 / 2.0;

	} else {		/* else, ave or ko period already started */
		if (endsim > MAXPER)
			t =3D endsim / MAXPER;
		else
			t =3D 1.0;
		delt =3D (int) (endsim/ t);

		/*
		 * if averaging period has already started, adjust strike
		 * price for option decomposition
		 */
	}

	n =3D 4 + (delt / 2);
	vol =3D volin / sqrt(DAYSYR / t);	/* vol is t-day volatility */
	halfvar =3D 0.5 * vol * vol;
	fd =3D (exp(-r * expd / DAYSYR));

	suma =3D sumg =3D sdsq =3D sumd =3D 0.0;

	kolimit =3D log(ko) - log(s);

	for (j =3D 0; j < max; j++) {	/* construct price histories */
		getrvs2(out, n);/* returns 2n random numbers drawn from N(0,1) */

		a3 =3D va3 =3D sum =3D pr =3D vsum =3D vpr =3D 0.0;
		kostep =3D -1;

		if (stasim > 0.0) {
			a3 =3D (vol0 * out[delt]) - halfvar0;
			va3 =3D (vol0 * out[delt] * voldelt) - halfvar0 * voldsq;
		}
		for (i =3D 0; i < delt; i++) {
			a3 +=3D (vol * out[i]) - halfvar;
			va3 +=3D (vol * out[i] * voldelt) - halfvar * voldsq;

			if(updown) {			/* if option is up-and-inout */
				if (a3 > kolimit){	/* option gets knocked    */
					kostep =3D i;
					i =3D delt;
				}
			} else {				/* if option is down-and-inout */
				if (a3 < kolimit){	/* option gets knocked */
					kostep =3D i;
					i =3D delt;
				}
			}
		}

		if( kostep > -1  &&  kostep < delt-1 ) {
		/** if kostep is set  and  kostep was set before the last time step **/
		=09
			time =3D (delt-kostep)*t;
			a3 +=3D (vol * out[i] * sqrt(time)) - halfvar*time;
            va3 +=3D (vol * out[i] * voldelt * sqrt(time)) - halfvar*time * =
voldsq;
		}

		/******** now do sums for option valuation  *********/

		/* check to see if option is active on expiry */

		if ( (inout && kostep >=3D 0)  ||			/* knock-in  is knocked   OR */
			 (!inout && kostep < 0)      ) {	/* knock-out is not knocked */

			avg =3D s * exp(a3);
			if( callput )
				pv =3D (avg - k);		/* option is a call */
			else
				pv =3D (k - avg);		/* option is a put  */

			opt =3D pv * (pv > 0);

		} else {					/* option is dead on expiry, check for rebate */
			if( inout )
				opt =3D rebate;		/* knock-in rebate is paid on expiration */
			else					/* knock-out rebate is paid on knock-out  */
				opt =3D exp( r*(delt-kostep)*t/DAYSYR ) * rebate;
		}

		suma +=3D opt;

		/********************************************************comment all out
		/********* Now do sums for risk parameters ********+/
	=09
		        sumd +=3D optd;
		        sdsq +=3D optd*optd;
	=09
		/*  delta and gamma calculation +/
	=09
		        pv =3D (avg*(1.0+DELTAEPS)-k);
		        pvg=3D (avgg*(1.0+DELTAEPS)-k);
	=09
		        opt   =3D pv*(pv>0);
		        optg  =3D pvg*(pvg>0);
		        optd  =3D opt-optg;
		        sumdhi +=3D optd;
	=09
		        pv =3D (avg*(1.0-DELTAEPS)-k);
		        pvg=3D (avgg*(1.0-DELTAEPS)-k);
	=09
		        opt   =3D pv*(pv>0);
		        optg  =3D pvg*(pvg>0);
		        optd  =3D opt-optg;
		        sumdlo +=3D optd;
	=09
		/*  lambda (vega) calculation +/
	=09
		        avg=3Ds*vsum/((float)(delt+1));
		        avgg=3Dvpr/((float)(delt+1));
		        avgg=3Ds*exp(avgg);
		        pv =3D (avg-k);
		        pvg=3D (avgg-k);
		        opt   =3D pv*(pv>0);
		        optg  =3D pvg*(pvg>0);
		        optd  =3D opt-optg;
		        vsumd +=3D optd;
		*****************************************************************/

	}			/* end of loop for price histories */

	suma *=3D fd / max;

	rvalues[0] =3D suma;

	/**************************************************************************=
*****
	    sumg  *=3D fd / max;
	    sumd  *=3D fd / max;
	    uncert =3D sqrt( (fd*fd*(sdsq/max) - sumd*sumd)/(max-1.0) );
=09
	    sumdlo  *=3D fd / max;
	    sumdhi  *=3D fd / max;
=09
	    vsumd *=3D fd / max;
=09
	    if( stako<0 )
	    	effstako =3D 0.0;
	    else
			effstako =3D stako;
	    vputag  =3D vsumd  + fd * asgeomput ( s, k, expd, effstako, 0.0, volin*=
voldelt );
	    putaghi =3D sumdhi + fd * asgeomput ( s*(1.0+DELTAEPS), k, expd, effsta=
ko, 0.0, volin );
	    putaglo =3D sumdlo + fd * asgeomput ( s*(1.0-DELTAEPS), k, expd, effsta=
ko, 0.0, volin );
=09
	    putg    =3D fd * asgeomput ( s, k, expd, effstako, 0.0, volin );
	    putag =3D sumd+putg;
=09
	    if( stako<0 ) {
			fac       =3D (endko+1.0) / (endko-stako+1.0);
	    	vputag  *=3D fac;
	    	putaghi *=3D fac;
	    	putaglo *=3D fac;
	    	putag   *=3D fac;
			putg    *=3D fac;
			suma     *=3D fac;
		}
=09
	    theodelta =3D (putaghi - putaglo)/(2.0*DELTAEPS*s);
	    theogamma =3D (putaghi+putaglo-2.0*putag)/(DELTAEPS*DELTAEPS*s*s);
	    theovega  =3D (vputag-putag)/(volin*VOLEPS);
	    theorho    =3D (-putag) * expd/DAYSYR;
=09
	    rvalues[1] =3D theodelta;
	    rvalues[2] =3D theogamma;
	    rvalues[3] =3D theovega;
	    rvalues[4] =3D theorho;
	    rvalues[5] =3D -99.0;
	    rvalues[6] =3D uncert;
	    rvalues[7] =3D putg;
	    rvalues[8] =3D suma;
	*****************************************************************/

}

#undef  MAXTS
#undef  MAXPER
#undef  DELTAEPS
#undef  VOLEPS

--------------000506070003020302060604
Content-Type: text/plain; name="Barrier.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Barrier.c"

/*
 *	file: barrier.c
 *
 *	Barrier Option
 *
 *
 *	V0.0	eric wu and v. kaminski, rewritten to correspond to the symbols
 *		 used by Mark Rubinstein
 *
 *	V0.1	29jul93  cleaned-up somewhat to use library functions... -psg
 *	V0.2	02nov93  minor mod to inflag, no functional change ... -psg
 *  V0.3	20aug96  minor bug fix knockout rebate discounting ... -gsm
 *
 */


#include <stdlib.h>
#include <math.h>

double barrier(F, k, vol, r, q, t, b, re, ty, inflag)
	double          F, k, vol, r, q, t, b, re;
	int ty, inflag;
{
	double          aa, bb, int1, int2, int3, int4, int5, int6;
	double          dsct1, dsct2;
	double          lambda, mu, phi, eta, res, volsq;
	double          timesqr, tmp, tmp1, x, x1, y, y1, z;
	int             oi, cas;

	double		cumnorm();

	if( ty=3D=3D0 ) ty =3D 2; =20
        if( inflag =3D=3D 0 ) oi =3D 1;
        else              oi =3D 0;

	t =3D t / 365.25;
	volsq =3D vol * vol;
	timesqr =3D sqrt(t);
	mu =3D (log((1.0 + r) / (1.0 + q))) - 0.5 * volsq;
	lambda =3D 1.0 + (mu / volsq);

	/******* determine the signs ************/


	if (ty =3D=3D 1) {
		if (F >=3D b && k >=3D b && oi =3D=3D 1) {
			phi =3D 1.0;
			eta =3D 1.0;
			cas =3D 2;
		}
		if (F >=3D b && k < b && oi =3D=3D 1) {
			phi =3D 1.0;
			eta =3D 1.0;
			cas =3D 1;
		}
		if (F < b && k >=3D b && oi =3D=3D 1) {
			phi =3D 1.0;
			eta =3D -1.0;
			cas =3D 2;
		}
		if (F < b && k < b && oi =3D=3D 1) {
			phi =3D 1.0;
			eta =3D -1.0;
			cas =3D 1;
		}
		if (F >=3D b && k >=3D b && oi =3D=3D 0) {
			phi =3D 1.0;
			eta =3D 1.0;
			cas =3D 2;
		}
		if (F >=3D b && k < b && oi =3D=3D 0) {
			phi =3D 1.0;
			eta =3D 1.0;
			cas =3D 1;
		}
		if (F < b && k >=3D b && oi =3D=3D 0) {
			phi =3D 1.0;
			eta =3D -1.0;
			cas =3D 2;
		}
		if (F < b && k < b && oi =3D=3D 0) {
			phi =3D 1.0;
			eta =3D -1.0;
			cas =3D 1;
		}
	}
	if (ty =3D=3D 2) {
		if (F >=3D b && k >=3D b && oi =3D=3D 1) {
			phi =3D -1.0;
			eta =3D 1.0;
			cas =3D 2;
		}
		if (F >=3D b && k < b && oi =3D=3D 1) {
			phi =3D -1.0;
			eta =3D 1.0;
			cas =3D 1;
		}
		if (F < b && k >=3D b && oi =3D=3D 1) {
			phi =3D -1.0;
			eta =3D -1.0;
			cas =3D 2;
		}
		if (F < b && k < b && oi =3D=3D 1) {
			phi =3D -1.0;
			eta =3D -1.0;
			cas =3D 1;
		}
		if (F >=3D b && k >=3D b && oi =3D=3D 0) {
			phi =3D -1.0;
			eta =3D 1.0;
			cas =3D 2;
		}
		if (F >=3D b && k < b && oi =3D=3D 0) {
			phi =3D -1.0;
			eta =3D 1.0;
			cas =3D 1;
		}
		if (F < b && k >=3D b && oi =3D=3D 0) {
			phi =3D -1.0;
			eta =3D -1.0;
			cas =3D 2;
		}
		if (F < b && k < b && oi =3D=3D 0) {
			phi =3D -1.0;
			eta =3D -1.0;
			cas =3D 1;
		}
	}
	x =3D ((log(F / k)) / (vol * timesqr)) + lambda * vol * timesqr;
	x1 =3D ((log(F / b)) / (vol * timesqr)) + lambda * vol * timesqr;

	y =3D ((log((b * b) / (F * k))) / (vol * timesqr)) + (lambda * vol * timesq=
r);
	y1 =3D ((log(b / F)) / (vol * timesqr)) + lambda * vol * timesqr;

	aa =3D mu / volsq;
	bb =3D (sqrt((mu * mu) + 2.0 * log(1 + r) * volsq)) / volsq;
	z =3D ((log(b / F)) / (vol * timesqr)) + bb * vol * timesqr;


	dsct1 =3D exp(-r * t);
	dsct2 =3D exp(-q * t);

	int1 =3D phi * (F * dsct2) * cumnorm(phi * x);
	tmp =3D phi * (x - vol * timesqr);
	int1 =3D int1 - phi * k * dsct1 * cumnorm(tmp);

	int2 =3D phi * (F * dsct2) * cumnorm(phi * x1);
	tmp =3D phi * (x1 - vol * timesqr);
	int2 =3D int2 - phi * k * dsct1 * cumnorm(tmp);


	int3 =3D phi * (F * dsct2) * pow(b / F, 2.0 * lambda);
	int3 =3D int3 * cumnorm(eta * y);

	tmp =3D phi * k * dsct1 * pow(b / F, (-2.0) + 2.0 * lambda);
	tmp1 =3D eta * (y - vol * timesqr);
	tmp =3D tmp * cumnorm(tmp1);

	int3 =3D int3 - tmp;


	int4 =3D phi * (F * dsct2) * pow(b / F, 2.0 * lambda);
	int4 =3D int4 * cumnorm(eta * y1);
	tmp =3D phi * k * dsct1 * pow((b / F), (-2.0) + 2.0 * lambda);
	tmp1 =3D eta * (y1 - vol * timesqr);
	tmp =3D tmp * cumnorm(tmp1);

	int4 =3D int4 - tmp;

	tmp =3D eta * (x1 - vol * timesqr);
	int5 =3D cumnorm(tmp);
	tmp =3D eta * (y1 - vol * timesqr);
	tmp =3D pow(b / F, (-2.0) + 2.0 * lambda) * cumnorm(tmp);

	int5 =3D int5 - tmp;
	int5 =3D re * dsct1 * int5;


	int6 =3D (pow(b / F, aa + bb)) * cumnorm(eta * z);
	tmp =3D eta * (z - 2.0 * bb * vol * timesqr);
	int6 =3D int6 + (pow(b / F, aa - bb) * cumnorm(tmp));
	/* gsm 20aug96 knock-out barriers rebates are discounted incorrectly */
	/* int6 =3D re * int6; */
	int6 =3D re * dsct1 * int6;

	switch (ty) {

	case 1:		/***** call ************/
		if (oi =3D=3D 0) {	/***** oi =3D=3D 0 is an in  option ****/

			if (F >=3D b) {	/* down and in  call */

				if (cas =3D=3D 1) {
					res =3D int1 - int2 + int4 + int5;
				} else {
					res =3D int3 + int5;
				}
			}
			if (F < b) {	/* up and in call */
				if (cas =3D=3D 1) {
					res =3D int2 - int3 + int4 + int5;
				} else {
					res =3D int1 + int5;
				}
			}
		}
		if (oi =3D=3D 1) {	/***** oi =3D=3D 1 is an out option ****/

			if (F >=3D b) {	/* down and out call */

				if (cas =3D=3D 1.0) {
					res =3D int2 - int4 + int6;
				} else {
					res =3D int1 - int3 + int6;
				}

			}
			if (F < b) {	/* up and out call */
				if (cas =3D=3D 1) {
					res =3D int1 - int2 + int3 - int4 + int6;
				} else {
					res =3D int6;
				}
			}
		}
		break;


	case 2:		/********* case 2 is a put *********/

		if (oi =3D=3D 0) {	/***** oi =3D=3D 0 is an in  option ****/

			if (F >=3D b) {	/* down and in  put */

				if (cas =3D=3D 1) {
					res =3D int1 + int5;
				} else {
					res =3D int2 - int3 + int4 + int5;
				}
			}
			if (F < b) {	/* up and in put */
				if (cas =3D=3D 1) {
					res =3D int3 + int5;
				} else {
					res =3D int1 - int2 + int4 + int5;
				}
			}
		}
		if (oi =3D=3D 1) {	/***** oi =3D=3D 1 is an out option ****/

			if (F >=3D b) {	/* down and out put */

				if (cas =3D=3D 1.0) {
					res =3D int6;
				} else {
					res =3D int1 - int2 + int3 - int4 + int6;
				}

			}
			if (F < b) {	/* up and out put */
				if (cas =3D=3D 1) {
					res =3D int1 + int6 - int3;
				} else {
					res =3D int2 + int6 - int4;
				}
			}
		}
		break;

	}

	return (res);

}

--------------000506070003020302060604
Content-Type: text/plain; name="Barriero.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Barriero.c"

/*-------------------------------------------------------------

  file: barrieropt.c

  V0.0  25aug93  analytical solution for premium, finite-diff greeks. -psg


  Various types of Barrier  (Knock-in and Knock-out) Options



    COPYRIGHT C 1993, BY ENRON GAS SERVICES, ALL RIGHTS RESERVED.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON GAS SERVICES.
------------------------------------------------------------------------*/

#include  <stdio.h>
#include  <math.h>

#define EPS			0.001
#define DAYSYR			365.25

double barrieropt(s, k, v, r, y, expdays, barr, reba, call, io, valtype )

double  s,            /*   forward price of underlying  */
	k,            /*   strike of the option         */
	v,            /*   voltility 			*/
	r,            /*   interest rate  		*/
	y,            /*   yield 			*/
	expdays,      /*   time to maturity (days)	*/
	barr,         /*   barrier price		*/
	reba;         /*   rebate  			*/

int	call,         /*     1=3Dcall, 0=3Dput  		*/
	io,           /*     1=3Dknockin,  0=3Dknockout	*/
	valtype;      /*   Type of return value:
						premium         0
                   		delta           1
                   		gamma           2
                   		vega            3
                   		rho             4
                   		theta           5
						vegadelta       6  */

{
double	prem, value;
double  tom;
double	barrier();

  tom =3D expdays;

  prem  =3D barrier(s, k, v, r, y, tom, barr, reba, call, io);

  switch(valtype)
  {
    case 0:		/* premium */
	{
	 value =3D prem;
         break;
	}
    case 1:		/* delta   */
	{
	 value =3D (barrier(s*(1.+EPS),k,v,r,y,tom,barr,reba,call,io)-prem)/(s*EPS)=
;
	 break;
	}
    case 2:		/* gamma   */
	{
	 value =3D ( barrier(s*(1.+EPS),k,v,r,y,tom,barr,reba,call,io)
	 	 + barrier(s*(1.-EPS),k,v,r,y,tom,barr,reba,call,io)
		 - 2.0*prem ) / (s*EPS*s*EPS);
	 break;
	}
    case 3:		/* vega    */
	{
	 value =3D ( barrier(s, k, v*(1.+EPS), r, y, tom, barr, reba, call, io)-pre=
m ) / (v*EPS);
	 break;
	}
    case 4:		/* commodity rho */
	{
	 /* commodity rho */
	 if( r=3D=3D 0.0 )
		value =3D 0.0;
	 else{
		r =3D y =3D r*(1.+EPS);
		value  =3D (barrier(s, k, v, r, y, tom, barr, reba, call, io)-prem)/(r*EPS=
);
	 }
	 break;
	}
    case 5:		/* theta */
	{
	 value =3D (prem-barrier(s, k, v, r, y, tom*(1.+EPS), barr, reba, call, io)=
 )/(tom*EPS/DAYSYR);
	 break;
	}
    default:
	{
	 value =3D -99.0;
	 break;
	}
  }
  return value;
}
#undef EPS


--------------000506070003020302060604
Content-Type: text/plain; name="Baskvol.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Baskvol.c"

/*---------------------------------------------------------------
 *
 *   file: baskvol.c
 *
 *   Calculates approximate volatility for asset basket of arbitrary	size.
 *
------------------------------------------------------------------*/
#include <stdio.h>
#include <math.h>

double baskvol(
		double	*fwd,		/* vector of asset prices */
		double	*vol,		/* vector of asset price volatilities (annualized) */
		double	*mu,		/* vector of price drifts (risk neutral) (annualized) */
		double	*wgt,		/* vector of weightings in basket */
		double	*correl,	/* vector containing correlation matrix */
					/* Must be the full matrix even though the matrix is symmetric. */
		int	n,		/* number of assets in basket */
		double	time		/* time to expiration (Years) */
	)
{
	int		col, row;
	double 		exp0, exp1, term1, Sum0, Sum1, num, sigma;

/** Read in the correlations  (specified as a worksheet range) **/

	Sum0 =3D Sum1 =3D 0.0;

	for(col=3D0; col<n; col++) {
	   for(row=3D0; row<n; row++) {
			exp1 =3D exp((mu[row] + mu[col])*time);
			exp0 =3D exp(time*vol[row]*vol[col]* (*(correl+col*n+row)) );
			term1 =3D wgt[row]*wgt[col]*fwd[row]*fwd[col]*exp1;
			Sum1 +=3D term1;
			Sum0 +=3D term1*exp0;
		}
	}
	num =3D log(Sum0) - log(Sum1);
	sigma =3D sqrt(num/time);
	return ( sigma );
}


--------------000506070003020302060604
Content-Type: text/plain; name="Binorm.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Binorm.c"

/**********************************************
* /usr/user/stinsong/util/optlibsrc/binorm.c   *
*
* V0.0  coded by eric wu   =20
* V0.1  18may93   corrections by psg
* V0.2  25aug93   corrected case for rho=3D +-1.0; -psg
*
* based on John Hull Page 245
***********************************************/


#include <stdio.h>
#include <math.h>
#include "M_PI.h"

double capa[4] =3D { 0.325303, 0.4211071, 0.1334425, 0.006374323 };
double capb[4] =3D { 0.1337764, 0.6243247, 1.3425378, 2.2626645 };=20

/*-------------------------------------------------------
	function   binorm_rt

	Calculates cumulative bivariate normal where
	ar <=3D 0  AND  br <=3D 0  AND  rhoo <=3D 0
-------------------------------------------------------*/
double binorm_rt(ar,br,rhoo)
double ar,br,rhoo;
{
  double res,mult,constant,aprime,bprime,fxy,temp;
  int i,j;

  if( ar > 0.0  ||  br > 0.0  ||  rhoo > 0.0 ){
    fprintf(stderr,"Invalid parameter passed to binorm_rt(%f,%f,%f)\n",ar,br=
,rhoo);
    return(-1.0);
  }
  if( rhoo < -1.0 )
    rhoo =3D -1.0;

  temp   =3D sqrt( 2.0*(1.0-(rhoo*rhoo)) );
  aprime =3D ar/temp;
  bprime =3D br/temp;
  constant =3D sqrt(1.0-rhoo*rhoo)/M_PI;

  res =3D 0.0;

  for ( i=3D0;i<4;i++ )
  {
    for ( j=3D0;j<4;j++ )
    {
        mult =3D capa[i]*capa[j];
        fxy =3D aprime*(2.0*capb[i]-aprime)+bprime*(2.0*capb[j]-bprime)
                  + 2.0*rhoo*(capb[i]-aprime)*(capb[j]-bprime);
        res +=3D mult*exp(fxy);
    }
   }
   res =3D constant*res;
   return (res);
}


/*-------------------------------------------------------
	function   binorm

	Calculates cumulative bivariate normal
=09
-------------------------------------------------------*/
double binorm(a,b,rho)
double a,b,rho;
{
  double res, delta, rho1, rho2, temp;
  double cumnorm(), binorm_rt();
  int sgn(double);

  if( rho =3D=3D 1.0 ){
      if( a<b ) res =3D cumnorm(a);
      else      res =3D cumnorm(b);
  }
  else if ( rho =3D=3D -1.0 ){
      if( a < -b ) res =3D 0.0;
      else         res =3D cumnorm(a) - cumnorm(-b);
  }

  else if ( (a*b*rho)>0.0 ){

      temp =3D sqrt(a*a - 2.0*rho*a*b + b*b);
      rho1 =3D ((rho*a-b)*(double)sgn(a))/temp;
      rho2 =3D ((rho*b-a)*(double)sgn(b))/temp;
      delta =3D (1.0-sgn(a)*(double)sgn(b))/4;
 =20
      res =3D binorm(a,0.0,rho1)+binorm(b,0.0,rho2)-delta;=20
  }

  else if ( (a*b*rho)<=3D0.0 ){

      if (     a <=3D 0.0  &&  b <=3D 0.0  &&  rho <=3D0.0 )	        /*   a,=
b,rho <=3D 0   	*/
          res =3D binorm_rt(a,b,rho);
      else if( rho <=3D 0.0  &&  a >=3D 0.0  &&  b >=3D 0.0 ) 	/*   a,b>=3D0=
   rho<=3D0	*/
          res =3D cumnorm(a) + cumnorm(b) - 1.0 + binorm_rt(-a,-b,rho);
      else if( rho >=3D 0.0  &&  a >=3D 0.0  &&  b <=3D 0.0  )	/*   a,rho>=3D=
0   b<=3D0	*/
          res =3D cumnorm(b) - binorm_rt(-a,b,-rho);
      else if( rho >=3D 0.0  &&  a <=3D 0.0  &&  b >=3D 0.0  )	/*   b,rho>=3D=
0   a<=3D0	*/
          res =3D cumnorm(a) - binorm_rt(a,-b,-rho);
  }

    return res;
}

--------------000506070003020302060604
Content-Type: text/plain; name="Boston.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Boston.c"

/*------------------------------------------------------------------
 *=20
 *   strikeroot()
 *
 *   Returns the premium for a Boston option, given the break-even
 *   price level.
 *   Use a quick and dirty bisection method.
 *
 *   V0.0  feb1994
 *
------------------------------------------------------------------*/


#include <stdio.h>
#include <math.h>
#include "option.h"

#define  TOL   0.0001

double strikeroot( brk, fwd, expd, r, q, vol, callput )
double brk, fwd, expd, r, q, vol;
int    callput;
{

  int i;
  double  k, min, max, prem;
  double  euroopt();

  /** we want a non-discounted premium value **/
  q -=3Dr;
  r  =3D 0.0;

  min =3D 0.01*fwd;
  max =3D 10.0*fwd;

  if( callput ) /** option is a CALL 			**/
  {		/** solve: brk =3D k + prem;		**/

	k =3D fwd;

  	for(i=3D0; i<10000; i++){
		prem =3D euroopt( fwd, k, expd, r, q, vol, callput,  0);
		if     ( prem+k > brk )  max =3D k;
		else if( prem+k < brk )  min =3D k;
       	=20
		if( fabs(prem+k-brk) < TOL )
	    		return (prem);
		k =3D (min+max)/2.;
  	}

  } else {	/** option is a PUT  **/

	k =3D fwd;
  	for(i=3D0; i<10000; i++){
		prem =3D euroopt( fwd, k, expd, r, q, vol, callput,  0);
		if     ( k-prem > brk )  max =3D k;
                else if( k-prem < brk )  min =3D k;
       =20
                if( fabs(k-prem-brk) < TOL )
                	return (prem);
                k =3D (min+max)/2.;
  	}
  }
  return( ERR_RETVAL );
}

/******
main()
{

double pprem;

  double brk=3D2.25, fwd=3D2.50, expd=3D0.3, r=3D0.03, vol=3D0.2, callput=3D=
0;


  pprem =3D strikeroot( brk, fwd, expd, r, vol, callput );
  printf("prem is %f\n", pprem);
}
*********/

--------------000506070003020302060604
Content-Type: text/plain; name="Bsroot.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Bsroot.c"

/*------------------------------------------------------------------
 *=20
 *   Putroot()  and   Callroot()
 *
 *   Find the underlying price which makes the European option
 *   worth "targ".
 *
 *   Use a quick and dirty bisection method.
 *
 *   V0.0  may1993  ugly but works -psg
 *
------------------------------------------------------------------*/


#include <stdio.h>
#include <math.h>

#define DAYS_YR 365.25
#define  TOL   0.0001

double euroopt();

double Putroot( targ, k, expd, r, vol, min, max )
double targ, k, expd, r, vol, min, max;
{

  int i;
  double  opt, und ;

  und =3D (min+max)/2.;

  for(i=3D0; i<10000; i++){
	opt =3D euroopt( und, k, expd/DAYS_YR, r, r, vol, 0, 0);=09
	if     ( opt > targ )  min =3D und;
	else if( opt < targ )  max =3D und;
       =20
	if( fabs(targ-opt) < TOL )
	    return und;
	und =3D (min+max)/2.;
  }
  return( -1 );
} /* putroot */

double Callroot( targ, k, expd, r, vol, min, max )
double targ, k, expd, r, vol, min, max;
{

  int i;
  double  opt, und ;

  und =3D (min+max)/2.;

  for(i=3D0; i<10000; i++){
	opt =3D euroopt( und, k, expd/DAYS_YR, r, r, vol, 1, 0);=09
	if     ( opt > targ )  max =3D und;
	else if( opt < targ )  min =3D und;
       =20
	if( fabs(targ-opt) < TOL )
	    return und;
	und =3D (min+max)/2.;
  }
  return( -1 );
} /* Callroot */


--------------000506070003020302060604
Content-Type: text/plain; name="Call.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Call.c"

/*---------------------------------------------------
 * Black-Scholes European Call Option Model=20
 *   for "stock" with continuous dividend yield q.
 *
 *	V0.1	21jul93		corrected r,q bug.
 *	V1.0	 4aug93		changed units of "time" from days to years.
 *
 * s    spot price     =20
 * d    strike price  =20
 * time tenor (years)
 * r    annualized riskfree rate
 * q    continuous dividend yield
 * vol1 annualized volatility =20

    COPYRIGHT C 1993, BY ENRON GAS SERVICES, ALL RIGHTS RESERVED.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON GAS SERVICES.
-----------------------------------------------------*/

#include  <math.h>

double call( s, k, time, r, q, vol1 )
double s, k, time, r, q, vol1;
{
    double d1, d2, callprem, Nd1, Nd2;
    double cumnorm();

    d1 =3D (log(s/k)+(r-q+vol1*vol1/2)* time)/(vol1 * sqrt(time));
    d2 =3D d1-(vol1*sqrt(time));

    Nd1=3D cumnorm(d1);
    Nd2 =3D cumnorm(d2);
    callprem =3D s*Nd1*exp(-q*time) - k*Nd2*exp(-r*time);
    return( callprem );
}

--------------000506070003020302060604
Content-Type: text/plain; name="Callr.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Callr.c"

/*---------------------------------------------------
 * Black-Scholes European Call Option Model=20
 *   for "stock" with continuous dividend yield q.
 *
 *	V0.1	22jul93	incorporate dDdV into risk parameters
 *
 *
 *	Calculates premium and risk parameters.
 *
 * 	s    spot price     =20
 * 	d    strike price  =20
 * 	expd days to expiration=20
 * 	r    annualized riskfree rate
 * 	q    continuous dividend yield
 * 	vol  annualized volatility =20
 *	risk[0]	delta
 *	    [1] gamma
 *	    [2] vega
 *	    [3]	rho (not valid for r=3Dq)
 *	    [4]	theta
 *	    [5]	commodity rho
 *	    [6]	d(delta)/d(vol)

    COPYRIGHT C 1993, BY ENRON GAS SERVICES, ALL RIGHTS RESERVED.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON GAS SERVICES.
-----------------------------------------------------*/

#include  <math.h>
#include  "M_PI.h"

double callr( s, k, expd, r, q, vol, risk )
double s, k, expd, r, q, vol, *risk;
{
    double time, d1, d2, call, Nd1, Nd2;
    double NPrimeD1, volt, expqt;
    double cumnorm();
    time =3D expd/365.25;
    expqt=3D exp(-q*time);
    volt =3D vol*sqrt(time);

    d1 =3D (log(s/k)+(r-q+vol*vol/2)* time)/volt;
    d2 =3D d1-volt;
    NPrimeD1 =3D (1.0 / sqrt(2.0*M_PI)) * exp(-d1*d1/2.0);

    Nd1=3D cumnorm(d1);
    Nd2 =3D cumnorm(d2);
    call =3D s*Nd1*exp(-q*time) - k*Nd2*exp(-r*time);

    risk[0] =3D Nd1 *  expqt;				/** delta **/
    risk[1] =3D (expqt * NPrimeD1) / (s * volt);		/** gamma **/
    risk[2] =3D expqt * s * NPrimeD1 * sqrt(time);	/** vega  **/
    risk[3] =3D time*exp(-r*time)*k*Nd2;			/** rho   **/
							/** theta **/
    risk[4] =3D (-s*NPrimeD1*vol*expqt)/(2.0*sqrt(time)) + q*s*Nd1*expqt - r=
*k*exp(-r*time)*Nd2;
    risk[5] =3D (-time)*call;			/** rho for commodity option **/
    risk[6] =3D expqt * NPrimeD1 * (sqrt(time) - d1/vol);

    return( call );
}

--------------000506070003020302060604
Content-Type: text/plain; name="Codopt.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Codopt.c"

/*-------------------------------------------------------------

  file: codopt.c

  V0.0  23jul93  analytical solution for MtM, finite-diff greeks. -psg


  C.O.D. OPTION


      rvalues[] =3D  MtM value       [0]
                   delta           [1]
                   gamma           [2]
                   lambda (vega)   [3]
                   rho             [4]
                   theta           [5]
                   dDdV            [6]  not implemented=20

    COPYRIGHT C 1993, BY ENRON GAS SERVICES, ALL RIGHTS RESERVED.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON GAS SERVICES.
------------------------------------------------------------------------*/

#include  <stdio.h>
#include  <math.h>

#define DAYSYR			365.25		 /* calendar days in a year */
#define EPS			0.00001

void codopt( prem, s, k, r, q, vol, expd, call, rvalues )
double 		prem,		/* Option contingent premium amount */
		s,		/* price of Underlying 	*/
		k,		/* Strike               */
		r,		/* annualized cost of money, for discounting */
		q,		/* annualized dividend yield (=3Dr for commodity */
		vol,		/* annualized volatility, eg. 0.30 	*/
		expd,		/* days until option expiration */
		*rvalues;	/* return values, see above explanation */
int		call;		/* 1=3DCall, 0=3DPut  */
{
double	value;
double	delta, gamma, vega, rho, theta;
double	codval();

	value  =3D codval( s, k, r, q, vol, expd, prem, call);
	delta  =3D (codval( s*(1.+EPS), k, r, q, vol, expd, prem, call) -value) / (=
s*EPS);
	gamma  =3D (codval( s*(1.+EPS), k, r, q, vol, expd, prem, call)
		+codval( s*(1.-EPS), k, r, q, vol, expd, prem, call)
		-2.*value) / (s*EPS*s*EPS);
	vega   =3D (codval( s, k, r, q, vol*(1.+EPS), expd, prem, call)-value)/(vol=
*EPS);

	/* commodity rho */
	if( r=3D=3D 0.0 )
		rho =3D 0.0;
	else
		rho    =3D (codval( s, k, r*(1.+EPS), q*(1.+EPS), vol, expd, prem, call)-v=
alue)/(r*EPS);

	theta  =3D (codval( s, k, r, q, vol, (expd-1.0), prem, call)-value)/ (1./DA=
YSYR);

	rvalues[0] =3D  value;
	rvalues[1] =3D  delta;
	rvalues[2] =3D  gamma;
	rvalues[3] =3D  vega;
	rvalues[4] =3D  rho;
	rvalues[5] =3D  theta;

}
#undef DAYSYR
#undef EPS

--------------000506070003020302060604
Content-Type: text/plain; name="Codpremi.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Codpremi.c"

/*-------------------------------------------------------------

  file: codpremium.c

  V0.0  22jul93  finds contingent premium for C.O.D. OPTION.  psg.


  C.O.D. OPTION


    COPYRIGHT C 1993, BY ENRON GAS SERVICES, ALL RIGHTS RESERVED.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON GAS SERVICES.
------------------------------------------------------------------------*/

#include  <math.h>

#define DAYSYR			365.25		 /* calendar days in a year */

double codpremium( s, k, r, q, vol, expd, call)
double 		s,		/* price of Underlying 	*/
		k,		/* Strike               */
		r,		/* annualized cost of money, for discounting */
		q,		/* annualized dividend yield (=3Dr for commodity */
		vol,		/* annualized volatility, eg. 0.30 	*/
		expd;		/* days until option expiration */
int		call;		/* 1=3DCall, 0=3DPut  */
{
double	prem;
double time, d1, d2, Nd1, Nd2;
double volt;
double cumnorm();

	time =3D expd/365.25;
	volt =3D vol*sqrt(time);
	d1 =3D (log(s/k)+(r-q+vol*vol/2)* time)/volt;
	d2 =3D d1-volt;
	Nd1=3D cumnorm(d1);
	Nd2 =3D cumnorm(d2);

	if( call )
		prem =3D s*Nd1*exp((r-q)*time)/Nd2 - k;
	else
		prem =3D s*exp((r-q)*time)*(Nd1-1.0)/(1.0-Nd2) + k;

	return ( prem );

}

--------------000506070003020302060604
Content-Type: text/plain; name="Codval.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Codval.c"

/*-------------------------------------------------------------

  file: codval.c

  V0.0  23jul93  Mark to market value of a C.O.D. option. -psg


  C.O.D. OPTION


    COPYRIGHT C 1993, BY ENRON GAS SERVICES, ALL RIGHTS RESERVED.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON GAS SERVICES.
------------------------------------------------------------------------*/

#include  <math.h>

#define DAYSYR			365.25		 /* calendar days in a year */

double codval( s, k, r, q, vol, expd, prem, call)
double 		s,		/* price of Underlying 	*/
		k,		/* Strike               */
		r,		/* annualized cost of money, for discounting */
		q,		/* annualized dividend yield (=3Dr for commodity */
		vol,		/* annualized volatility, eg. 0.30 	*/
		expd,		/* days until option expiration */
		prem;		/* contingent premium payment */
int		call;		/* 1=3DCall, 0=3DPut  */
{
double time, d1, d2, Nd1, Nd2;
double volt, pval;
double cumnorm();

	time =3D expd/365.25;
	volt =3D vol*sqrt(time);
	d1 =3D (log(s/k)+(r-q+vol*vol/2)* time)/volt;
	d2 =3D d1-volt;
	Nd1=3D cumnorm(d1);
	Nd2 =3D cumnorm(d2);

	if( call )
		pval =3D s*Nd1*exp(-q*time) - (k+prem)*Nd2*exp(-r*time);
	else
		pval =3D s*(Nd1-1.0)*exp(-q*time) - (k-prem)*(Nd2-1.0)*exp(-r*time);

	return ( pval );

}
#undef DAYSYR

--------------000506070003020302060604
Content-Type: text/plain; name="Compvopt.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Compvopt.c"

/*-------------------------------------------------------------

  file: compvopt.c

  V0.0  13aug93  analytical solution for prem,  finite-diff greeks. -psg
  V1.0  23aug93  units of time inputs changed from years to calendar days. -=
psg


  Compound Option with two point volatility term structure.

  Premium and Risk Parameters



    COPYRIGHT C 1993, BY ENRON GAS SERVICES, ALL RIGHTS RESERVED.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON GAS SERVICES.
------------------------------------------------------------------------*/

#include  <stdio.h>
#include  <math.h>

#define DAYSYR			365.25
#define EPS			0.001

double compvopt( S, xa, xb, ta, tb, r, q, volab, volb, optype, valtype)
double S,                       /* price of underlying */
      xa,                       /* strike price for receiving/putting the op=
tion at ta  */
      xb,                       /* strike price for receiving/putting the un=
derlying at tb */
      ta,                       /* time to expiration of compound option (da=
ys) */
      tb,                       /* time to expiration of underlying option (=
days)  */
       r,                       /* risk free rate */
       q,                       /* dividend yield  (=3Drisk free rate for fu=
tures) */
   volab,                       /* volatility of underlying at time "ta" */
    volb;                       /* present  volatility of underlying */

int optype;                       /* specifies type of compound option:
                                        1  Call on a Call
                                        2  Put  on a Call
                                        3  Call on a Put
                                        4  Put  on a Put
                                        5  implied vola 	*/

int valtype;  /* 	premium		0
			delta		1
			gamma		2
			vega		3
			rho		4
			theta		5	( annualized )  */
{
double	value, prem;
double	optoptvol();

  prem =3D optoptvol(S,xa,xb,ta,tb,r,q,volab,volb,optype);

  switch(valtype)
  {
    case 0:             /* premium */
        {
	  value =3D prem;
	  break;
	}
    case 1:             /* delta */
        {
         value =3D ( optoptvol(S*(1.+EPS), xa, xb, ta, tb, r, q, volab, volb=
, optype)-prem )
		   / (S*EPS);
         break;
        }
    case 2:             /* gamma */
        {
         value =3D ( optoptvol(S*(1.+EPS),xa,xb,ta,tb,r,q,volab,volb,optype)
		  +optoptvol(S*(1.-EPS),xa,xb,ta,tb,r,q,volab,volb,optype)
		  -2.*prem) / (S*EPS*S*EPS);
         break;
        }
    case 3:             /* vega  */
        {
         value =3D ( optoptvol(S,xa,xb,ta,tb,r,q,volab*(1.+EPS),volb*(1.+EPS=
),optype)-prem  )
		   /(volb*EPS);
         break;
        }
    case 4:             /* commodity rho */
        {
	if( r=3D=3D 0.0 )
		value =3D 0.0;
	else
		value =3D (optoptvol(S,xa,xb,ta,tb,r*(1.+EPS),q*(1.+EPS),volab,volb,optype=
)-prem )/(r*EPS);
         break;
        }
    case 5:             /* theta */
        {
	if( ta>EPS )
		value  =3D ( optoptvol(S,xa,xb,(ta-EPS),(tb-EPS),r,q,volab,volb,optype)-pr=
em  )
		  	/ EPS;
	else
		value  =3D ( optoptvol(S,xa,xb,(ta-EPS*EPS),(tb-EPS*EPS),r,q,volab,volb,op=
type)-prem  )
		  	/ (EPS*EPS);
	 value *=3D DAYSYR; /** annualize theta **/
         break;
        }
  }
  return value;
}
#undef EPS
#undef DAYSYR

--------------000506070003020302060604
Content-Type: text/plain; name="Cumnorm.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Cumnorm.c"


#include	<math.h>

#define B1              0.319381530
#define B2             -0.356563782
#define B3              1.781477937
#define B4             -1.821255978
#define B5              1.330274429
#define A               0.2316419
#define SQRT2PI			2.506628275


double cumnorm( x )
   double x;
{
   double exp(double);
   double y, k, nd, series;
=09
	if (x<-25.0)
		return(0.0);
	else if (x>25.0)
		return(1.0);

    if( x < 0.0 ){

       y =3D -x;
       k =3D 1.0/(1.0+A*y);
       series =3D (B1+(B2+(B3+(B4+B5*k)*k)*k)*k)*k;
       nd =3D exp(-y*y/2.0)/SQRT2PI * series;

    }else{

       y =3D  x;
       k =3D 1.0/(1.0+A*y);
       series =3D (B1+(B2+(B3+(B4+B5*k)*k)*k)*k)*k;
       nd =3D 1.0  -  exp(-y*y/2.0)/SQRT2PI * series;

    }
    return nd ;
}

#undef B1
#undef B2
#undef B3
#undef B4
#undef B5
#undef A
#undef SQRT2PI

--------------000506070003020302060604
Content-Type: text/plain; name="Euro.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Euro.c"

/*---------------------------------------------------
 * 	Black-Scholes European Option Model=20
 *   	for "stock" with continuous dividend yield q.
 *
 *	Calculates premium and risk parameters.
 *
 * 	s    spot price     =20
 * 	d    k price  =20
 * 	time time to exipration (years)
 * 	r    annualized riskfree rate
 * 	q    continuous dividend yield
 * 	vol  annualized volatility =20
 *
-----------------------------------------------------*/

#include  <math.h>
#include "option.h"
#include "M_PI.h"

void euro( double s, double k, double time, double r, double q, double vol, =
int callflag, Optresults *out, int risk )
{
    double d1, d2, Nd1, Nd2;
    double NPrimeD1, volt, expqt;
    double cumnorm();
    double call, put, negd1, negd2;

    if( time<=3D0.0 || vol<=3D0.0 )
    {
	if( callflag ) {
		out->Premium[0]	=3D (s-k)*(s>k);
        	if( time > 0.0) out->Delta[0]	=3D exp(-r*time)*(s>k);
        	else 		out->Delta[0]	=3D 0.0;
	} else {
		out->Premium[0]	=3D (k-s)*(k>s);
        	if( time > 0.0) out->Delta[0]	=3D -exp(-r*time)*(k>s);
        	else 		out->Delta[0]	=3D 0.0;
	}
        out->Gamma[0]	=3D 0.0;
        out->Vega[0]	=3D 0.0;
        out->Theta[0]	=3D 0.0;
        out->DeltaVega[0]=3D 0.0;
        out->Charm[0]	=3D 0.0;
        out->Rho[0]	=3D 0.0;
    }

    else if( callflag ) {

        expqt=3D exp(-q*time);
        volt =3D vol*sqrt(time);

        d1 =3D (log(s/k)+(r-q+vol*vol/2)* time)/volt;
        d2 =3D d1-volt;

        Nd1=3D cumnorm(d1);
        Nd2 =3D cumnorm(d2);
        call =3D s*Nd1*exp(-q*time) - k*Nd2*exp(-r*time);
        NPrimeD1 =3D (1.0 / sqrt(2.0*M_PI)) * exp(-d1*d1/2.0);

		out->Premium[0]	=3D call;
        out->Delta[0]	=3D Nd1 *  expqt;
        out->Gamma[0]	=3D (expqt * NPrimeD1) / (s * volt);
        out->Vega[0]	=3D  expqt * s * NPrimeD1 * sqrt(time);
        out->Theta[0]	=3D (-s*NPrimeD1*vol*expqt)/(2.0*sqrt(time)) + q*s*Nd1=
*expqt - r*k*exp(-r*time)*Nd2;
        out->DeltaVega[0]=3D expqt * NPrimeD1 * (sqrt(time) - d1/vol);
        out->Charm[0]	=3D -expqt * ( (2.*(r-q)/volt-d2)*NPrimeD1/(2.*time) -=
 q*Nd1);

	/** commodity rho **/
        out->Rho[0]	=3D (-time)*call;

	/** equity rho **/
	/** out->Rho[0]	=3D time*exp(-r*time)*k*Nd2; **/

    } else {

    	expqt=3D exp(-q*time);
    	volt =3D vol*sqrt(time);

    	negd1 =3D (log(s/k)+(r-q+vol*vol/2)* time)/(-volt);
    	negd2 =3D volt + negd1;
    	NPrimeD1 =3D (1.0 / sqrt(2.0*M_PI)) * exp(-negd1*negd1/2.0);

    	Nd1 =3D cumnorm(negd1);
    	Nd2 =3D cumnorm(negd2);
    	put =3D exp(-r*time)*k*Nd2 - exp(-q*time)*s*Nd1 ;

	out->Premium[0]	=3D put;
        out->Delta[0]	=3D  -Nd1 *  expqt;
        out->Gamma[0]	=3D (expqt * NPrimeD1) / (s * volt);
        out->Vega[0]	=3D  expqt * s * NPrimeD1 * sqrt(time);
        out->Theta[0]	=3D (-s*NPrimeD1*vol*expqt)/(2.0*sqrt(time)) - q*s*Nd1=
*expqt + r*k*exp(-r*time) *Nd2;
        out->DeltaVega[0]=3D expqt * NPrimeD1 * (sqrt(time) + negd1/vol);
        out->Charm[0]	=3D -expqt * ( (2.*(r-q)/volt+negd2)*NPrimeD1/(2.*time=
) + q*Nd1);

	/** commodity rho **/
        out->Rho[0]	=3D (-time)*put;

	/** equity rho **/
        /** out->Rho[0]	=3D (-time)*exp(-r*time)*k*Nd2; **/
    }
}

--------------000506070003020302060604
Content-Type: text/plain; name="Euroopt.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Euroopt.c"

/*---------------------------------------------------
 * 	Black-Scholes European Option Model=20
 *   	for "stock" with continuous dividend yield q.
 *
 *	V0.0	18aug93=09
 *	V1.0	9sept93	 fixed bug,  add risk parameters. -psg
 *	V1.1	14jan94	 added charm. -psg
 *
 *
 *	Calculates premium or risk parameters.
 *
 * 	s    spot price     =20
 * 	d    strike price  =20
 * 	time time to exipration (years)
 * 	r    annualized riskfree rate
 * 	q    continuous dividend yield
 * 	vol  annualized volatility =20
 *
 *   risk:   0  premium
 *	     1 	delta
 *	     2  gamma
 *	     3  vega
 *	     4 	commodity rho
 *	     5 	theta
 *	     6 	rho (not valid for r=3Dq)
 *	     7 	d(delta)/d(vol)
 *	     8 	charm:  d(delta)/dt
-----------------------------------------------------*/

#include  <math.h>
#include  "M_PI.h"

#define EPSD 0.000030517578125


double euroopt( s, k, time, r, q, vol, callflag, risk )
double s, k, time, r, q, vol;
int	callflag, risk;
{
    double d1, d2, value, Nd1, Nd2;
    double NPrimeD1, volt, expqt;
    double cumnorm();
    double call, put, negd1, negd2;

    if( time<=3D0.0 ){
	if( risk !=3D 0 )
		return(0.0);
	else if( callflag ) {
		return( (s-k)*((s-k)>0.0) );
	} else {
		return( (k-s)*((k-s)>0.0) );
	}
    } else if ( vol < EPSD ) {
	vol =3D EPSD;
    }

    if( callflag ) {

        expqt=3D exp(-q*time);
        volt =3D vol*sqrt(time);

        d1 =3D (log(s/k)+(r-q+vol*vol/2)* time)/volt;
        d2 =3D d1-volt;

        Nd1=3D cumnorm(d1);
        Nd2 =3D cumnorm(d2);
        call =3D s*Nd1*exp(-q*time) - k*Nd2*exp(-r*time);
        NPrimeD1 =3D (1.0 / sqrt(2.0*M_PI)) * exp(-d1*d1/2.0);

	switch( risk ) {

	case(0):		/*** premium ***/
		value =3D call;
		break;
	case(1):		/** delta **/
        	value =3D Nd1 *  expqt;
		break;
	case(2):		/** gamma **/
        	value =3D (expqt * NPrimeD1) / (s * volt);
		break;
	case(3):		/** vega **/
        	value =3D  expqt * s * NPrimeD1 * sqrt(time);
		break;
	case(4):		/** commodity rho **/
        	value =3D (-time)*call;
		break;
	case(5):		 /** theta **/
        	value =3D (-s*NPrimeD1*vol*expqt)/(2.0*sqrt(time)) + q*s*Nd1*expqt =
- r*k*exp(-r*time)*Nd2;
		break;
	case(6):		/** rho **/
        	value =3D time*exp(-r*time)*k*Nd2;
		break;
	case(7):		/** d Delta / d V **/
        	value =3D expqt * NPrimeD1 * (sqrt(time) - d1/vol);
		break;
	case(8):		/** charm  **/
        	value =3D -expqt * ( (2.*(r-q)/volt-d2)*NPrimeD1/(2.*time) - q*Nd1)=
;
		/* Krishna's charm */
		/*	value =3D -expqt * ( (d1-2.*log(s/k)/volt)*NPrimeD1/(2.*time) - q*Nd1);=
 */
		break;
	default:
		value =3D 99.0;
		break;
	}
    } else {

    	expqt=3D exp(-q*time);
    	volt =3D vol*sqrt(time);

    	negd1 =3D (log(s/k)+(r-q+vol*vol/2)* time)/(-volt);
    	negd2 =3D volt + negd1;
    	NPrimeD1 =3D (1.0 / sqrt(2.0*M_PI)) * exp(-negd1*negd1/2.0);

    	Nd1 =3D cumnorm(negd1);
    	Nd2 =3D cumnorm(negd2);
    	put =3D exp(-r*time)*k*Nd2 - exp(-q*time)*s*Nd1 ;

	switch( risk ) {

	case(0):		/*** premium ***/
		value =3D put;
		break;
	case(1):		/** delta **/
        	value =3D  -Nd1 *  expqt;
		break;
	case(2):		/** gamma **/
        	value =3D (expqt * NPrimeD1) / (s * volt);
		break;
	case(3):		/** vega **/
        	value =3D  expqt * s * NPrimeD1 * sqrt(time);
		break;
	case(6):		/** rho **/
        	value =3D (-time)*exp(-r*time)*k*Nd2;
		break;
	case(5):		 /** theta **/
        	value =3D (-s*NPrimeD1*vol*expqt)/(2.0*sqrt(time)) - q*s*Nd1*expqt =
+ r*k*exp(-r*time) *Nd2;
		break;
	case(4):		/** commodity rho **/
        	value =3D (-time)*put;
		break;
	case(7):		/** d Delta / d V **/
        	value =3D expqt * NPrimeD1 * (sqrt(time) + negd1/vol);
		break;
	case(8):		/** charm for put **/
        	value =3D -expqt * ( (2.*(r-q)/volt+negd2)*NPrimeD1/(2.*time) + q*N=
d1);
		break;
	default:
		value =3D 99.0;
		break;
	}
    }
    return( value );
}

--------------000506070003020302060604
Content-Type: text/plain; name="Eurostri.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Eurostri.c"

/*---------------------------------------------------
 *
 *	file: eurostrip.c
 *
 *	Strip of Daily Call Options
 *
 *
 *	V0.0	19aug93	 psg
 *
 *
 *	Calculates premium and risk parameters.
 *
 * 	s         spot price     =20
 * 	d         strike price  =20
 *	period    days to beginning of period
 * 	start     days from beginning of period to beginning of strip
 * 	end       days from beginning of period to end of strip
 * 	r         annualized riskfree rate
 * 	q         annualized dividend rate
 * 	vol       annualized volatility =20
 *      callflag  1=3Dcall 0=3Dput
 *
 *      risk 0  premium
 *	     1 	delta
 *	     2  gamma
 *	     3  vega
 *	     4 	commodity rho
 *	     5 	theta
 *	     6 	delta on forward strike date

    COPYRIGHT C 1993, BY ENRON GAS SERVICES, ALL RIGHTS RESERVED.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON GAS SERVICES.
-----------------------------------------------------*/

#include  <math.h>

#define		EPS	0.001

double eurostrip( s, k, period, start, end, r, q, vol, callflag, risk )
double s, k, period, start, end, r, q, vol;
int    callflag, risk;
{
    double time;
    double value;
    double euroopt();

    value =3D 0.0;

    if( start<-1.0 ) start =3D -1.0;

    if( period <=3D0.0 ) {

	if( risk =3D=3D 6 ) risk =3D 1;  /** both deltas are the same **/

        for( time=3Dend; time>=3D(start+1.0); time-=3D1.0)
            value +=3D euroopt( s, k, time/365.25, r, q, vol, callflag, risk=
 );
        if( time > start )
            value +=3D (time-start) * euroopt( s, k, time/365.25, r, q, vol,=
 callflag, risk );
    	value /=3D (end-start);

    } else {

        switch( risk ) {

        case(1):                /** delta **/
        	for( time=3Dend; time>=3D(start+1.0); time-=3D1.0)
	            value +=3D (euroopt( s*(1.0+EPS), k*(1.0+EPS), time/365.25, r, =
q, vol, callflag,0)
	                      -euroopt( s, k, time/365.25, r, q, vol, callflag,0))/=
EPS;
        	if( time > start )
	            value +=3D (time-start) * (euroopt( s*(1.0+EPS), k*(1.0+EPS), t=
ime/365.25, r, q, vol, callflag,0)
                              -euroopt( s, k, time/365.25, r, q, vol, callfl=
ag,0))/EPS;
    		value *=3D exp(-r*period/365.25) / (end-start);
                break;
        case(2):                /** gamma **/
                value =3D 0.0;
                break;
	case(6):		/**  delta on fwd start date **/
		risk =3D 1;
        case(0):                /*** premium ***/
        case(3):                /**  vega  **/
        	for( time=3Dend; time>=3D(start+1.0); time-=3D1.0)
	            value +=3D euroopt( s, k, time/365.25, r, q, vol, callflag, ris=
k );
        	if( time > start )
	            value +=3D (time-start) * euroopt( s, k, time/365.25, r, q, vol=
, callflag, risk );
    		value *=3D exp(-r*period/365.25) / (end-start);
                break;

        case(4):                /**  rho   **/
        	for( time=3Dend; time>=3D(start+1.0); time-=3D1.0)
	            value +=3D euroopt( s, k, time/365.25, r, q, vol, callflag, ris=
k );
        	if( time > start )
	            value +=3D (time-start) * euroopt( s, k, time/365.25, r, q, vol=
, callflag, risk );
    		value  =3D exp(-r*period/365.25) /  (end-start) *=20
		    ( value-(period/365.25)*eurostrip(s,k,period,start,end,r,q,vol,callfla=
g,0) );
                break;

        case(5):                /**  theta **/

    		value =3D (-r)*eurostrip(s,k,period,start,end,r,q,vol,callflag,0);
                break;
	}
    }

    return( value );
}
#undef		EPS

--------------000506070003020302060604
Content-Type: text/plain; name="Fstasian.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Fstasian.c"

/*--------------------------------------------------------------------------=
----------------------
=20
  file: FstAsian.c
=20
  set tabstop=3D4
=20
FastAsian.c
  V0.0  27may93  a fast analytical approximation to asian pricing. -psg
  V1.0  24jun93  this version to incorporate an empirical correction factor.=
 -psg
  V2.0  29jun93  include theoretical risk parameter calculations. -psg
  V2.2  26jul93  add DriftTheta, corrected theta for "in averaging" case. -p=
sg
FastAsian.c
  V3.0  19aug93  change averaging daycounts to trading days. additional arg =
added. -psg
  V3.1  30mar95  simplify negative strike case,  improve handling of delta r=
olloff -psg
  V3.2  31mar95  changed functionality slightly, if sta<=3D0.0 set "price" m=
ust be supplied. -psg
  V3.3  14Feb96  Data file incorporated by Joe Hrgovcic sometime before this=
 date  -pvk
=20
   ASIAN CALL OPTION WITH ONE CONTINUOUS AVERAGING PERIOD
=20
      rvalues[] =3D  call premium,   [0]
                   delta           [1]
                   gamma           [2]
                   lambda (vega)   [3]
                   rho             [4]
                   theta           [5]
                   d(delta)/d(vol) [6]

    COPYRIGHT C 1995 BY ENRON CAPITAL & TRADE RESOURCES, ALL RIGHTS RESERVED=
=2E
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON  CAPITAL & TRADE RESOURCES.
----------------------------------------------------------------------------=
---------------------*/

#include  <stdio.h>
#include  <math.h>

#define DAYSYR			365.25		 /* calendar days in a year */

void FastAsian(double s, double k, double r, double volin, double set, doubl=
e expd,
	       double sta, double toend, double tradedays, int callflag, double *rv=
alues );
extern double callr(double s, double k, double expd, double r, double q, dou=
ble vol, double *risk );
extern double putr(double s, double k, double expd, double r, double q, doub=
le vol, double *risk );
extern double cumnorm( double x );


/*
 *	function correctcall()
 *
 *	Finds correction factor to asian approximation.
 *
 */

#define	XSTART	0.04		/* starting value for sigt; xstep=3D(1/nsteps)*ln(sigte=
nd/sigtstart)*/
#define XEND	2.5
#define	YSTART	0.0		/* starting value for Tstart/Tend 			*/
#define YEND	1.0
#define	ZSTART	1.0/3.0		/* start value for s/k				 	*/
#define NXMAX	10		/* number of vol*sqrt(Tend) values in corr. matrix 	*/
#define NYMAX	17		/* number of Tstart/Tend values in corr. matrix 	*/
#define NZMAX	52		/* number of s/k values in corr. matrix 		*/

double correctcall(double s, double k, double volin, double sta, double toen=
d)
/* double	s, k, volin, sta, toend; */
{

double	sigt, sk, tste;
double	correction;
double	x, y, z, dx, dy, dz, f[3][3][3];
int	nx, ny, nz, dnx, dny, dnz;

double triinterp( double  f[3][3][3], double p, double q, double r);
// FILE	*filep;
static double corrfac[NXMAX][NYMAX][NZMAX]=3D{0,
0, 0, 0, 0, 0, 0, 0, 0, 0,
 -9.44e-15, 1.2523e-05, -6.2e-06, 3e-06, 3e-06, 3e-06, 4e-06, 3e-06, 4e-06, =
1e-05,
 0, 0, 1e-05, 0, 0, 1e-05, 0, 1e-05, 0, 1e-05,
 0, 0, 0, 0, 1e-05, 0, 1e-05, 0, 0, 1e-05,
 0, 1e-05, 0, 0, 1e-05, 1e-05, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, -5.279e-14, 1.1905e-05, -5.9e-06, 2e-06, 2e-06, 2e-06, 3e-06, 2e-06,
 3e-06, 0, 0, 0, 1e-05, 0, 0, 1e-05, 0, 1e-05,
 0, 1e-05, 0, 0, 0, 0, 1e-05, 0, 1e-05, 0,
 0, 1e-05, 0, 0, 0, 0, 1e-05, 1e-05, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, -2.378e-13, 1.0632e-05, -4.6e-06, 3e-06, 2e-06, 3e-06,
 3e-06, 3e-06, 3e-06, 1e-05, 0, 0, 1e-05, 0, 0, 1e-05,
 0, 1e-05, 0, 1e-05, 0, 0, 0, 0, 1e-05, 0,
 1e-05, 0, 0, 1e-05, 0, 1e-05, 0, 0, 1e-05, 1e-05,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, -8.81e-13, 1.0066e-05, -3.8e-06, 3e-06,
 2e-06, 3e-06, 3e-06, 3e-06, 3e-06, 0, 0, 0, 1e-05, 0,
 0, 1e-05, 0, 1e-05, 0, 1e-05, 0, 0, 0, 0,
 1e-05, 0, 1e-05, 0, 0, 1e-05, 0, 0, 0, 0,
 1e-05, 1e-05, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, -2.778e-12, 1.0112e-05,
 -1.8e-06, 3e-06, 3e-06, 3e-06, 3e-06, 3e-06, 3e-06, 1e-05, 0, 0,
 1e-05, 0, 0, 1e-05, 0, 1e-05, 0, 1e-05, 0, 0,
 0, 0, 1e-05, 0, 1e-05, 0, 0, 1e-05, 0, 1e-05,
 0, 0, 1e-05, 1e-05, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 -7.58e-12, 8.87e-06, -9e-07, 2e-06, 2e-06, 2e-06, 2e-06, 2e-06, 2e-06, 0,
 0, 0, 1e-05, 0, 0, 1e-05, 0, 1e-05, 0, 1e-05,
 0, 0, 0, 0, 1e-05, 0, 1e-05, 0, 0, 1e-05,
 0, 0, 0, 0, 1e-05, 1e-05, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, -2.08e-20, -1.815e-11, 8.61e-06, -7e-07, 2e-06, 2e-06, 2e-06, 2e-06, 2e-=
06,
 3e-06, 0, 0, 0, 1e-05, 0, 0, 1e-05, 0, 1e-05,
 0, 1e-05, 0, 0, 0, 0, 1e-05, 0, 1e-05, 0,
 0, 1e-05, 0, 0, 0, 0, 1e-05, 1e-05, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, -1.529e-19, -3.84e-11, 7.75e-06, -2e-07, 1e-06, 1e-06, 1e-06,
 1e-06, 1e-06, 1e-06, 0, 0, 0, 1e-05, 0, 0, 1e-05,
 0, 1e-05, 0, 0, 0, 0, 0, 0, 1e-05, 0,
 1e-05, 0, 0, 0, 0, 0, 0, 0, 0, 1e-05,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, -1.1272e-18, -7.17e-11, 6.69e-06, 3e-07, 1e-06,
 1e-06, 1e-06, 1e-06, 1e-06, 2e-06, 0, 0, 0, 1e-05, 0,
 0, 1e-05, 0, 1e-05, 0, 0, 0, 0, 0, 0,
 1e-05, 0, 1e-05, 0, 0, 0, 0, 0, 0, 0,
 0, 1e-05, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, -3.49937e-16, -1.158e-10, 6.66e-06,
 1.8e-06, 1e-06, 1e-06, 1e-06, 2e-06, 2e-06, 2e-06, 0, 0, 0,
 1e-05, 0, 0, 1e-05, 0, 1e-05, 0, 0, 0, 0,
 0, 0, 1e-05, 0, 1e-05, 0, 0, 0, 0, 0,
 0, 0, 0, 1e-05, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, -7.571e-17,
 8.5162e-09, 5.64e-06, 2.9e-06, 2e-06, 1e-06, 1e-06, 2e-06, 2e-06, 2e-06, 0,
 0, 0, 1e-05, 0, 0, 1e-05, 0, 1e-05, 0, 1e-05,
 0, 0, 0, 0, 1e-05, 0, 1e-05, 0, 0, 1e-05,
 0, 0, 0, 0, 0, 1e-05, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 1.093e-16, -1.34e-10, 4.98e-06, 2.2e-06, 0, -1e-06, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, -1e-05, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 2.78e-17, 7.598e-09, 4.28e-06, 3.3e-06, 1e-06, 0, 1e-06,
 1e-06, 1e-06, 1e-06, 0, 0, 0, 1e-05, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 1e-05, 0,
 1e-05, 0, 0, 0, 0, 0, 0, 0, 0, 1e-05,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 1.767e-15, 9.588e-09, 3.7e-06, 2.9e-06, 0,
 -1e-06, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 7.29e-15, 8.76e-09, 3.41e-06,
 3.8e-06, 0, 0, 0, 1e-06, 1e-06, 1e-06, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 1e-05, 0, 1e-05, 0, 0, 0, 0, 0,
 0, 0, 0, 1e-05, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 2.8e-14,
 5.21e-09, 3.23e-06, 3.5e-06, 0, 0, 0, 0, 0, 1e-06, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 1e-05, 0, 1e-05, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, -7.573e-15, 4.81216e-07, 7.478e-05, -3.66e-05, 1.1e-05, 1.1e-05, 1=
=2E1e-05,
 1.1e-05, 1.1e-05, 1.1e-05, 1e-05, 1e-05, 1e-05, 2e-05, 1e-05, 1e-05, 2e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 2e-05, 1e-05,
 2e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 2e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 0, 0, 0, 0,
 0, 0, 0, 0, 0, -4.732e-14, 2.3967e-07, 6.847e-05, -2.95e-05, 1e-05,
 1e-05, 1e-05, 1.1e-05, 1.1e-05, 1.1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 2e-05, 1e-05, 2e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 1e-05, 2e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 0, 0,
 0, 0, 0, 0, 0, 0, 0, -2.3016e-13, 1.24857e-06, 6.129e-05,
 -2.4e-05, 7e-06, 7e-06, 8e-06, 8e-06, 8e-06, 8e-06, 1e-05, 1e-05, 0,
 1e-05, 1e-05, 0, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 0, 1e-05, 1e-05, 0, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 0, 1e-05, 1e-05, 0,
 0, 0, 0, 0, 0, 0, 0, 0, -1.28e-19, -9.306e-13,
 5.4944e-07, 5.165e-05, -1.92e-05, 4e-06, 3e-06, 3e-06, 4e-06, 4e-06, 4e-06,=
 1e-05,
 0, 0, 1e-05, 0, 0, 1e-05, 0, 1e-05, 0, 1e-05,
 0, 0, 0, 0, 1e-05, 0, 1e-05, 0, 0, 1e-05,
 0, 1e-05, 0, 0, 1e-05, 1e-05, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 3.09192e-16, -3.2e-12, 1.04287e-06, 4.284e-05, -1.55e-05, 1e-06, 1e-06, 1e-=
06, 2e-06, 2e-06,
 2e-06, 0, 0, 0, 1e-05, 0, 0, 1e-05, 0, 1e-05,
 0, 1e-05, 0, 0, 0, 0, 1e-05, 0, 1e-05, 0,
 0, 0, 0, 0, 0, 0, 0, 1e-05, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, -1.91286e-16, -9.55e-12, 1.2043e-06, 4.157e-05, -5.5e-06, 8e-06, 8e-0=
6, 9e-06,
 9e-06, 9e-06, 9e-06, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 0, 1e-05, 1e-05, 0,
 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 0, 1e-05, 1e-05, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 3.938e-17, -2.512e-11, 1.1505e-06, 3.357e-05, -4.3e-06, 1e-06,
 2e-06, 2e-06, 2e-06, 2e-06, 2e-06, 0, 0, 0, 1e-05, 0,
 0, 1e-05, 0, 1e-05, 0, 1e-05, 0, 0, 0, 0,
 1e-05, 0, 1e-05, 0, 0, 1e-05, 0, 0, 0, 0,
 1e-05, 1e-05, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, -2.191e-16, -5.89e-11, 8.29e-07, 3.097e-05,
 1.2e-06, 5e-06, 5e-06, 6e-06, 6e-06, 6e-06, 6e-06, 1e-05, 0, 0,
 1e-05, 1e-05, 0, 1e-05, 0, 1e-05, 1e-05, 1e-05, 0, 0,
 0, 1e-05, 1e-05, 0, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 0, 0, 1e-05, 1e-05, 0, 1e-05, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, -8.739e-16, -1.239e-10,
 1.5056e-06, 2.628e-05, 5.4e-06, 6e-06, 6e-06, 6e-06, 7e-06, 7e-06, 7e-06, 1=
e-05,
 0, 0, 1e-05, 1e-05, 0, 1e-05, 0, 1e-05, 1e-05, 1e-05,
 1e-05, 0, 0, 1e-05, 1e-05, 0, 1e-05, 1e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 0, 1e-05, 1e-05, 1e-05, 0, 1e-05, 0, 0,
 1e-05, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 -2.97e-15, 5.15352e-08, 1.5729e-06, 2.203e-05, 4e-06, 2e-06, 2e-06, 2e-06, =
3e-06, 3e-06,
 3e-06, 0, 0, 0, 1e-05, 0, 0, 1e-05, 0, 1e-05,
 0, 1e-05, 0, 0, 0, 0, 1e-05, 0, 1e-05, 0,
 0, 1e-05, 0, 0, 0, 0, 1e-05, 1e-05, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, -6.8e-20, -8.72e-15, -3.953e-10, 1.1452e-06, 1.786e-05, 7.3e-06, 3e-06, =
3e-06, 3e-06,
 3e-06, 3e-06, 3e-06, 1e-05, 0, 0, 1e-05, 0, 0, 1e-05,
 0, 1e-05, 0, 1e-05, 0, 0, 0, 0, 1e-05, 0,
 1e-05, 0, 0, 1e-05, 0, 1e-05, 0, 0, 1e-05, 1e-05,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, -4.046e-19, -2.007e-14, -5.81e-10, 1.165e-06, 1.51e-05, 5e-06, -2e=
-06,
 -2e-06, -2e-06, -1e-06, -1e-06, -1e-06, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, -1e-05, 0,
 0, -1e-05, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, -1e-05, 0, 0, -1e-05, 0, 0,
 0, 0, 0, 0, 0, -3.44075e-16, -2.08e-14, -6.96e-10, 1.203e-06, 1.37e-05,
 1e-05, 3e-06, 3e-06, 3e-06, 3e-06, 3e-06, 3e-06, 1e-05, 0, 0,
 1e-05, 0, 0, 1e-05, 0, 1e-05, 0, 1e-05, 0, 0,
 0, 0, 1e-05, 0, 1e-05, 0, 0, 1e-05, 0, 1e-05,
 0, 0, 1e-05, 1e-05, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, -2.49775e-16, 7.95e-14, 1.913e-09,
 1.228e-06, 1.08e-05, 8e-06, 1e-06, 0, 0, 0, 0, 1e-06, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 1e-05, 0, 1e-05, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 8.083e-17,
 6.3e-13, 6.511e-09, 8.03e-07, 9.1e-06, 9e-06, 1e-06, 0, 1e-06, 1e-06, 1e-06=
,
 1e-06, 0, 0, 0, 1e-05, 0, 0, 1e-05, 0, 0,
 0, 0, 0, 0, 0, 0, 1e-05, 0, 1e-05, 0,
 0, 0, 0, 0, 0, 0, 0, 1e-05, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 4.119e-16, 2.67e-12, 5.55e-09, 7.72e-07, 8.4e-06, 8e-06, 1e-06, 0, 0,
 0, 0, 1e-06, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 1e-05, 0,
 1e-05, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 1.696e-18, -4.166e-12, -1.1873e-08, 4.1432e-05, 0.0002029,
 -0.000103, 1e-06, 2.9e-05, 2.9e-05, 2.9e-05, 2.9e-05, 2.9e-05, 3e-05, 3e-05=
, 3e-05,
 3e-05, 3e-05, 3e-05, 3e-05, 3e-05, 3e-05, 3e-05, 3e-05, 3e-05, 3e-05,
 2e-05, 3e-05, 3e-05, 2e-05, 3e-05, 3e-05, 3e-05, 3e-05, 3e-05, 3e-05,
 3e-05, 3e-05, 3e-05, 3e-05, 3e-05, 3e-05, 2e-05, 3e-05, 3e-05, 2e-05,
 0, 0, 0, 0, 0, 0, 0, -6.0544e-16, -1.671e-11, 5.57881e-07,
 3.8394e-05, 0.00018, -7.3e-05, -4e-06, 2.1e-05, 2.1e-05, 2.2e-05, 2.2e-05, =
2.2e-05, 2e-05,
 2e-05, 2e-05, 3e-05, 2e-05, 2e-05, 3e-05, 2e-05, 3e-05, 2e-05, 2e-05,
 2e-05, 2e-05, 2e-05, 2e-05, 3e-05, 2e-05, 3e-05, 2e-05, 2e-05, 2e-05,
 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 3e-05, 2e-05, 2e-05, 2e-05, 2e-05,
 2e-05, 2e-05, 0, 0, 0, 0, 0, 0, 0, -4.2135e-15,
 -5.66e-11, 1.49331e-06, 3.7554e-05, 0.0001494, -6.1e-05, -1.3e-05, 1.2e-05,=
 1.3e-05, 1.3e-05, 1.3e-05,
 1.3e-05, 1e-05, 1e-05, 1e-05, 2e-05, 1e-05, 1e-05, 2e-05, 1e-05, 2e-05,
 1e-05, 2e-05, 1e-05, 1e-05, 1e-05, 1e-05, 2e-05, 1e-05, 2e-05, 1e-05,
 1e-05, 2e-05, 1e-05, 1e-05, 1e-05, 1e-05, 2e-05, 2e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 0, 0, 0, 0, 0, 0,
 -8.007e-19, -2.4057e-14, -1.6602e-10, 1.32884e-06, 4.193e-05, 0.000136, -2.=
8e-05, 0, 2.1e-05, 2.1e-05,
 2.2e-05, 2.2e-05, 2.2e-05, 2e-05, 2e-05, 2e-05, 3e-05, 2e-05, 2e-05, 3e-05,
 2e-05, 3e-05, 2e-05, 3e-05, 2e-05, 2e-05, 2e-05, 2e-05, 3e-05, 2e-05,
 3e-05, 2e-05, 2e-05, 3e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 3e-05,
 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 0, 0, 0, 0,
 0, 0, -2.97959e-16, -1.1577e-13, -4.3e-10, 1.65874e-06, 3.6469e-05, 0.00011=
07, -2.4e-05, -3e-06,
 1.9e-05, 1.9e-05, 2e-05, 1.9e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05,
 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 1e-05, 2e-05,
 2e-05, 1e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05,
 2e-05, 2e-05, 2e-05, 2e-05, 1e-05, 2e-05, 2e-05, 1e-05, 0, 0,
 0, 0, 0, 0, 2.28625e-16, -4.724e-13, -9.986e-10, 1.5324e-06, 3.466e-05, 9.3=
2e-05,
 -1.7e-05, -6e-06, 1.4e-05, 1.5e-05, 1.5e-05, 1.5e-05, 1.5e-05, 2e-05, 1e-05=
, 1e-05,
 2e-05, 2e-05, 1e-05, 2e-05, 1e-05, 2e-05, 2e-05, 2e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 2e-05, 1e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05,
 1e-05, 1e-05, 2e-05, 2e-05, 1e-05, 2e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 0, 0, 0, 0, 0, 0, -2.2294e-16, -1.6564e-12, -2.1046e-09, 1.8463e-06,
 3.13e-05, 7.83e-05, -2e-06, -1e-06, 1.4e-05, 1.6e-05, 1.6e-05, 1.6e-05, 1.6=
e-05, 2e-05,
 1e-05, 1e-05, 2e-05, 2e-05, 1e-05, 2e-05, 1e-05, 2e-05, 2e-05, 2e-05,
 1e-05, 1e-05, 1e-05, 2e-05, 2e-05, 1e-05, 2e-05, 2e-05, 2e-05, 2e-05,
 2e-05, 2e-05, 1e-05, 1e-05, 2e-05, 2e-05, 1e-05, 2e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 0, 0, 0, 0, 0, -1.2e-19, -1.5232e-15, -5.062e-12,
 -4.061e-09, 2.0659e-06, 2.757e-05, 6.43e-05, 3e-06, 0, 1.5e-05, 1.6e-05, 1.=
6e-05, 1.6e-05,
 1.6e-05, 2e-05, 1e-05, 1e-05, 2e-05, 2e-05, 1e-05, 2e-05, 1e-05, 2e-05,
 2e-05, 2e-05, 1e-05, 1e-05, 1e-05, 2e-05, 2e-05, 1e-05, 2e-05, 2e-05,
 2e-05, 2e-05, 2e-05, 2e-05, 1e-05, 1e-05, 2e-05, 2e-05, 1e-05, 2e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 0, 0, 0, 0, 0, -1.307e-18,
 -6.157e-15, -1.3638e-11, -7.213e-09, 2.4017e-06, 2.79e-05, 5.78e-05, 7e-06,=
 4e-06, 1.2e-05, 1.4e-05,
 1.4e-05, 1.4e-05, 1.4e-05, 2e-05, 1e-05, 1e-05, 2e-05, 1e-05, 1e-05, 2e-05,
 1e-05, 2e-05, 1e-05, 2e-05, 1e-05, 1e-05, 1e-05, 1e-05, 2e-05, 1e-05,
 2e-05, 1e-05, 1e-05, 2e-05, 1e-05, 2e-05, 1e-05, 1e-05, 2e-05, 2e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 0, 0, 0, 0,
 0, -3.9423e-17, -2.335e-14, -3.262e-11, 5.2851e-08, 2.4359e-06, 2.153e-05, =
4.83e-05, 1.5e-05, 4e-06,
 9e-06, 1.1e-05, 1.1e-05, 1.1e-05, 1.1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-0=
5,
 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 2e-05, 1e-05, 2e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 1e-05, 2e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 0, 0,
 0, 0, 0, 2.0915e-16, -7.539e-14, -6.936e-11, 5.61e-09, 2.411e-06, 2.152e-05=
, 4.14e-05,
 1.9e-05, 7e-06, 1.1e-05, 1.1e-05, 1.2e-05, 1.2e-05, 1.2e-05, 1e-05, 1e-05, =
1e-05,
 2e-05, 1e-05, 1e-05, 2e-05, 1e-05, 2e-05, 1e-05, 2e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 2e-05, 1e-05, 2e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 1e-05, 2e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 0, 0, 0, 0, -7.3e-20, -3.446e-17, -2.06e-13, -1.3e-10, 1.6102e-07, 1.806e-0=
6,
 1.447e-05, 3.3e-05, 1.3e-05, -1e-06, -1e-06, 0, 1e-06, 1e-06, 1e-06, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 1e-05, 0, 1e-05, 0, 0, 0,
 0, 0, 0, 0, 0, 1e-05, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, -2.96e-19, -5.924e-16, -4.561e-13, -2.088e-10,
 6.573e-08, 1.908e-06, 1.376e-05, 3.04e-05, 2.3e-05, 1.2e-05, 8e-06, 9e-06, =
9e-06, 9e-06,
 9e-06, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 0, 1e-05, 1e-05, 0, 1e-05, 1e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 0, 1e-05, 1e-05, 0, 0, 0, 0, 0, -1.632e-18, -6.36e-16,
 -7.12e-13, -2.64e-10, 1.0953e-07, 1.577e-06, 9.79e-06, 2.28e-05, 1.8e-05, 6=
e-06, 1e-06, 1e-06,
 2e-06, 2e-06, 2e-06, 0, 0, 0, 1e-05, 0, 0, 1e-05,
 0, 1e-05, 0, 1e-05, 0, 0, 0, 0, 1e-05, 0,
 1e-05, 0, 0, 1e-05, 0, 0, 0, 0, 0, 1e-05,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 -4.6174e-16, 1.214e-15, -1.54e-13, 2.927e-08, 5.33e-08, 1.196e-06, 7.42e-06=
, 1.8e-05, 1.6e-05, 7e-06,
 3e-06, 2e-06, 3e-06, 3e-06, 3e-06, 0, 0, 0, 1e-05, 0,
 0, 1e-05, 0, 1e-05, 0, 1e-05, 0, 0, 0, 0,
 1e-05, 0, 1e-05, 0, 0, 1e-05, 0, 0, 0, 0,
 1e-05, 1e-05, 0, 0, 0, 0, 0, 0, 0, 0,
 0, -1.6e-20, -6.219e-17, 1.634e-14, 4.15e-12, 3.53e-10, 4.34e-08, 8.07e-07,=
 6.11e-06, 1.59e-05,
 1.5e-05, 4e-06, 0, 0, -1e-06, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 -1e-05, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, -1e-05, 0, 0, -1e-05,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 8.736e-18, -2.283e-14, -1.8312e-11, -5.1258e-09,
 9.74048e-06, 9.1703e-05, 0.00038016, 0.0004189, -0.00018, -0.00019, 2.1e-05=
, 6.8e-05, 7.1e-05, 7.1e-05,
 7.1e-05, 7e-05, 7e-05, 7e-05, 7e-05, 7e-05, 7e-05, 7e-05, 7e-05, 7e-05,
 7e-05, 7e-05, 7e-05, 7e-05, 7e-05, 7e-05, 8e-05, 7e-05, 8e-05, 7e-05,
 7e-05, 7e-05, 7e-05, 7e-05, 7e-05, 7e-05, 7e-05, 8e-05, 7e-05, 7e-05,
 7e-05, 7e-05, 7e-05, 7e-05, 0, 0, 0, 0, -1.3275e-16, -1.5151e-13,
 -7.1192e-11, 2.87478e-07, 4.9363e-06, 8.2807e-05, 0.00034845, 0.0003581, -0=
=2E000113, -0.000172, 9e-06, 5.9e-05,
 6.4e-05, 6.3e-05, 6.4e-05, 7e-05, 6e-05, 6e-05, 7e-05, 6e-05, 6e-05, 7e-05,
 6e-05, 7e-05, 6e-05, 7e-05, 6e-05, 6e-05, 6e-05, 6e-05, 7e-05, 6e-05,
 7e-05, 6e-05, 6e-05, 7e-05, 6e-05, 7e-05, 6e-05, 6e-05, 7e-05, 7e-05,
 6e-05, 6e-05, 6e-05, 6e-05, 6e-05, 6e-05, 0, 0, 0, -8.473e-19,
 -8.8841e-16, -8.0152e-13, -2.3478e-10, 4.75953e-07, 1.13885e-05, 8.8633e-05=
, 0.00030877, 0.0003029, -9.3e-05, -0.000139,
 9e-06, 5.4e-05, 5.7e-05, 5.7e-05, 5.8e-05, 6e-05, 6e-05, 5e-05, 6e-05, 6e-0=
5,
 5e-05, 6e-05, 5e-05, 6e-05, 6e-05, 6e-05, 6e-05, 6e-05, 5e-05, 6e-05,
 6e-05, 5e-05, 6e-05, 6e-05, 6e-05, 6e-05, 6e-05, 6e-05, 6e-05, 6e-05,
 6e-05, 6e-05, 6e-05, 6e-05, 5e-05, 5e-05, 6e-05, 5e-05, 0, 0,
 0, -1.7649e-16, -8.1863e-15, -3.4946e-12, -6.7303e-10, -5.7216e-08, 1.50765=
e-05, 9.3675e-05, 0.00027824, 0.0002608,
 -5.7e-05, -0.000117, 0, 4e-05, 4.4e-05, 4.5e-05, 4.5e-05, 5e-05, 4e-05, 4e-=
05,
 5e-05, 5e-05, 4e-05, 5e-05, 4e-05, 5e-05, 4e-05, 5e-05, 4e-05, 4e-05,
 4e-05, 4e-05, 5e-05, 4e-05, 5e-05, 4e-05, 5e-05, 5e-05, 5e-05, 5e-05,
 4e-05, 4e-05, 5e-05, 5e-05, 4e-05, 5e-05, 4e-05, 4e-05, 4e-05, 4e-05,
 0, 0, 0, 1.31325e-16, -4.5359e-14, -1.2922e-11, -1.7096e-09, 7.704e-08, 5.0=
184e-06, 7.734e-05,
 0.00023322, 0.0002215, -3.5e-05, -0.0001, -1.6e-05, 3.1e-05, 3.6e-05, 3.6e-=
05, 3.7e-05, 4e-05,
 3e-05, 3e-05, 4e-05, 4e-05, 3e-05, 4e-05, 3e-05, 4e-05, 4e-05, 4e-05,
 3e-05, 3e-05, 3e-05, 4e-05, 4e-05, 3e-05, 4e-05, 4e-05, 4e-05, 4e-05,
 4e-05, 4e-05, 3e-05, 3e-05, 4e-05, 4e-05, 3e-05, 4e-05, 3e-05, 3e-05,
 3e-05, 3e-05, 0, 0, -1.06e-18, -5.1768e-16, -2.155e-13, -4.137e-11, 9.55634=
e-07, 1.31397e-06,
 1.9213e-05, 8.318e-05, 0.0001968, 0.0001818, -6e-06, -5.6e-05, 6e-06, 3.9e-=
05, 4.6e-05, 4.7e-05,
 4.7e-05, 5e-05, 5e-05, 4e-05, 5e-05, 5e-05, 4e-05, 5e-05, 4e-05, 5e-05,
 5e-05, 5e-05, 5e-05, 4e-05, 4e-05, 5e-05, 5e-05, 4e-05, 5e-05, 5e-05,
 5e-05, 5e-05, 5e-05, 5e-05, 5e-05, 5e-05, 5e-05, 5e-05, 4e-05, 5e-05,
 4e-05, 4e-05, 5e-05, 4e-05, 0, 0, 9.6934e-17, -3.2785e-15, -8.675e-13, -1.1=
665e-10,
 -8.126e-09, 7.4333e-07, 1.4285e-05, 6.943e-05, 0.0001533, 0.0001373, -1e-05=
, -5.9e-05, -1.7e-05, 1.7e-05,
 2.2e-05, 2.3e-05, 2.3e-05, 2e-05, 2e-05, 2e-05, 3e-05, 2e-05, 2e-05, 3e-05,
 2e-05, 3e-05, 2e-05, 3e-05, 2e-05, 2e-05, 2e-05, 2e-05, 3e-05, 2e-05,
 3e-05, 2e-05, 2e-05, 3e-05, 2e-05, 2e-05, 2e-05, 2e-05, 3e-05, 3e-05,
 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 0, 0, -9.8835e-17, -1.6706e-14,
 -3.0091e-12, -2.9353e-10, 7.28388e-07, 2.6481e-06, 1.3113e-05, 6.903e-05, 0=
=2E000156, 0.0001494, 2.8e-05, -9e-06,
 1.5e-05, 3.9e-05, 4.7e-05, 4.9e-05, 4.9e-05, 5e-05, 5e-05, 4e-05, 5e-05, 5e=
-05,
 4e-05, 5e-05, 5e-05, 5e-05, 5e-05, 5e-05, 5e-05, 5e-05, 4e-05, 5e-05,
 5e-05, 4e-05, 5e-05, 5e-05, 5e-05, 5e-05, 5e-05, 5e-05, 5e-05, 5e-05,
 5e-05, 5e-05, 5e-05, 5e-05, 4e-05, 5e-05, 5e-05, 4e-05, 0, 6.04484e-16,
 -3.875e-16, -7.048e-14, -9.13e-12, -6.655e-10, -2.7391e-08, 2.9746e-06, 1.7=
758e-05, 6.563e-05, 0.0001294, 0.0001252,
 3.7e-05, -8e-06, 7e-06, 2.4e-05, 3.1e-05, 3.3e-05, 3.4e-05, 4e-05, 3e-05, 3=
e-05,
 4e-05, 3e-05, 3e-05, 4e-05, 3e-05, 4e-05, 3e-05, 4e-05, 3e-05, 3e-05,
 3e-05, 3e-05, 4e-05, 3e-05, 4e-05, 3e-05, 3e-05, 4e-05, 3e-05, 4e-05,
 3e-05, 3e-05, 4e-05, 4e-05, 3e-05, 3e-05, 3e-05, 3e-05, 3e-05, 3e-05,
 0, -4.52623e-16, -1.3257e-15, -2.5508e-13, -2.4461e-11, -1.3675e-09, 3.0129=
e-07, 2.3418e-06, 1.3762e-05, 4.952e-05,
 9.97e-05, 9.34e-05, 3e-05, 1e-06, 1.3e-05, 2.6e-05, 3.2e-05, 3.3e-05, 3.3e-=
05, 4e-05,
 3e-05, 3e-05, 4e-05, 3e-05, 3e-05, 4e-05, 3e-05, 4e-05, 3e-05, 4e-05,
 3e-05, 3e-05, 3e-05, 3e-05, 4e-05, 3e-05, 4e-05, 3e-05, 3e-05, 4e-05,
 3e-05, 4e-05, 3e-05, 3e-05, 4e-05, 4e-05, 3e-05, 3e-05, 3e-05, 3e-05,
 3e-05, 3e-05, -2.14e-19, 3.70356e-16, -6.57e-15, -8e-13, -5.815e-11, -2.552=
9e-09, -5.268e-08, 9.668e-07,
 1.1656e-05, 3.739e-05, 6.63e-05, 7.56e-05, 3.1e-05, -1e-06, -2e-06, 7e-06, =
1.1e-05, 1.1e-05,
 1.2e-05, 1e-05, 1e-05, 1e-05, 2e-05, 1e-05, 1e-05, 2e-05, 1e-05, 2e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 2e-05, 1e-05, 2e-05, 1e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 2e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 1e-05, 1e-05, -1.271e-18, -7.4167e-16, -2.396e-14, -2.1629e-1=
2, -1.2234e-10, 9.8676e-08,
 6.078e-08, 2.9919e-06, 1.2462e-05, 3.796e-05, 6.37e-05, 6.18e-05, 3.4e-05, =
5e-06, -1e-06, 3e-06,
 5e-06, 7e-06, 6e-06, 1e-05, 0, 0, 1e-05, 1e-05, 0, 1e-05,
 0, 1e-05, 1e-05, 1e-05, 1e-05, 0, 0, 1e-05, 1e-05, 0,
 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 0, 0, 1e-05, 1e-05,
 0, 1e-05, 0, 0, 1e-05, 0, 4.36673e-16, -5.534e-16, -7.08e-14, -4.978e-12,
 -2.247e-10, -6.499e-09, 1.9002e-07, 2.329e-06, 8.68e-06, 2.492e-05, 4.85e-0=
5, 5.19e-05, 3.8e-05, 1.9e-05,
 1.4e-05, 1.6e-05, 1.8e-05, 1.8e-05, 1.8e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e=
-05,
 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 1e-05, 2e-05,
 2e-05, 1e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05,
 2e-05, 2e-05, 2e-05, 2e-05, 1e-05, 2e-05, 2e-05, 1e-05, 6.30232e-16, -1.62e=
-15,
 -1.638e-13, -9.293e-12, -3.448e-10, -8.394e-09, 2.432e-07, 2.289e-06, 6.72e=
-06, 1.838e-05, 3.6e-05, 4.27e-05,
 3.2e-05, 1.6e-05, 6e-06, 4e-06, 4e-06, 5e-06, 5e-06, 1e-05, 0, 0,
 1e-05, 1e-05, 0, 1e-05, 0, 1e-05, 0, 1e-05, 0, 0,
 0, 0, 1e-05, 0, 1e-05, 0, 1e-05, 1e-05, 1e-05, 1e-05,
 0, 0, 1e-05, 1e-05, 0, 1e-05, 0, 0, 0, 0,
 -3.5622e-16, -3.264e-15, -2.372e-13, -1.171e-11, -3.8e-10, 1.247e-08, 2.31e=
-08, 1.147e-06, 5.03e-06, 1.415e-05,
 2.81e-05, 3.7e-05, 3.3e-05, 2.4e-05, 1.3e-05, 1e-05, 9e-06, 9e-06, 9e-06, 1=
e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 0, 1e-05, 1e-05, 0, 1e-05, 1e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 0, 1e-05,
 1e-05, 0, 1.11e-16, 6.34e-15, 1.89e-13, 2.15e-12, -4.6e-11, 2.01e-09, 6.5e-=
08, 9.76e-07,
 3.42e-06, 8.95e-06, 1.83e-05, 2.68e-05, 2.5e-05, 1.7e-05, 7e-06, 3e-06, 0, =
0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, -4.9015e-16, -2.9743e-14, -2.4325e-12, -1.30643e-10,
 5.99082e-07, 9.53841e-06, 2.70327e-05, 0.000124612, 0.0004076, 0.00093358, =
0.0012947, 0.0007911, -0.000228, -0.000691,
 -0.000391, -1.3e-05, 0.00013, 0.000157, 0.000161, 0.00016, 0.00016, 0.00016=
, 0.00017, 0.00016,
 0.00016, 0.00017, 0.00016, 0.00017, 0.00016, 0.00017, 0.00016, 0.00016, 0.0=
0016, 0.00016,
 0.00017, 0.00016, 0.00017, 0.00016, 0.00016, 0.00016, 0.00016, 0.00016, 0.0=
0016, 0.00016,
 0.00016, 0.00017, 0.00016, 0.00016, 0.00016, 0.00016, 0.00016, 0.00016, -2.=
3859e-15, -2.1226e-13,
 -1.21732e-11, -4.7515e-10, -1.2637e-08, 2.28449e-06, 1.89771e-05, 0.0001146=
14, 0.00039097, 0.00082057, 0.0010768, 0.0006514,
 -0.000183, -0.000557, -0.000337, -2.5e-05, 0.000132, 0.000181, 0.000187, 0.=
00019, 0.00019, 0.00019,
 0.00019, 0.00019, 0.00019, 0.00019, 0.00019, 0.00019, 0.00019, 0.00019, 0.0=
0019, 0.00019,
 0.00018, 0.00019, 0.00019, 0.00018, 0.00019, 0.00019, 0.00019, 0.00019, 0.0=
0019, 0.00019,
 0.00019, 0.00019, 0.00019, 0.00019, 0.00019, 0.00019, 0.00018, 0.00019, 0.0=
0019, 0.00018,
 -2.01848e-14, -1.19634e-12, -5.0207e-11, -1.47796e-09, -3.0573e-08, 5.06519=
e-06, 3.48743e-05, 0.000145267, 0.00041313, 0.0007582,
 0.0009053, 0.0005277, -0.00013, -0.000476, -0.000311, -5.4e-05, 7.6e-05, 0.=
000123, 0.000128, 0.00013,
 0.00013, 0.00013, 0.00013, 0.00013, 0.00013, 0.00013, 0.00013, 0.00013, 0.0=
0013, 0.00013,
 0.00013, 0.00013, 0.00013, 0.00013, 0.00014, 0.00013, 0.00014, 0.00013, 0.0=
0013, 0.00013,
 0.00013, 0.00013, 0.00013, 0.00013, 0.00013, 0.00013, 0.00013, 0.00013, 0.0=
0013, 0.00013,
 0.00013, 0.00013, -1.2567e-13, -5.5298e-12, -1.7571e-10, -4.024e-09, 1.2840=
9e-06, 9.28939e-06, 2.90954e-05, 0.000120709,
 0.00036067, 0.0006256, 0.0007594, 0.0004576, -9.9e-05, -0.000364, -0.000247=
, -4.9e-05, 8.3e-05, 0.000133,
 0.000141, 0.00014, 0.00014, 0.00014, 0.00015, 0.00014, 0.00014, 0.00015, 0.=
00014, 0.00015,
 0.00014, 0.00014, 0.00014, 0.00014, 0.00014, 0.00014, 0.00015, 0.00014, 0.0=
0015, 0.00014,
 0.00014, 0.00014, 0.00014, 0.00014, 0.00014, 0.00014, 0.00014, 0.00015, 0.0=
0014, 0.00014,
 0.00014, 0.00014, 0.00014, 0.00014, -6.4176e-13, -2.1555e-11, -5.3382e-10, =
-9.7667e-09, 9.3054e-07, 1.00632e-05,
 3.8873e-05, 0.000128856, 0.00033007, 0.0006117, 0.000707, 0.0004507, 1.3e-0=
5, -0.000226, -0.000176, -3e-05,
 8.1e-05, 0.000122, 0.000132, 0.00014, 0.00013, 0.00013, 0.00014, 0.00014, 0=
=2E00013, 0.00014,
 0.00013, 0.00014, 0.00013, 0.00014, 0.00013, 0.00013, 0.00013, 0.00013, 0.0=
0014, 0.00013,
 0.00014, 0.00013, 0.00014, 0.00014, 0.00013, 0.00014, 0.00013, 0.00013, 0.0=
0014, 0.00014,
 0.00013, 0.00014, 0.00013, 0.00013, 0.00013, 0.00013, -2.7583e-12, -7.2425e=
-11, -1.4337e-09, 2.04268e-06,
 3.42155e-06, 1.72458e-05, 5.0762e-05, 0.00014696, 0.00030641, 0.0005076, 0.=
0005674, 0.0003753, 5.8e-05, -0.000159,
 -0.000121, 2.1e-05, 0.000122, 0.000166, 0.000179, 0.00019, 0.00018, 0.00018=
, 0.00019, 0.00018,
 0.00018, 0.00019, 0.00018, 0.00019, 0.00018, 0.00019, 0.00018, 0.00018, 0.0=
0018, 0.00018,
 0.00019, 0.00018, 0.00019, 0.00018, 0.00018, 0.00019, 0.00018, 0.00019, 0.0=
0018, 0.00018,
 0.00019, 0.00019, 0.00018, 0.00018, 0.00018, 0.00018, 0.00018, 0.00018, -1.=
0157e-11, -2.1353e-10,
 -3.4535e-09, 1.03846e-06, 4.68348e-06, 1.38438e-05, 4.3644e-05, 0.00011915,=
 0.00026132, 0.0004315, 0.0004402, 0.000298,
 4.6e-05, -0.000105, -0.000113, -3.4e-05, 4.4e-05, 7.6e-05, 9.5e-05, 9e-05, =
0.0001, 9e-05,
 0.0001, 0.0001, 9e-05, 0.0001, 9e-05, 0.0001, 0.0001, 0.0001, 0.0001, 9e-05=
,
 9e-05, 0.0001, 0.0001, 9e-05, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.000=
1,
 0.0001, 0.0001, 0.0001, 0.0001, 9e-05, 0.0001, 9e-05, 9e-05, 0.0001, 9e-05,
 -3.2584e-11, -5.6011e-10, -7.5422e-09, 6.6303e-07, 1.67109e-06, 9.664e-06, =
3.9253e-05, 0.00010707, 0.00020689, 0.00032,
 0.0003565, 0.000229, 4.3e-05, -9.1e-05, -9.8e-05, -2.3e-05, 4.8e-05, 8.8e-0=
5, 0.000102, 0.0001,
 0.00011, 0.0001, 0.00011, 0.00011, 0.0001, 0.00011, 0.00011, 0.00011, 0.000=
11, 0.00011,
 0.00011, 0.00011, 0.0001, 0.00011, 0.00011, 0.0001, 0.00011, 0.00011, 0.000=
11, 0.00011,
 0.00011, 0.00011, 0.00011, 0.00011, 0.00011, 0.00011, 0.00011, 0.00011, 0.0=
001, 0.00011,
 0.00011, 0.0001, -9.227e-11, -1.3209e-09, -1.5057e-08, -1.3687e-07, 2.043e-=
06, 1.3132e-05, 4.5549e-05, 0.00011077,
 0.00019721, 0.0002714, 0.00029, 0.000198, 5.2e-05, -5.4e-05, -7.5e-05, -3.8=
e-05, 1.2e-05, 4.6e-05,
 5.7e-05, 6e-05, 6e-05, 6e-05, 7e-05, 6e-05, 6e-05, 7e-05, 6e-05, 7e-05,
 6e-05, 6e-05, 6e-05, 6e-05, 6e-05, 6e-05, 7e-05, 6e-05, 7e-05, 6e-05,
 6e-05, 6e-05, 6e-05, 6e-05, 6e-05, 6e-05, 6e-05, 7e-05, 6e-05, 6e-05,
 6e-05, 6e-05, 6e-05, 6e-05, -2.328e-10, -2.8203e-09, -2.762e-08, 8.429e-08,=
 7.097e-06, 1.376e-05,
 3.5373e-05, 7.853e-05, 0.00015536, 0.0002159, 0.0002569, 0.000194, 7.9e-05,=
 -4e-06, -1.7e-05, 8e-06,
 3.7e-05, 6.4e-05, 7.5e-05, 8e-05, 8e-05, 8e-05, 8e-05, 8e-05, 8e-05, 8e-05,
 8e-05, 8e-05, 8e-05, 8e-05, 8e-05, 8e-05, 7e-05, 8e-05, 8e-05, 7e-05,
 8e-05, 8e-05, 8e-05, 8e-05, 8e-05, 8e-05, 8e-05, 8e-05, 8e-05, 8e-05,
 8e-05, 8e-05, 7e-05, 8e-05, 8e-05, 7e-05, -5.2595e-10, -5.471e-09, 3.3526e-=
07, 1.93274e-06,
 4.8266e-06, 1.2541e-05, 2.551e-05, 7.055e-05, 0.0001306, 0.0001876, 0.00019=
93, 0.000172, 9.7e-05, 2.2e-05,
 1.2e-05, 2.6e-05, 4e-05, 5.6e-05, 6.3e-05, 6e-05, 7e-05, 7e-05, 7e-05, 7e-0=
5,
 7e-05, 7e-05, 7e-05, 7e-05, 7e-05, 7e-05, 7e-05, 7e-05, 6e-05, 7e-05,
 7e-05, 6e-05, 7e-05, 7e-05, 7e-05, 7e-05, 7e-05, 7e-05, 7e-05, 7e-05,
 7e-05, 7e-05, 7e-05, 7e-05, 6e-05, 7e-05, 7e-05, 6e-05, -1.0636e-09, -9.625=
e-09,
 5.396e-08, -3.247e-07, 2.134e-07, 5.333e-06, 2.117e-05, 5.847e-05, 8.99e-05=
, 0.0001216, 0.0001295, 0.0001,
 4.1e-05, -5e-06, -2.7e-05, -3.3e-05, -1.8e-05, -7e-06, 1e-06, 0, 1e-05, 0,
 1e-05, 0, 0, 1e-05, 0, 1e-05, 0, 1e-05, 0, 0,
 0, 0, 1e-05, 0, 1e-05, 0, 0, 1e-05, 0, 1e-05,
 0, 0, 1e-05, 1e-05, 0, 0, 0, 0, 0, 0,
 -1.907e-09, -1.5198e-08, -1.0168e-07, 3.499e-07, 4.395e-06, 1.4271e-05, 3.7=
88e-05, 5.741e-05, 8.02e-05, 0.0001081,
 0.0001272, 0.000126, 0.00011, 8.5e-05, 6.4e-05, 5.7e-05, 5.5e-05, 5.9e-05, =
6.1e-05, 6e-05,
 6e-05, 6e-05, 7e-05, 7e-05, 6e-05, 7e-05, 6e-05, 7e-05, 7e-05, 7e-05,
 6e-05, 6e-05, 6e-05, 6e-05, 7e-05, 6e-05, 7e-05, 7e-05, 7e-05, 7e-05,
 7e-05, 7e-05, 6e-05, 6e-05, 7e-05, 7e-05, 6e-05, 7e-05, 6e-05, 6e-05,
 6e-05, 6e-05, -2.945e-09, -2.0931e-08, 6.5455e-07, 1.5926e-06, 3.401e-06, 8=
=2E377e-06, 1.624e-05, 2.814e-05,
 4.96e-05, 6.34e-05, 8.15e-05, 8.4e-05, 6.7e-05, 4.2e-05, 2.6e-05, 2e-05, 1.=
9e-05, 2.3e-05,
 2.4e-05, 2e-05, 2e-05, 3e-05, 3e-05, 3e-05, 2e-05, 3e-05, 2e-05, 3e-05,
 3e-05, 3e-05, 3e-05, 2e-05, 2e-05, 3e-05, 3e-05, 2e-05, 3e-05, 3e-05,
 3e-05, 3e-05, 3e-05, 3e-05, 2e-05, 2e-05, 3e-05, 3e-05, 2e-05, 3e-05,
 2e-05, 2e-05, 3e-05, 2e-05, -3.586e-09, -2.311e-08, 5.86e-08, 3.35e-07, 2.5=
28e-06, 5.548e-06,
 1.028e-05, 2.148e-05, 3.71e-05, 5.12e-05, 6.08e-05, 6.3e-05, 5.7e-05, 2.8e-=
05, 2.5e-05, 1.9e-05,
 1.3e-05, 1.2e-05, 1.1e-05, 1e-05, 2e-05, 1e-05, 1e-05, 1e-05, 1e-05, 2e-05,
 1e-05, 2e-05, 1e-05, 2e-05, 1e-05, 1e-05, 1e-05, 1e-05, 2e-05, 1e-05,
 2e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 2e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 4.945e-08, 3.795e-08, -4e-10, 2.1=
9e-07,
 8.89e-07, 3.24e-06, 7.07e-06, 1.369e-05, 2.38e-05, 3.38e-05, 4.31e-05, 4.6e=
-05, 4.4e-05, 3.5e-05,
 2.4e-05, 1.7e-05, 1.1e-05, 7e-06, 6e-06, 1e-05, 0, 1e-05, 0, 1e-05,
 0, 1e-05, 0, 1e-05, 0, 1e-05, 0, 0, 0, 0,
 1e-05, 0, 1e-05, 0, 1e-05, 1e-05, 1e-05, 1e-05, 0, 0,
 1e-05, 1e-05, 0, 1e-05, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 -3.16059e-08, 2.64463e-06, 2.0024e-05, 0.000115558, 0.000275931, 0.00063493=
7, 0.00132576, 0.00223353, 0.0030724, 0.0035184,
 0.0030131, 0.0016, -5.3e-05, -0.001273, -0.001487, -0.000924, -0.000203, 0.=
00036, 0.000649, 0.00077,
 0.00082, 0.00082, 0.00083, 0.00083, 0.00083, 0.00083, 0.00083, 0.00083, 0.0=
0083, 0.00083,
 0.00083, 0.00083, 0.00082, 0.00083, 0.00083, 0.00082, 0.00083, 0.00083, 0.0=
0083, 0.00083,
 0.00083, 0.00083, 0.00083, 0.00083, 0.00083, 0.00083, 0.00083, 0.00083, 0.0=
0082, 0.00083,
 0.00083, 0.00082, 9.74796e-06, 2.19155e-05, 5.07277e-05, 9.19802e-05, 0.000=
262842, 0.000619318, 0.00120264, 0.00199876,
 0.0026331, 0.0029193, 0.0024617, 0.001291, -3.1e-05, -0.000992, -0.001209, =
-0.000848, -0.000323, 0.000143,
 0.000427, 0.00056, 0.00061, 0.00062, 0.00062, 0.00062, 0.00062, 0.00062, 0.=
00062, 0.00062,
 0.00062, 0.00062, 0.00062, 0.00062, 0.00062, 0.00062, 0.00063, 0.00062, 0.0=
0063, 0.00062,
 0.00062, 0.00062, 0.00062, 0.00062, 0.00062, 0.00062, 0.00062, 0.00063, 0.0=
0062, 0.00062,
 0.00062, 0.00062, 0.00062, 0.00062, 4.84562e-06, 1.55631e-05, 3.16594e-05, =
0.000121436, 0.000303845, 0.00062868,
 0.00116178, 0.0017721, 0.002268, 0.0024442, 0.0020984, 0.00114, 0.000102, -=
0.000711, -0.00093, -0.000653,
 -0.000205, 0.00024, 0.000472, 0.0006, 0.00065, 0.00067, 0.00067, 0.00068, 0=
=2E00067, 0.00068,
 0.00067, 0.00068, 0.00068, 0.00068, 0.00067, 0.00067, 0.00067, 0.00067, 0.0=
0068, 0.00067,
 0.00068, 0.00068, 0.00068, 0.00068, 0.00068, 0.00068, 0.00067, 0.00067, 0.0=
0068, 0.00068,
 0.00067, 0.00068, 0.00067, 0.00067, 0.00067, 0.00067, 3.75922e-06, 2.68105e=
-05, 9.1761e-05, 0.000185945,
 0.000366148, 0.00060518, 0.00105861, 0.0014751, 0.0018532, 0.0020154, 0.001=
636, 0.000921, 9.8e-05, -0.000527,
 -0.000693, -0.000587, -0.00026, 6.7e-05, 0.000275, 0.0004, 0.00045, 0.00048=
, 0.00049, 0.00049,
 0.00049, 0.0005, 0.00049, 0.0005, 0.00049, 0.0005, 0.00049, 0.00049, 0.0004=
9, 0.00049,
 0.0005, 0.00049, 0.0005, 0.00049, 0.00049, 0.0005, 0.00049, 0.00049, 0.0004=
9, 0.00049,
 0.0005, 0.0005, 0.00049, 0.00049, 0.00049, 0.00049, 0.00049, 0.00049, 2.840=
28e-06, 3.86472e-05,
 7.21188e-05, 0.000153258, 0.00032985, 0.00064979, 0.00105876, 0.0014597, 0.=
0017913, 0.0017668, 0.001501, 0.000887,
 0.000238, -0.00028, -0.000449, -0.000345, -7.2e-05, 0.000225, 0.00042, 0.00=
053, 0.00057, 0.0006,
 0.00061, 0.00061, 0.00061, 0.00061, 0.00061, 0.00061, 0.00061, 0.00061, 0.0=
0061, 0.00061,
 0.00061, 0.00061, 0.00062, 0.00061, 0.00062, 0.00061, 0.00061, 0.00061, 0.0=
0061, 0.00061,
 0.00061, 0.00061, 0.00061, 0.00062, 0.00061, 0.00061, 0.00061, 0.00061, 0.0=
0061, 0.00061,
 3.21299e-06, 2.22627e-05, 5.6728e-05, 0.000136843, 0.00029928, 0.0005214, 0=
=2E00081173, 0.0011544, 0.0013984, 0.0014813,
 0.001236, 0.000771, 0.000289, -0.000123, -0.000262, -0.000241, -7.9e-05, 0.=
000145, 0.000308, 0.00042,
 0.00047, 0.0005, 0.00051, 0.00052, 0.00051, 0.00052, 0.00051, 0.00052, 0.00=
051, 0.00052,
 0.00051, 0.00051, 0.00051, 0.00051, 0.00052, 0.00051, 0.00052, 0.00051, 0.0=
0052, 0.00052,
 0.00051, 0.00052, 0.00051, 0.00051, 0.00052, 0.00052, 0.00051, 0.00052, 0.0=
0051, 0.00051,
 0.00051, 0.00051, 1.58603e-05, 3.0585e-05, 7.7984e-05, 0.000156313, 0.00033=
862, 0.00056014, 0.0008189, 0.0010641,
 0.0012039, 0.0012092, 0.001011, 0.000644, 0.000266, -7.6e-05, -0.000214, -0=
=2E000222, -9e-05, 7.9e-05,
 0.000203, 0.00028, 0.00034, 0.00035, 0.00037, 0.00037, 0.00037, 0.00038, 0.=
00037, 0.00038,
 0.00037, 0.00038, 0.00037, 0.00037, 0.00037, 0.00037, 0.00038, 0.00037, 0.0=
0038, 0.00037,
 0.00037, 0.00038, 0.00037, 0.00038, 0.00037, 0.00037, 0.00038, 0.00038, 0.0=
0037, 0.00037,
 0.00037, 0.00037, 0.00037, 0.00037, 1.30497e-05, 4.2808e-05, 9.6311e-05, 0.=
000183736, 0.00030833, 0.00046446,
 0.0006951, 0.0008672, 0.0010041, 0.0009475, 0.000806, 0.000591, 0.000368, 0=
=2E000119, 1.4e-05, -2.9e-05,
 3e-05, 0.000156, 0.000257, 0.00033, 0.00037, 0.00038, 0.0004, 0.00041, 0.00=
041, 0.00041,
 0.00041, 0.00041, 0.00041, 0.00041, 0.00041, 0.00041, 0.0004, 0.00041, 0.00=
041, 0.0004,
 0.00041, 0.00041, 0.00041, 0.00041, 0.00041, 0.00041, 0.00041, 0.00041, 0.0=
0041, 0.00041,
 0.00041, 0.00041, 0.0004, 0.00041, 0.00041, 0.0004, 2.55982e-05, 5.7248e-05=
, 9.1472e-05, 0.00015168,
 0.0002237, 0.0003691, 0.0005293, 0.0007012, 0.0008026, 0.0008358, 0.000688,=
 0.000476, 0.000268, 0.000121,
 1.5e-05, -1.5e-05, 6.8e-05, 0.000153, 0.000224, 0.00029, 0.00033, 0.00036, =
0.00037, 0.00038,
 0.00038, 0.00038, 0.00038, 0.00038, 0.00038, 0.00038, 0.00038, 0.00038, 0.0=
0038, 0.00038,
 0.00038, 0.00038, 0.00038, 0.00038, 0.00038, 0.00038, 0.00038, 0.00038, 0.0=
0038, 0.00038,
 0.00038, 0.00038, 0.00038, 0.00038, 0.00038, 0.00038, 0.00038, 0.00038, 9.2=
738e-06, 3.1871e-05,
 5.5852e-05, 0.00013726, 0.00023549, 0.00035224, 0.0004591, 0.0005827, 0.000=
6063, 0.0006199, 0.000545, 0.000436,
 0.000304, 0.000151, 7.6e-05, 3.7e-05, 7.2e-05, 0.000129, 0.000176, 0.00022,=
 0.00025, 0.00027,
 0.00028, 0.00029, 0.00028, 0.00028, 0.00029, 0.00029, 0.00029, 0.00029, 0.0=
0029, 0.00029,
 0.00028, 0.00029, 0.00029, 0.00028, 0.00029, 0.00029, 0.00029, 0.00029, 0.0=
0029, 0.00029,
 0.00029, 0.00029, 0.00029, 0.00029, 0.00029, 0.00029, 0.00028, 0.00029, 0.0=
0029, 0.00028,
 1.4299e-05, 3.2166e-05, 5.8108e-05, 9.99e-05, 0.00015896, 0.0002508, 0.0003=
404, 0.000455, 0.0005143, 0.000497,
 0.000449, 0.000342, 0.000254, 0.000177, 0.000129, 0.000121, 0.000149, 0.000=
185, 0.00022, 0.00025,
 0.00027, 0.00029, 0.0003, 0.0003, 0.00031, 0.0003, 0.0003, 0.00031, 0.0003,=
 0.00031,
 0.0003, 0.0003, 0.0003, 0.0003, 0.00031, 0.0003, 0.00031, 0.0003, 0.00031, =
0.00031,
 0.00031, 0.00031, 0.0003, 0.0003, 0.00031, 0.00031, 0.0003, 0.00031, 0.0003=
, 0.0003,
 0.0003, 0.0003, -1.193e-06, 5.281e-06, 2.857e-05, 4.964e-05, 0.00011141, 0.=
0001657, 0.0002104, 0.0002265,
 0.0002627, 0.000292, 0.000261, 0.000156, 0.000112, 2.3e-05, -2.7e-05, -4.6e=
-05, -4.3e-05, -4.1e-05,
 -3.3e-05, -3e-05, -1e-05, 1e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05,
 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 3e-05, 2e-05, 3e-05, 2e-05,
 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05,
 2e-05, 2e-05, 2e-05, 2e-05, 2.1917e-05, 2.952e-05, 4.587e-05, 7.934e-05, 0.=
00010145, 0.0001509,
 0.0001825, 0.0002336, 0.0002613, 0.000279, 0.000249, 0.000197, 0.00019, 0.0=
00135, 9.5e-05, 8.7e-05,
 8.1e-05, 7.9e-05, 8.6e-05, 9e-05, 0.0001, 0.00011, 0.00012, 0.00012, 0.0001=
2, 0.00012,
 0.00012, 0.00012, 0.00012, 0.00013, 0.00012, 0.00012, 0.00012, 0.00012, 0.0=
0013, 0.00012,
 0.00013, 0.00012, 0.00012, 0.00013, 0.00012, 0.00012, 0.00012, 0.00012, 0.0=
0013, 0.00013,
 0.00012, 0.00012, 0.00012, 0.00012, 0.00012, 0.00012, 6.477e-06, 7e-06, 1.6=
7e-05, 2.71e-05,
 4.283e-05, 7.26e-05, 9.82e-05, 0.0001186, 0.0001267, 0.00013, 0.000129, 9e-=
05, 9e-05, 7.3e-05,
 3.9e-05, 3.2e-05, 1.3e-05, 2e-06, 0, 0, 1e-05, 1e-05, 2e-05, 1e-05,
 2e-05, 2e-05, 2e-05, 1e-05, 2e-05, 2e-05, 2e-05, 1e-05, 1e-05, 2e-05,
 2e-05, 1e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05,
 2e-05, 2e-05, 1e-05, 2e-05, 1e-05, 1e-05, 2e-05, 1e-05, 1.488e-06, 2.01e-06=
,
 7.1e-06, 8.74e-06, 1.78e-05, 3.93e-05, 5.06e-05, 6.41e-05, 8.1e-05, 8.6e-05=
, 7.5e-05, 6.3e-05,
 4.9e-05, 3.7e-05, 2.8e-05, 1.3e-05, 3e-06, -3e-06, -6e-06, 0, 0, 0,
 0, 0, 0, 1e-05, 0, 0, 0, 1e-05, 0, 0,
 0, 0, 1e-05, 0, 1e-05, 0, 0, 0, 0, 0,
 0, 0, 0, 1e-05, 0, 0, 0, 0, 0, 0,
 7.205e-06, 1.031e-05, 1.198e-05, 1.646e-05, 2.37e-05, 3.37e-05, 4.23e-05, 5=
=2E11e-05, 5.85e-05, 6.5e-05,
 7.1e-05, 6.8e-05, 7.3e-05, 6.3e-05, 5.2e-05, 4.4e-05, 3.4e-05, 2.8e-05, 2.1=
e-05, 1e-05,
 2e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 2e-05, 1e-05, 2e-05, 1e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 1e-05, 1e-05, 1e-05, 2e-05, 1e-05, 1e-05, 1e-05, 1e-05,
 1e-05, 1e-05, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0.00114112, 0.00183203, 0.0028384, 0.00411961, 0.00545823, 0.00=
68933,
 0.0080243, 0.0084563, 0.0082241, 0.00707, 0.005066, 0.00244, -6.3e-05, -0.0=
02257, -0.003406, -0.003621,
 -0.003056, -0.002016, -0.000898, 0.0001, 0.00085, 0.00131, 0.00159, 0.00175=
, 0.00181, 0.00184,
 0.00186, 0.00185, 0.00186, 0.00186, 0.00186, 0.00186, 0.00185, 0.00186, 0.0=
0186, 0.00185,
 0.00186, 0.00186, 0.00186, 0.00186, 0.00186, 0.00186, 0.00186, 0.00186, 0.0=
0186, 0.00186,
 0.00186, 0.00186, 0.00185, 0.00185, 0.00186, 0.00185, 0.000864257, 0.001530=
09, 0.00230669, 0.0034254,
 0.0046051, 0.0059237, 0.0068139, 0.007228, 0.0068937, 0.005892, 0.004224, 0=
=2E001972, -6.8e-05, -0.00179,
 -0.002746, -0.003101, -0.002752, -0.001984, -0.001087, -0.0002, 0.0005, 0.0=
0098, 0.00128, 0.00145,
 0.00154, 0.00159, 0.00161, 0.00161, 0.00162, 0.00162, 0.00162, 0.00162, 0.0=
0161, 0.00162,
 0.00162, 0.00161, 0.00162, 0.00162, 0.00162, 0.00162, 0.00162, 0.00162, 0.0=
0162, 0.00162,
 0.00162, 0.00162, 0.00162, 0.00162, 0.00161, 0.00162, 0.00162, 0.00161, 0.0=
0108053, 0.00160072,
 0.00231114, 0.00327081, 0.0043866, 0.0052439, 0.00584, 0.0059159, 0.005507,=
 0.004648, 0.003134, 0.001369,
 -0.000176, -0.001546, -0.002413, -0.002622, -0.002305, -0.001752, -0.001005=
, -0.00032, 0.00031, 0.00077,
 0.00101, 0.00119, 0.00129, 0.00132, 0.00134, 0.00136, 0.00136, 0.00136, 0.0=
0136, 0.00136,
 0.00135, 0.00136, 0.00136, 0.00135, 0.00136, 0.00136, 0.00136, 0.00136, 0.0=
0136, 0.00136,
 0.00136, 0.00136, 0.00136, 0.00136, 0.00136, 0.00136, 0.00135, 0.00136, 0.0=
0136, 0.00135,
 0.0012903, 0.00193114, 0.00275003, 0.0036308, 0.0043842, 0.0050413, 0.00543=
88, 0.0054507, 0.005149, 0.004478,
 0.003233, 0.001739, 0.000485, -0.000502, -0.001149, -0.001455, -0.001321, -=
0.000928, -0.00036, 0.00021,
 0.00069, 0.00106, 0.00133, 0.00149, 0.00161, 0.00166, 0.0017, 0.00172, 0.00=
172, 0.00172,
 0.00173, 0.00173, 0.00172, 0.00173, 0.00173, 0.00172, 0.00173, 0.00173, 0.0=
0173, 0.00173,
 0.00173, 0.00173, 0.00173, 0.00173, 0.00173, 0.00173, 0.00173, 0.00173, 0.0=
0172, 0.00173,
 0.00173, 0.00172, 0.00118876, 0.00164741, 0.0022564, 0.0029146, 0.0036516, =
0.004204, 0.0045069, 0.004527,
 0.004283, 0.003684, 0.002767, 0.00175, 0.000853, -2.7e-05, -0.000631, -0.00=
079, -0.000708, -0.00042,
 3.2e-05, 0.00043, 0.00084, 0.0012, 0.00147, 0.00163, 0.00172, 0.00177, 0.00=
179, 0.00181,
 0.00182, 0.00182, 0.00183, 0.00183, 0.00182, 0.00183, 0.00183, 0.00182, 0.0=
0183, 0.00183,
 0.00183, 0.00183, 0.00183, 0.00183, 0.00183, 0.00183, 0.00183, 0.00183, 0.0=
0183, 0.00183,
 0.00182, 0.00183, 0.00183, 0.00182, 0.00103091, 0.00137247, 0.001853, 0.002=
4275, 0.0029466, 0.0034207,
 0.0036099, 0.0036062, 0.003347, 0.002842, 0.002151, 0.001338, 0.000571, -7.=
3e-05, -0.000475, -0.000686,
 -0.0006, -0.000349, 1e-06, 0.00037, 0.00072, 0.00096, 0.00113, 0.00127, 0.0=
0136, 0.0014,
 0.00144, 0.00146, 0.00146, 0.00147, 0.00147, 0.00147, 0.00147, 0.00147, 0.0=
0147, 0.00147,
 0.00148, 0.00147, 0.00147, 0.00148, 0.00147, 0.00148, 0.00147, 0.00147, 0.0=
0148, 0.00148,
 0.00147, 0.00147, 0.00147, 0.00147, 0.00147, 0.00147, 0.00112898, 0.0015144=
8, 0.0020701, 0.0025562,
 0.0030464, 0.0034075, 0.0034517, 0.003483, 0.003143, 0.002798, 0.002248, 0.=
001658, 0.001076, 0.00055,
 0.000137, -4.9e-05, -5.8e-05, 4.6e-05, 0.000265, 0.00052, 0.00082, 0.00107,=
 0.00124, 0.00136,
 0.00143, 0.00151, 0.00155, 0.00156, 0.00158, 0.00158, 0.00159, 0.00159, 0.0=
0158, 0.00159,
 0.00158, 0.00158, 0.00159, 0.00159, 0.00159, 0.00159, 0.00159, 0.00159, 0.0=
0159, 0.00159,
 0.00159, 0.00159, 0.00159, 0.00159, 0.00158, 0.00159, 0.00159, 0.00158, 0.0=
0105398, 0.00142823,
 0.0017223, 0.0020679, 0.0023772, 0.0026005, 0.0027139, 0.002579, 0.002411, =
0.002164, 0.001828, 0.00135,
 0.000896, 0.000577, 0.000205, 4.2e-05, 3.6e-05, 0.00013, 0.000223, 0.00038,=
 0.00056, 0.00073,
 0.00089, 0.00096, 0.00103, 0.00109, 0.00113, 0.00115, 0.00117, 0.00117, 0.0=
0118, 0.00118,
 0.00118, 0.00118, 0.00118, 0.00118, 0.00119, 0.00118, 0.00118, 0.00119, 0.0=
0118, 0.00119,
 0.00118, 0.00118, 0.00119, 0.00119, 0.00118, 0.00118, 0.00118, 0.00118, 0.0=
0118, 0.00118,
 0.00108579, 0.0013636, 0.0016082, 0.0019108, 0.0021813, 0.0023201, 0.002437=
3, 0.002309, 0.002186, 0.002028,
 0.001753, 0.001432, 0.001042, 0.000721, 0.00048, 0.000351, 0.00026, 0.00024=
8, 0.000342, 0.00049,
 0.00063, 0.00078, 0.00088, 0.00095, 0.00101, 0.00105, 0.00107, 0.00109, 0.0=
011, 0.00111,
 0.00111, 0.00112, 0.00112, 0.00112, 0.00112, 0.00112, 0.00112, 0.00112, 0.0=
0112, 0.00113,
 0.00112, 0.00112, 0.00112, 0.00112, 0.00113, 0.00113, 0.00112, 0.00112, 0.0=
0112, 0.00112,
 0.00112, 0.00112, 0.00078885, 0.0009539, 0.0011929, 0.0014091, 0.0016128, 0=
=2E0016418, 0.001662, 0.001645,
 0.001584, 0.001432, 0.001189, 0.000958, 0.00074, 0.00053, 0.000328, 0.00022=
3, 0.000242, 0.000252,
 0.000297, 0.00038, 0.00051, 0.0006, 0.00069, 0.00074, 0.00079, 0.00083, 0.0=
0087, 0.00088,
 0.0009, 0.00091, 0.00091, 0.00092, 0.00092, 0.00092, 0.00092, 0.00092, 0.00=
092, 0.00092,
 0.00092, 0.00093, 0.00092, 0.00092, 0.00092, 0.00092, 0.00093, 0.00093, 0.0=
0092, 0.00092,
 0.00092, 0.00092, 0.00092, 0.00092, 0.0005187, 0.0006498, 0.0007765, 0.0008=
08, 0.0008421, 0.0009013,
 0.000946, 0.000965, 0.00092, 0.000827, 0.000669, 0.00059, 0.00047, 0.000334=
, 0.000205, 0.000133,
 0.000127, 0.000108, 0.000155, 0.00021, 0.00027, 0.00033, 0.00039, 0.00042, =
0.00046, 0.0005,
 0.0005, 0.00052, 0.00054, 0.00055, 0.00056, 0.00055, 0.00056, 0.00056, 0.00=
055, 0.00055,
 0.00055, 0.00056, 0.00056, 0.00056, 0.00056, 0.00056, 0.00056, 0.00056, 0.0=
0056, 0.00056,
 0.00056, 0.00056, 0.00055, 0.00056, 0.00056, 0.00055, 0.0003522, 0.0004384,=
 0.0005196, 0.0006014,
 0.000683, 0.0007169, 0.000702, 0.000692, 0.000706, 0.000631, 0.000439, 0.00=
0271, 0.000153, 3.1e-05,
 -6.8e-05, -8.9e-05, -0.000135, -0.000157, -0.000165, -0.00013, -0.00012, -6=
e-05, -2e-05, 0,
 2e-05, 4e-05, 6e-05, 8e-05, 8e-05, 8e-05, 0.0001, 9e-05, 9e-05, 9e-05,
 9e-05, 9e-05, 9e-05, 9e-05, 0.0001, 0.0001, 9e-05, 0.0001, 9e-05, 9e-05,
 0.0001, 0.0001, 9e-05, 0.0001, 9e-05, 9e-05, 9e-05, 9e-05, 0.000459, 0.0004=
973,
 0.0006233, 0.0006627, 0.0007325, 0.0008054, 0.000805, 0.000794, 0.000803, 0=
=2E000761, 0.000711, 0.000667,
 0.000582, 0.000501, 0.000438, 0.00042, 0.000423, 0.000409, 0.000421, 0.0004=
4, 0.00046, 0.00048,
 0.0005, 0.00051, 0.00052, 0.00054, 0.00054, 0.00055, 0.00056, 0.00057, 0.00=
057, 0.00057,
 0.00057, 0.00057, 0.00057, 0.00057, 0.00057, 0.00057, 0.00057, 0.00058, 0.0=
0057, 0.00057,
 0.00057, 0.00057, 0.00058, 0.00058, 0.00057, 0.00057, 0.00057, 0.00057, 0.0=
0057, 0.00057,
 0.0001544, 0.000214, 0.0002788, 0.0002924, 0.0003695, 0.000365, 0.000401, 0=
=2E00039, 0.000415, 0.000358,
 0.000319, 0.000295, 0.000255, 0.000225, 0.000171, 0.00014, 0.000126, 0.0001=
11, 0.000113, 0.00011,
 0.00012, 0.00013, 0.00013, 0.00014, 0.00014, 0.00015, 0.00015, 0.00016, 0.0=
0017, 0.00017,
 0.00017, 0.00017, 0.00017, 0.00017, 0.00017, 0.00017, 0.00017, 0.00017, 0.0=
0017, 0.00017,
 0.00017, 0.00017, 0.00017, 0.00017, 0.00017, 0.00017, 0.00017, 0.00017, 0.0=
0016, 0.00017,
 0.00017, 0.00016, 8.5e-05, 0.0001039, 0.0001231, 0.000177, 0.0001789, 0.000=
148, 0.00016, 0.00015,
 0.000133, 0.000111, 9.7e-05, 0.000114, 8.5e-05, 5.6e-05, 2.4e-05, -7e-06, -=
1.2e-05, -1.6e-05,
 -2.6e-05, -3e-05, -3e-05, -3e-05, -2e-05, -2e-05, -1e-05, -1e-05, 0, 0,
 -1e-05, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 5.21e-05, 6.73e-05, 6.84e-05, 7.53e-05, 9.2e-05, 0.000114,
 0.000113, 0.000114, 0.000109, 0.000107, 0.000108, 0.000108, 0.000103, 8.2e-=
05, 6.7e-05, 5.9e-05,
 4.9e-05, 4.2e-05, 4.5e-05, 3e-05, 3e-05, 2e-05, 2e-05, 3e-05, 2e-05, 2e-05,
 2e-05, 1e-05, 1e-05, 2e-05, 1e-05, 2e-05, 1e-05, 2e-05, 1e-05, 1e-05,
 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 2e-05, 1e-05, 1e-05, 2e-05, 2e-05,
 1e-05, 2e-05, 1e-05, 1e-05, 1e-05, 1e-05, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0.0149781, 0.0171052,
 0.0189799, 0.0201907, 0.0208683, 0.020608, 0.019274, 0.017134, 0.014279, 0.=
010651, 0.006546, 0.00238,
 -0.001571, -0.004852, -0.007337, -0.008928, -0.009614, -0.009423, -0.008391=
, -0.00687, -0.00501, -0.003,
 -0.00106, 0.00055, 0.00188, 0.00287, 0.00354, 0.004, 0.00428, 0.00445, 0.00=
455, 0.0046,
 0.00463, 0.00463, 0.00464, 0.00464, 0.00464, 0.00465, 0.00465, 0.00465, 0.0=
0465, 0.00465,
 0.00464, 0.00464, 0.00465, 0.00465, 0.00464, 0.00465, 0.00464, 0.00464, 0.0=
0464, 0.00464,
 0.0151719, 0.0166557, 0.0182388, 0.0189943, 0.0196134, 0.019403, 0.018086, =
0.016135, 0.013304, 0.01035,
 0.007331, 0.004269, 0.001278, -0.001355, -0.003126, -0.00438, -0.004927, -0=
=2E00474, -0.003989, -0.00294,
 -0.00161, -0.00021, 0.00113, 0.00242, 0.00357, 0.00446, 0.00511, 0.00559, 0=
=2E00592, 0.00616,
 0.00631, 0.00639, 0.00644, 0.00647, 0.00648, 0.00649, 0.00649, 0.00649, 0.0=
0649, 0.00649,
 0.00649, 0.00649, 0.00649, 0.00649, 0.00649, 0.0065, 0.00649, 0.00649, 0.00=
649, 0.00649,
 0.00649, 0.00649, 0.0127392, 0.0139291, 0.0148999, 0.0157236, 0.015968, 0.0=
15482, 0.014194, 0.012447,
 0.010341, 0.007854, 0.005056, 0.002396, 2.3e-05, -0.002153, -0.003603, -0.0=
04644, -0.005142, -0.004961,
 -0.004209, -0.00326, -0.00219, -0.00109, 2e-05, 0.00113, 0.00211, 0.00287, =
0.00343, 0.00386,
 0.00418, 0.00441, 0.00458, 0.00468, 0.00473, 0.00477, 0.0048, 0.00482, 0.00=
483, 0.00483,
 0.00483, 0.00484, 0.00483, 0.00484, 0.00483, 0.00483, 0.00484, 0.00484, 0.0=
0483, 0.00484,
 0.00483, 0.00483, 0.00483, 0.00483, 0.0129879, 0.0140697, 0.014837, 0.01531=
12, 0.015229, 0.014725,
 0.013767, 0.01238, 0.010644, 0.008679, 0.006632, 0.004745, 0.002787, 0.0011=
11, -0.000118, -0.000936,
 -0.00121, -0.001124, -0.00076, -0.00028, 0.00054, 0.00148, 0.00243, 0.00328=
, 0.00405, 0.00466,
 0.00516, 0.00556, 0.00588, 0.00608, 0.00621, 0.00632, 0.0064, 0.00645, 0.00=
649, 0.0065,
 0.00652, 0.00652, 0.00652, 0.00652, 0.00653, 0.00653, 0.00652, 0.00652, 0.0=
0653, 0.00653,
 0.00652, 0.00653, 0.00652, 0.00652, 0.00652, 0.00652, 0.0104318, 0.0113747,=
 0.0121022, 0.012556,
 0.01255, 0.012104, 0.011327, 0.010048, 0.008552, 0.00692, 0.005351, 0.00389=
2, 0.002371, 0.001138,
 0.000146, -0.000355, -0.000633, -0.000603, -0.00039, 6e-05, 0.00068, 0.0013=
7, 0.00203, 0.00271,
 0.00332, 0.00389, 0.00437, 0.00472, 0.00499, 0.00518, 0.00531, 0.0054, 0.00=
547, 0.00552,
 0.00556, 0.00557, 0.00559, 0.0056, 0.0056, 0.0056, 0.00561, 0.00561, 0.0056=
, 0.0056,
 0.00561, 0.00561, 0.0056, 0.00561, 0.0056, 0.0056, 0.0056, 0.0056, 0.010675=
6, 0.0113237,
 0.0114696, 0.011441, 0.011198, 0.010872, 0.010105, 0.009087, 0.008242, 0.00=
6926, 0.005561, 0.004276,
 0.003229, 0.002275, 0.001528, 0.001055, 0.000824, 0.000698, 0.00075, 0.0011=
1, 0.00154, 0.00203,
 0.0025, 0.00301, 0.00349, 0.00393, 0.00431, 0.00464, 0.00493, 0.00514, 0.00=
528, 0.00538,
 0.00546, 0.00551, 0.00554, 0.00557, 0.00559, 0.0056, 0.0056, 0.00561, 0.005=
62, 0.00562,
 0.00562, 0.00562, 0.00562, 0.00562, 0.00562, 0.00562, 0.00561, 0.00562, 0.0=
0562, 0.00561,
 0.0068478, 0.0070616, 0.007291, 0.007268, 0.006874, 0.006538, 0.006069, 0.0=
05219, 0.004371, 0.003387,
 0.002346, 0.001211, 0.000248, -0.000583, -0.001183, -0.00157, -0.001727, -0=
=2E00176, -0.00156, -0.00134,
 -0.00107, -0.00067, -0.00017, 0.00024, 0.00067, 0.00102, 0.00131, 0.00153, =
0.00173, 0.0019,
 0.00203, 0.00215, 0.00223, 0.00228, 0.00232, 0.00235, 0.00236, 0.00238, 0.0=
0238, 0.00239,
 0.00239, 0.00239, 0.00239, 0.00239, 0.0024, 0.00239, 0.00239, 0.00239, 0.00=
239, 0.00239,
 0.00239, 0.00239, 0.0058904, 0.006647, 0.007166, 0.007243, 0.007258, 0.0067=
33, 0.006027, 0.005407,
 0.004784, 0.004026, 0.003359, 0.002686, 0.002133, 0.001714, 0.00137, 0.0011=
38, 0.000951, 0.000845,
 0.00087, 0.00105, 0.00129, 0.00157, 0.00192, 0.00222, 0.0025, 0.00277, 0.00=
298, 0.00319,
 0.00338, 0.00354, 0.00367, 0.00376, 0.00382, 0.00388, 0.00391, 0.00394, 0.0=
0396, 0.00398,
 0.00399, 0.00399, 0.004, 0.004, 0.00401, 0.00401, 0.00401, 0.004, 0.004, 0.=
00401,
 0.004, 0.004, 0.00401, 0.004, 0.0056161, 0.00564, 0.005671, 0.005721, 0.005=
497, 0.005303,
 0.00508, 0.004691, 0.004181, 0.003514, 0.002934, 0.002463, 0.002059, 0.0015=
87, 0.001218, 0.001055,
 0.000944, 0.000972, 0.00096, 0.001, 0.00121, 0.00145, 0.00173, 0.00195, 0.0=
0213, 0.00233,
 0.00252, 0.00266, 0.00281, 0.00291, 0.003, 0.00307, 0.00313, 0.00318, 0.003=
21, 0.00324,
 0.00325, 0.00327, 0.00328, 0.00329, 0.0033, 0.00329, 0.0033, 0.0033, 0.0033=
, 0.0033,
 0.0033, 0.0033, 0.0033, 0.0033, 0.0033, 0.0033, 0.003688, 0.003553, 0.00360=
5, 0.00363,
 0.003439, 0.003266, 0.00301, 0.002764, 0.002392, 0.002036, 0.001715, 0.0014=
79, 0.00117, 0.000867,
 0.000635, 0.000389, 0.000243, 0.00011, 0.00016, 0.0002, 0.00032, 0.00043, 0=
=2E00058, 0.00073,
 0.00086, 0.00103, 0.00118, 0.00131, 0.00141, 0.00149, 0.00156, 0.00163, 0.0=
017, 0.00173,
 0.00176, 0.00179, 0.00181, 0.00183, 0.00184, 0.00185, 0.00185, 0.00186, 0.0=
0186, 0.00186,
 0.00186, 0.00186, 0.00186, 0.00186, 0.00186, 0.00186, 0.00186, 0.00186, 0.0=
02635, 0.002794,
 0.002866, 0.002833, 0.002653, 0.002462, 0.002315, 0.002123, 0.00187, 0.0016=
31, 0.00144, 0.001211,
 0.001034, 0.000897, 0.000719, 0.000547, 0.000444, 0.00036, 0.00038, 0.00047=
, 0.00049, 0.00053,
 0.00062, 0.00072, 0.0008, 0.0009, 0.00098, 0.00108, 0.00116, 0.00123, 0.001=
3, 0.00134,
 0.00138, 0.00141, 0.00144, 0.00146, 0.00147, 0.00148, 0.00149, 0.00151, 0.0=
015, 0.0015,
 0.00151, 0.00151, 0.00151, 0.00151, 0.00151, 0.00152, 0.00151, 0.00151, 0.0=
0151, 0.00151,
 0.002674, 0.002709, 0.002688, 0.002614, 0.002485, 0.002392, 0.002374, 0.002=
342, 0.002327, 0.002244,
 0.002136, 0.001961, 0.001803, 0.001664, 0.001535, 0.001503, 0.001468, 0.001=
41, 0.00138, 0.00135,
 0.00139, 0.00144, 0.00147, 0.00152, 0.00156, 0.00164, 0.0017, 0.00173, 0.00=
178, 0.00183,
 0.00187, 0.00189, 0.00192, 0.00194, 0.00196, 0.00198, 0.00199, 0.002, 0.002=
, 0.002,
 0.002, 0.00201, 0.00201, 0.00201, 0.00201, 0.00202, 0.00202, 0.00202, 0.002=
01, 0.00202,
 0.00202, 0.00201, 0.001843, 0.001877, 0.001966, 0.001908, 0.001874, 0.00185=
6, 0.001741, 0.001644,
 0.001465, 0.001379, 0.001279, 0.001227, 0.001137, 0.001049, 0.000984, 0.001=
011, 0.001, 0.00094,
 0.00092, 0.00093, 0.00096, 0.00101, 0.00107, 0.00111, 0.00115, 0.00119, 0.0=
0123, 0.00126,
 0.00132, 0.00134, 0.00137, 0.00138, 0.00141, 0.00142, 0.00143, 0.00144, 0.0=
0145, 0.00145,
 0.00146, 0.00146, 0.00147, 0.00147, 0.00146, 0.00147, 0.00147, 0.00146, 0.0=
0146, 0.00146,
 0.00147, 0.00147, 0.00147, 0.00146, 0.000876, 0.000875, 0.000939, 0.000846,=
 0.000819, 0.000798,
 0.000848, 0.000819, 0.000825, 0.000806, 0.000713, 0.000695, 0.000639, 0.000=
492, 0.000419, 0.000397,
 0.000357, 0.00032, 0.00032, 0.00033, 0.00035, 0.00032, 0.00031, 0.00033, 0.=
00033, 0.00034,
 0.00035, 0.00036, 0.00039, 0.00039, 0.0004, 0.00042, 0.00043, 0.00044, 0.00=
045, 0.00045,
 0.00046, 0.00047, 0.00047, 0.00048, 0.00047, 0.00048, 0.00048, 0.00048, 0.0=
0049, 0.00049,
 0.00048, 0.00048, 0.00048, 0.00048, 0.00048, 0.00048, 0.000552, 0.000506, 0=
=2E000611, 0.00053,
 0.000524, 0.000558, 0.000489, 0.000398, 0.000358, 0.000337, 0.000243, 0.000=
151, 0.000119, 0.000103,
 9.2e-05, 8.5e-05, 0.0001, 0.0001, 0.00012, 0.00011, 0.0001, 0.00012, 0.0001=
3, 0.00013,
 0.00012, 0.00013, 0.00014, 0.00013, 0.00013, 0.00013, 0.00013, 0.00014, 0.0=
0015, 0.00015,
 0.00015, 0.00015, 0.00015, 0.00015, 0.00015, 0.00015, 0.00015, 0.00015, 0.0=
0015, 0.00016,
 0.00016, 0.00015, 0.00015, 0.00016, 0.00016, 0.00016, 0.00016, 0.00015, 0.0=
0012, 0.000137,
 0.000178, 0.000184, 0.000154, 0.000146, 0.000134, 0.000103, 0.000119, 0.000=
102, 9.9e-05, 8.1e-05,
 5.8e-05, 4.9e-05, 2.2e-05, 1e-05, 0, -1e-05, -1e-05, -3e-05, -4e-05, -5e-05=
,
 -4e-05, -5e-05, -5e-05, -6e-05, -6e-05, -6e-05, -6e-05, -6e-05, -5e-05, -6e=
-05,
 -6e-05, -7e-05, -7e-05, -7e-05, -7e-05, -7e-05, -6e-05, -6e-05, -6e-05, -6e=
-05,
 -6e-05, -6e-05, -6e-05, -6e-05, -6e-05, -6e-05, -6e-05, -7e-05, -6e-05, -6e=
-05,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0.074312, 0.072543, 0.070089, 0.066706, 0.062708, 0.057771, 0.051853,=
 0.045922,
 0.039761, 0.033724, 0.027904, 0.022124, 0.016703, 0.012149, 0.008353, 0.005=
335, 0.003579, 0.00264,
 0.00255, 0.00324, 0.00465, 0.00674, 0.00936, 0.01221, 0.0152, 0.01825, 0.02=
121, 0.02399,
 0.02645, 0.02855, 0.03025, 0.03161, 0.0327, 0.03356, 0.03421, 0.03469, 0.03=
506, 0.03531,
 0.03548, 0.03559, 0.03567, 0.03571, 0.03575, 0.03577, 0.03579, 0.03579, 0.0=
358, 0.0358,
 0.03581, 0.03581, 0.03581, 0.0358, 0.048533, 0.047034, 0.044826, 0.04185, 0=
=2E038165, 0.033753,
 0.029005, 0.024044, 0.019152, 0.014325, 0.009535, 0.005282, 0.001432, -0.00=
2034, -0.004957, -0.007107,
 -0.00842, -0.00899, -0.00891, -0.0082, -0.007, -0.00531, -0.00331, -0.00113=
, 0.00122, 0.00357,
 0.00585, 0.00796, 0.00986, 0.01156, 0.01304, 0.01429, 0.01536, 0.01622, 0.0=
1691, 0.01745,
 0.01785, 0.01815, 0.01837, 0.01853, 0.01864, 0.01872, 0.01878, 0.01881, 0.0=
1883, 0.01885,
 0.01886, 0.01886, 0.01887, 0.01888, 0.01888, 0.01887, 0.043765, 0.041706, 0=
=2E039309, 0.036543,
 0.033206, 0.029486, 0.025931, 0.022054, 0.018183, 0.014195, 0.010331, 0.006=
685, 0.003622, 0.000836,
 -0.001621, -0.003637, -0.00507, -0.00558, -0.00558, -0.00502, -0.004, -0.00=
264, -0.00107, 0.00056,
 0.00229, 0.0041, 0.00593, 0.00774, 0.00943, 0.01096, 0.01225, 0.01338, 0.01=
435, 0.01513,
 0.01577, 0.01627, 0.01665, 0.01696, 0.01719, 0.01738, 0.01752, 0.01762, 0.0=
177, 0.01776,
 0.0178, 0.01782, 0.01784, 0.01786, 0.01787, 0.01787, 0.01787, 0.01788, 0.04=
0546, 0.039069,
 0.037211, 0.034906, 0.032503, 0.029581, 0.026509, 0.023381, 0.020256, 0.017=
052, 0.013926, 0.011163,
 0.008685, 0.006608, 0.005159, 0.004056, 0.00323, 0.00275, 0.00262, 0.00284,=
 0.00341, 0.00438,
 0.00558, 0.00696, 0.00844, 0.00988, 0.01129, 0.01264, 0.01394, 0.01517, 0.0=
1624, 0.01718,
 0.018, 0.01869, 0.01926, 0.01971, 0.02009, 0.02041, 0.02066, 0.02085, 0.021=
, 0.02111,
 0.02121, 0.02128, 0.02133, 0.02138, 0.0214, 0.02142, 0.02143, 0.02144, 0.02=
145, 0.02146,
 0.03575, 0.034097, 0.03252, 0.030698, 0.028431, 0.026095, 0.023894, 0.02172=
1, 0.019588, 0.017328,
 0.014969, 0.012923, 0.011103, 0.009624, 0.008161, 0.00708, 0.00627, 0.00585=
, 0.00591, 0.00615,
 0.00657, 0.00718, 0.00801, 0.00898, 0.00997, 0.01105, 0.01208, 0.01311, 0.0=
1404, 0.01493,
 0.01575, 0.01654, 0.01724, 0.01785, 0.01837, 0.01882, 0.01917, 0.01946, 0.0=
1969, 0.01989,
 0.02004, 0.02018, 0.02026, 0.02034, 0.02039, 0.02043, 0.02046, 0.02048, 0.0=
2049, 0.02051,
 0.02052, 0.02052, 0.027, 0.025886, 0.024357, 0.022695, 0.020903, 0.019108, =
0.017201, 0.015599,
 0.013953, 0.012211, 0.010409, 0.008664, 0.007273, 0.006035, 0.005187, 0.004=
51, 0.00403, 0.00373,
 0.0037, 0.00394, 0.00426, 0.00476, 0.00537, 0.00606, 0.00684, 0.00764, 0.00=
844, 0.0092,
 0.00995, 0.01069, 0.01138, 0.012, 0.01256, 0.01305, 0.01349, 0.01388, 0.014=
22, 0.0145,
 0.01475, 0.01494, 0.01509, 0.01521, 0.01531, 0.01539, 0.01544, 0.01548, 0.0=
1552, 0.01554,
 0.01555, 0.01557, 0.01558, 0.01559, 0.021207, 0.02019, 0.018896, 0.017647, =
0.016399, 0.015223,
 0.013774, 0.012133, 0.010693, 0.00951, 0.008479, 0.007389, 0.006413, 0.0056=
27, 0.00495, 0.00441,
 0.00426, 0.00421, 0.00428, 0.00435, 0.00457, 0.00484, 0.00518, 0.00564, 0.0=
0621, 0.00683,
 0.00753, 0.00818, 0.0088, 0.00937, 0.00993, 0.01047, 0.01098, 0.01144, 0.01=
184, 0.01217,
 0.01245, 0.01268, 0.01287, 0.01303, 0.01316, 0.01327, 0.01336, 0.01343, 0.0=
1349, 0.01353,
 0.01357, 0.0136, 0.01362, 0.01364, 0.01365, 0.01366, 0.016562, 0.015934, 0.=
014883, 0.01365,
 0.012607, 0.011504, 0.010582, 0.00972, 0.008929, 0.008042, 0.007163, 0.0063=
39, 0.00568, 0.005196,
 0.00484, 0.00457, 0.00455, 0.00455, 0.00465, 0.00472, 0.00479, 0.00495, 0.0=
0517, 0.0055,
 0.00584, 0.00626, 0.00665, 0.00708, 0.0075, 0.00796, 0.00838, 0.00877, 0.00=
915, 0.00949,
 0.00979, 0.01006, 0.0103, 0.0105, 0.01065, 0.01079, 0.01091, 0.01101, 0.011=
1, 0.01118,
 0.01124, 0.01129, 0.01133, 0.01136, 0.01138, 0.0114, 0.01142, 0.01143, 0.01=
4826, 0.013965,
 0.013372, 0.012759, 0.012072, 0.011481, 0.010928, 0.010252, 0.009693, 0.008=
94, 0.00842, 0.007935,
 0.007473, 0.006993, 0.00657, 0.00623, 0.00604, 0.00592, 0.00602, 0.00622, 0=
=2E00645, 0.0067,
 0.00698, 0.00725, 0.00753, 0.00788, 0.0083, 0.0087, 0.00901, 0.00933, 0.009=
65, 0.00994,
 0.01022, 0.01046, 0.01067, 0.01089, 0.01108, 0.01125, 0.01139, 0.01151, 0.0=
1161, 0.01168,
 0.01175, 0.01182, 0.01186, 0.0119, 0.01194, 0.01196, 0.01198, 0.012, 0.0120=
1, 0.01203,
 0.014295, 0.014235, 0.014029, 0.013656, 0.013011, 0.012611, 0.0121, 0.01150=
4, 0.010944, 0.01051,
 0.010018, 0.009643, 0.009218, 0.00903, 0.00883, 0.00856, 0.00837, 0.00834, =
0.00834, 0.00846,
 0.00856, 0.00868, 0.00883, 0.00903, 0.00926, 0.00953, 0.00978, 0.01005, 0.0=
1027, 0.0105,
 0.01072, 0.0109, 0.01107, 0.01123, 0.01138, 0.01156, 0.01171, 0.01184, 0.01=
195, 0.01203,
 0.0121, 0.01216, 0.01222, 0.01228, 0.01232, 0.01235, 0.01238, 0.01241, 0.01=
242, 0.01244,
 0.01245, 0.01247, 0.009542, 0.00919, 0.009036, 0.008818, 0.008494, 0.008285=
, 0.008022, 0.007572,
 0.007029, 0.006718, 0.006482, 0.006322, 0.00608, 0.00603, 0.00593, 0.00589,=
 0.00586, 0.00583,
 0.00575, 0.0057, 0.00576, 0.00588, 0.00599, 0.00608, 0.00622, 0.00639, 0.00=
652, 0.00668,
 0.00684, 0.007, 0.00718, 0.00735, 0.0075, 0.00764, 0.00775, 0.00787, 0.0079=
7, 0.00807,
 0.00815, 0.00823, 0.0083, 0.00835, 0.00841, 0.00845, 0.00848, 0.00852, 0.00=
855, 0.00857,
 0.00859, 0.00859, 0.00862, 0.00862, 0.009349, 0.009163, 0.008838, 0.008431,=
 0.008463, 0.008325,
 0.008133, 0.007769, 0.007518, 0.007253, 0.007014, 0.006921, 0.00672, 0.0066=
, 0.00646, 0.00644,
 0.00654, 0.00655, 0.00654, 0.00648, 0.00649, 0.00652, 0.00659, 0.00659, 0.0=
0663, 0.00672,
 0.00686, 0.00696, 0.00707, 0.00717, 0.00724, 0.00732, 0.0074, 0.00749, 0.00=
758, 0.00766,
 0.00773, 0.00779, 0.00784, 0.00789, 0.00793, 0.00797, 0.00801, 0.00803, 0.0=
0806, 0.00808,
 0.00809, 0.00811, 0.00812, 0.00814, 0.00815, 0.00815, 0.01617, 0.016262, 0.=
01599, 0.015695,
 0.01537, 0.015093, 0.015035, 0.014991, 0.014831, 0.014825, 0.014739, 0.0145=
9, 0.01458, 0.0145,
 0.01438, 0.01433, 0.01438, 0.0144, 0.01448, 0.01449, 0.01448, 0.01448, 0.01=
452, 0.01451,
 0.01455, 0.01462, 0.01466, 0.01472, 0.01477, 0.01482, 0.01486, 0.01492, 0.0=
1499, 0.01506,
 0.01513, 0.01516, 0.0152, 0.01525, 0.01528, 0.01531, 0.01533, 0.01535, 0.01=
536, 0.01539,
 0.01541, 0.01542, 0.01544, 0.01544, 0.01546, 0.01546, 0.01547, 0.01547, 0.0=
06327, 0.006345,
 0.006276, 0.006255, 0.006237, 0.00601, 0.005757, 0.005627, 0.005483, 0.0055=
18, 0.005467, 0.00536,
 0.00533, 0.0053, 0.00529, 0.00535, 0.00533, 0.00524, 0.00519, 0.00526, 0.00=
53, 0.00532,
 0.00531, 0.0053, 0.00533, 0.00536, 0.00541, 0.00545, 0.0055, 0.00551, 0.005=
53, 0.00555,
 0.00557, 0.0056, 0.00563, 0.00566, 0.00569, 0.00571, 0.00572, 0.00574, 0.00=
575, 0.00576,
 0.00576, 0.00577, 0.00577, 0.00578, 0.00579, 0.0058, 0.0058, 0.0058, 0.0058=
1, 0.00581,
 0.000946, 0.000893, 0.000843, 0.000791, 0.000678, 0.000677, 0.000639, 0.000=
561, 0.000569, 0.000555,
 0.00054, 0.00056, 0.00054, 0.00052, 0.00051, 0.0005, 0.00049, 0.00047, 0.00=
044, 0.00041,
 0.00041, 0.00038, 0.00039, 0.00038, 0.00037, 0.00038, 0.00038, 0.00039, 0.0=
0041, 0.00042,
 0.00041, 0.00043, 0.00043, 0.00044, 0.00045, 0.00046, 0.00047, 0.00047, 0.0=
0048, 0.00049,
 0.00049, 0.00048, 0.00049, 0.0005, 0.0005, 0.00051, 0.00051, 0.00051, 0.000=
51, 0.00052,
 0.00052, 0.00053, 0.000529, 0.000535, 0.000477, 0.000567, 0.000609, 0.00059=
9, 0.000573, 0.000652,
 0.000642, 0.00059, 0.00057, 0.00058, 0.00054, 0.00051, 0.00049, 0.0005, 0.0=
0047, 0.00046,
 0.00045, 0.00042, 0.00042, 0.00042, 0.00039, 0.0004, 0.0004, 0.00039, 0.000=
37, 0.00037,
 0.00037, 0.00036, 0.00035, 0.00035, 0.00035, 0.00035, 0.00035, 0.00035, 0.0=
0034, 0.00034,
 0.00035, 0.00034, 0.00034, 0.00035, 0.00035, 0.00034, 0.00034, 0.00034, 0.0=
0035, 0.00035,
 0.00035, 0.00035, 0.00035, 0.00035, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0.164644, 0.156851, 0.148706, 0.14044,
 0.132306, 0.124277, 0.116262, 0.108361, 0.100781, 0.093736, 0.087138, 0.081=
24, 0.07602, 0.07152,
 0.06776, 0.06469, 0.06232, 0.06063, 0.0598, 0.05979, 0.06052, 0.06202, 0.06=
418, 0.06693,
 0.07024, 0.07395, 0.07797, 0.08217, 0.08653, 0.09095, 0.09533, 0.09958, 0.1=
0366, 0.10753,
 0.11111, 0.11436, 0.11727, 0.11983, 0.12207, 0.12399, 0.12562, 0.12699, 0.1=
2812, 0.12905,
 0.1298, 0.1304, 0.1309, 0.13129, 0.1316, 0.13185, 0.13203, 0.13218, 0.12212=
9, 0.115747,
 0.109285, 0.10272, 0.096036, 0.089265, 0.082605, 0.076171, 0.0703, 0.064984=
, 0.05991, 0.05542,
 0.05155, 0.04815, 0.04533, 0.0432, 0.04176, 0.04092, 0.04074, 0.04122, 0.04=
217, 0.04359,
 0.04547, 0.04792, 0.05074, 0.05383, 0.0571, 0.06052, 0.06399, 0.0675, 0.070=
94, 0.07423,
 0.07739, 0.08035, 0.08309, 0.08562, 0.08796, 0.09006, 0.09191, 0.09354, 0.0=
9496, 0.09618,
 0.09722, 0.09811, 0.09887, 0.09948, 0.1, 0.10041, 0.10075, 0.10102, 0.10125=
, 0.10142,
 0.153725, 0.148001, 0.142308, 0.13681, 0.131508, 0.126449, 0.121801, 0.1173=
99, 0.113091, 0.10913,
 0.10555, 0.1024, 0.0998, 0.0975, 0.09544, 0.09392, 0.0929, 0.09235, 0.09226=
, 0.0927,
 0.09366, 0.09507, 0.09673, 0.09859, 0.10068, 0.10293, 0.10526, 0.10769, 0.1=
1018, 0.11269,
 0.11516, 0.11756, 0.11988, 0.12213, 0.12424, 0.12623, 0.12809, 0.12979, 0.1=
3135, 0.13275,
 0.134, 0.13511, 0.13611, 0.13698, 0.13774, 0.13839, 0.13894, 0.13941, 0.139=
81, 0.14015,
 0.14043, 0.14066, 0.134193, 0.129474, 0.124889, 0.120386, 0.115964, 0.11183=
8, 0.107949, 0.104442,
 0.10141, 0.09864, 0.09611, 0.0941, 0.09244, 0.09109, 0.0902, 0.08982, 0.089=
78, 0.08998,
 0.09052, 0.09135, 0.09242, 0.09371, 0.09516, 0.09674, 0.09846, 0.10033, 0.1=
0228, 0.10427,
 0.10622, 0.10812, 0.10995, 0.11173, 0.11347, 0.11518, 0.11683, 0.11839, 0.1=
1987, 0.12121,
 0.12246, 0.12359, 0.12461, 0.12552, 0.12633, 0.12704, 0.12768, 0.12824, 0.1=
2874, 0.12917,
 0.12955, 0.12988, 0.13015, 0.13038, 0.050121, 0.046518, 0.043158, 0.040145,=
 0.037199, 0.034239,
 0.031452, 0.02887, 0.02673, 0.02488, 0.02313, 0.02146, 0.01988, 0.01853, 0.=
01755, 0.01706,
 0.01682, 0.01687, 0.01721, 0.01785, 0.01869, 0.01971, 0.02086, 0.02212, 0.0=
2355, 0.02504,
 0.02652, 0.02803, 0.02955, 0.03108, 0.03262, 0.03408, 0.03544, 0.03676, 0.0=
38, 0.03922,
 0.04034, 0.0414, 0.04239, 0.0433, 0.04415, 0.04493, 0.04563, 0.04626, 0.046=
82, 0.04731,
 0.04775, 0.04813, 0.04847, 0.04877, 0.04902, 0.04923, 0.085249, 0.083428, 0=
=2E081444, 0.079251,
 0.077009, 0.074971, 0.07317, 0.07161, 0.0699, 0.0685, 0.06735, 0.06638, 0.0=
656, 0.06509,
 0.06471, 0.06456, 0.06455, 0.06466, 0.06493, 0.06533, 0.06593, 0.06671, 0.0=
676, 0.06864,
 0.06974, 0.07081, 0.07186, 0.07294, 0.07401, 0.07507, 0.07613, 0.07717, 0.0=
782, 0.07919,
 0.08015, 0.08107, 0.08195, 0.08279, 0.08358, 0.08431, 0.08499, 0.08561, 0.0=
862, 0.08673,
 0.08721, 0.08763, 0.08802, 0.08836, 0.08867, 0.08893, 0.08916, 0.08936, 0.0=
38709, 0.036694,
 0.035047, 0.033534, 0.03192, 0.03041, 0.02914, 0.02801, 0.0271, 0.02641, 0.=
02571, 0.0251,
 0.02461, 0.02424, 0.02386, 0.02363, 0.02357, 0.02368, 0.02397, 0.02441, 0.0=
2493, 0.02566,
 0.02641, 0.02713, 0.02787, 0.02861, 0.02939, 0.03017, 0.03097, 0.03182, 0.0=
3268, 0.0335,
 0.03434, 0.03518, 0.03598, 0.0367, 0.03736, 0.038, 0.03858, 0.03914, 0.0396=
6, 0.04015,
 0.0406, 0.04101, 0.04139, 0.04173, 0.04205, 0.04234, 0.0426, 0.04284, 0.043=
04, 0.04323,
 0.029664, 0.028579, 0.027134, 0.02574, 0.02454, 0.02334, 0.0224, 0.02153, 0=
=2E02069, 0.02014,
 0.01949, 0.01904, 0.01878, 0.01849, 0.01823, 0.01805, 0.01794, 0.0179, 0.01=
797, 0.01815,
 0.0183, 0.01856, 0.0189, 0.01934, 0.01989, 0.02045, 0.02104, 0.02167, 0.022=
31, 0.02294,
 0.02359, 0.02423, 0.02484, 0.02542, 0.02595, 0.02645, 0.02694, 0.02743, 0.0=
2791, 0.02835,
 0.02876, 0.02914, 0.0295, 0.02982, 0.03013, 0.03042, 0.03068, 0.03092, 0.03=
113, 0.03132,
 0.03148, 0.03163, 0.086458, 0.085712, 0.08488, 0.08418, 0.08357, 0.08294, 0=
=2E08228, 0.08183,
 0.0815, 0.08132, 0.08115, 0.08106, 0.08099, 0.08098, 0.08102, 0.08108, 0.08=
13, 0.08156,
 0.08189, 0.08229, 0.08272, 0.0831, 0.08348, 0.08394, 0.08444, 0.08495, 0.08=
542, 0.08594,
 0.08643, 0.0869, 0.08737, 0.08783, 0.08829, 0.08877, 0.0892, 0.08959, 0.089=
97, 0.09034,
 0.09069, 0.09101, 0.0913, 0.09157, 0.09182, 0.09205, 0.09227, 0.09247, 0.09=
266, 0.09282,
 0.09297, 0.0931, 0.09322, 0.09334, 0.051966, 0.05133, 0.05081, 0.05032, 0.0=
4974, 0.04919,
 0.04878, 0.04853, 0.04815, 0.04774, 0.04739, 0.04718, 0.047, 0.0469, 0.0469=
2, 0.04698,
 0.0471, 0.04721, 0.04739, 0.04761, 0.04785, 0.04818, 0.04854, 0.04882, 0.04=
911, 0.04944,
 0.04983, 0.05024, 0.05062, 0.05103, 0.0514, 0.05173, 0.05206, 0.05237, 0.05=
264, 0.05289,
 0.05317, 0.05344, 0.0537, 0.05395, 0.05418, 0.0544, 0.0546, 0.05477, 0.0549=
3, 0.05509,
 0.05523, 0.05537, 0.05549, 0.0556, 0.05572, 0.05581, -0.00033, -0.00061, -0=
=2E00073, -0.00091,
 -0.00076, -0.00067, -0.00039, -0.0003, -2e-05, 0.00019, 0.00033, 0.00044, 0=
=2E00044, 0.00044,
 0.00047, 0.00044, 0.00047, 0.00053, 0.00063, 0.00084, 0.00099, 0.00115, 0.0=
0136, 0.00159,
 0.00182, 0.00203, 0.00221, 0.00233, 0.0025, 0.00268, 0.00287, 0.00307, 0.00=
326, 0.00345,
 0.00365, 0.00386, 0.00404, 0.00422, 0.00437, 0.00453, 0.00467, 0.0048, 0.00=
493, 0.00504,
 0.00516, 0.00526, 0.00536, 0.00545, 0.00555, 0.00563, 0.0057, 0.00577, 0.03=
228, 0.03215,
 0.03187, 0.03159, 0.03107, 0.03068, 0.03043, 0.03033, 0.0304, 0.03037, 0.03=
019, 0.03004,
 0.03004, 0.03001, 0.03013, 0.03021, 0.03026, 0.03036, 0.03049, 0.03068, 0.0=
3085, 0.03097,
 0.03114, 0.03122, 0.03132, 0.03141, 0.03151, 0.03168, 0.03186, 0.03203, 0.0=
3216, 0.03229,
 0.03241, 0.03253, 0.03266, 0.03276, 0.03285, 0.03295, 0.03305, 0.03314, 0.0=
3325, 0.03335,
 0.03343, 0.0335, 0.03358, 0.03365, 0.03372, 0.03378, 0.03383, 0.03388, 0.03=
391, 0.03396,
 0.06771, 0.06736, 0.06716, 0.06676, 0.06668, 0.06675, 0.06698, 0.06708, 0.0=
6697, 0.06693,
 0.06695, 0.0669, 0.06694, 0.06699, 0.06701, 0.06704, 0.06708, 0.06702, 0.06=
704, 0.06708,
 0.06718, 0.06729, 0.06744, 0.06757, 0.06765, 0.06774, 0.06783, 0.06787, 0.0=
6791, 0.06798,
 0.06805, 0.06812, 0.06821, 0.06829, 0.06836, 0.06843, 0.06849, 0.06858, 0.0=
6866, 0.06872,
 0.06877, 0.06883, 0.06889, 0.06894, 0.069, 0.06905, 0.06909, 0.06913, 0.069=
16, 0.06919,
 0.06923, 0.06926, 0.01335, 0.01321, 0.01308, 0.01302, 0.01307, 0.01304, 0.0=
1304, 0.01295,
 0.01276, 0.01269, 0.01265, 0.01265, 0.01269, 0.01283, 0.01289, 0.01299, 0.0=
1303, 0.0131,
 0.01318, 0.01317, 0.01311, 0.01314, 0.0132, 0.01326, 0.0133, 0.01333, 0.013=
36, 0.01335,
 0.01335, 0.01335, 0.01337, 0.01339, 0.01342, 0.01345, 0.01349, 0.01353, 0.0=
1356, 0.0136,
 0.01364, 0.01369, 0.01373, 0.01377, 0.0138, 0.01382, 0.01386, 0.01389, 0.01=
391, 0.01393,
 0.01396, 0.01397, 0.014, 0.01402, 0.02305, 0.02308, 0.02315, 0.02305, 0.022=
96, 0.02293,
 0.02296, 0.02292, 0.02286, 0.02289, 0.0229, 0.02285, 0.02281, 0.02277, 0.02=
273, 0.02269,
 0.02274, 0.02279, 0.0228, 0.02277, 0.02274, 0.02277, 0.02275, 0.02275, 0.02=
278, 0.02281,
 0.0228, 0.02283, 0.02286, 0.02287, 0.02288, 0.02291, 0.02293, 0.02294, 0.02=
296, 0.02299,
 0.02301, 0.02302, 0.02302, 0.02305, 0.02306, 0.02307, 0.02309, 0.02311, 0.0=
2312, 0.02313,
 0.02314, 0.02315, 0.02315, 0.02316, 0.02318, 0.02317, 0.00569, 0.00578, 0.0=
0581, 0.00572,
 0.00558, 0.00547, 0.00535, 0.00526, 0.0052, 0.00517, 0.00514, 0.00516, 0.00=
522, 0.00518,
 0.00518, 0.00517, 0.00519, 0.00521, 0.00519, 0.00516, 0.00514, 0.00512, 0.0=
0513, 0.00515,
 0.00516, 0.00515, 0.00514, 0.00513, 0.00513, 0.00514, 0.00515, 0.00514, 0.0=
0514, 0.00514,
 0.00515, 0.00515, 0.00515, 0.00516, 0.00517, 0.00517, 0.00516, 0.00516, 0.0=
0516, 0.00516,
 0.00516, 0.00516, 0.00516, 0.00516, 0.00516, 0.00516, 0.00515, 0.00515, 0, =
0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

static double	xstep, xoff, ystep, zstep, zoff;
static int	readflag =3D 1;
double floor(double);
/* int nint(double);*/

	if( readflag ) {
/*		filep =3D fopen( "asncorr.dat", "r");
		if( filep =3D=3D NULL ){
			fprintf(stderr,"Can't open correction file\n");
			return( -100.0 );
		}

		nread =3D fread( (char *)corrfac, sizeof(double), NXMAX*NYMAX*NZMAX, filep=
);
		if( nread !=3D NXMAX*NYMAX*NZMAX ){
			fprintf(stderr,"Error reading correction file\n");
			return( -200 );
		}
	=09
*/		xstep =3D log(XEND/XSTART)/(NXMAX-1.0);
		xoff  =3D log(XSTART);
		ystep =3D log(1.0+ YEND-YSTART)/(NYMAX-1.0);
		zstep =3D log(1.1);
		zoff  =3D log(ZSTART);
		readflag =3D 0;
	}

	sigt =3D volin * sqrt( toend/DAYSYR );
	sk   =3D s/k;
	tste =3D sta/toend;

	if( sigt<=3D0.0 || sk<=3D0.0 || tste<0.0 )
		return( 0.0 );

	x  =3D log(sigt);
	y  =3D log(tste+1);
	z  =3D log(sk);

	dx    =3D  (( x - xoff )/xstep);
	nx    =3D (int) floor(dx);
	dx   -=3D nx;

	dy    =3D (y/ystep);
	ny    =3D (int) floor(dy);
	dy	 -=3D ny;

	dz    =3D ( z - zoff ) / zstep;
	nz    =3D (int) floor(dz);
	dz   -=3D nz;

	if( nx<0 || nx>=3DNXMAX  || ny<0 || ny>=3DNYMAX  || nz<0 || nz>=3DNZMAX   )
		return(0.0);

	if( nx =3D=3D 0 ) {
		nx++;
		dnx =3D -1;
		dx  =3D 1.0 - dx;
	}
	else    dnx =3D 1;

	if( ny =3D=3D 0 ) {
		ny++;
		dny =3D -1;
		dy  =3D 1.0 - dy;
	}
	else    dny =3D 1;

	if( nz =3D=3D 0 ) {
		nz++;
		dnz =3D -1;
		dz  =3D 1.0 - dz;
	}
	else    dnz =3D 1;

	f[0][0][0] =3D corrfac[nx][ny][nz];
	f[1][0][0] =3D corrfac[nx+dnx][ny][nz];
	f[2][0][0] =3D corrfac[nx-dnx][ny][nz];
	f[0][1][0] =3D corrfac[nx][ny+dny][nz];
	f[0][2][0] =3D corrfac[nx][ny-dny][nz];
	f[0][0][1] =3D corrfac[nx][ny][nz+dnz];
	f[0][0][2] =3D corrfac[nx][ny][nz-dnz];
	f[1][1][0] =3D corrfac[nx+dnx][ny+dny][nz];
	f[1][0][1] =3D corrfac[nx+dnx][ny][nz+dnz];
	f[0][1][1] =3D corrfac[nx][ny+dny][nz+dnz];
	f[1][1][1] =3D corrfac[nx+dnx][ny+dny][nz+dnz];

	correction =3D triinterp( f, dx, dy, dz )*s/2.00 ; /* scale correction from=
 $2 underlying */
	return ( correction );
}

#undef 	XSTART
#undef  XEND
#undef 	YSTART
#undef  YEND
#undef 	ZSTART
#undef  NXMAX
#undef  NYMAX
#undef  NZMAX

void FastAsian(s, k, r, volin, set, expd, sta, toend, tradedays, callflag, r=
values)
double 	s,			/* price of Underlying 	*/
		k,		/* Strike               */
		r,		/* annualized cost of money, for discounting */
		volin,		/* annualized volatility, eg. 0.30 	*/
		set,		/* Ave. price of underlying already set, if into averaging period */
		expd,		/* days until option expiration */
		sta,		/* days until start of averaging */
		toend,		/* days until end of averaging */
		tradedays,	/* number of trading days in a year 		*/
		*rvalues;	/* return values, see above explanation 	*/
int		callflag;	/* 1=3DCall, 0=3DPut  				*/
{

double	tadjust;		/* factor to adjust time from trading day to calendar day
					basis (used by called functions callr() putr() */
double	totdays, setdays, daysleft, tonext;
double	risk[7], kold, delt, vol, prem, nfac, fac, dfac, avg;
double	delta, gamma, vega, rho, theta, sigdelt;
double  callr(), putr();
double	correctcall();
int	i;

	tadjust =3D DAYSYR/tradedays;

	if( expd<0.0 ){
		dfac =3D 1.0;
		expd =3D 0.0;
	}
	else	      =20
		dfac =3D exp( r*(-expd)/DAYSYR );

	if( toend<=3D0 ){		/* if we are finished with the averaging period */
		if( callflag ){	/* Call */
			if( set > k ) prem =3D ( set - k );
			else	      prem =3D 0.0;
		}
		else{		/* Put */
			if( k > set ) prem =3D ( k - set );
			else	      prem =3D 0.0;
		}
		rvalues[0] =3D dfac * prem;
		rvalues[1] =3D rvalues[2] =3D rvalues[3] =3D rvalues[6] =3D 0.0;
		rvalues[4] =3D (-expd) * prem/DAYSYR;
		rvalues[5] =3D r * prem/DAYSYR;
	}
	else if( sta > 0.0 ){	/* if averaging period has not started */
		delt =3D ( toend-sta+1.0 );
		nfac =3D ( delt-0.5 )/( delt );
		vol  =3D sqrt( volin*volin*( nfac*(delt-1.0)/3.0 + sta )/toend );
		if( callflag )
			prem =3D callr( s, k, toend*tadjust, r, r, vol, risk)=20
				+ correctcall( s, k, volin, sta*tadjust, toend*tadjust);
		else
			prem =3D  putr( s, k, toend*tadjust, r, r, vol, risk);

		/** these risk parameters neglect the effect of the additive correction **=
/
		delta =3D risk[0];
		gamma =3D risk[1];
		vega  =3D risk[2] * sqrt( (nfac*(delt-1.0)/3.0 + sta )/toend );
		rho   =3D risk[5];
		theta =3D risk[4] + risk[2]*(vol-volin*volin/vol)*tradedays/(2.0*toend);
		sigdelt =3D risk[6]*vol/volin;

		if( expd !=3D toend*tadjust )
			dfac =3D exp( r*(toend/tradedays-expd/DAYSYR) );
		else
			dfac =3D 1.0;

		rvalues[0] =3D dfac * prem;
		rvalues[1] =3D dfac * delta;
		rvalues[2] =3D dfac * gamma;
		rvalues[3] =3D dfac * vega;
		rvalues[4] =3D dfac * rho;
		rvalues[5] =3D dfac * theta;
		rvalues[6] =3D dfac * sigdelt;

	} else {		/* else, we are in averaging period */
	/* assumes that "current day" price has settled */
		totdays =3D toend-sta+1.0;
		daysleft =3D ceil( toend );		/* number of settles remaining */
		tonext =3D toend - (daysleft-1.0);/* tonext is time to next price settle *=
/
		setdays =3D totdays - daysleft;

		/* if averaging period has already started, adjust strike price
		   for option decomposition */
		kold =3D k;
		k    =3D ( totdays*kold - setdays*set ) / daysleft;

		if( k < 0.0 ){	/** if effective strike is negative, then value as a forwar=
d **/
			avg  =3D (  setdays*set + daysleft*s) / totdays;
			if( callflag ){	/* Call option is deep in the money */
				prem =3D ( avg - kold ) * exp( -r * toend*tadjust);
				rvalues[0] =3D prem =3D prem*(prem>0);
				rvalues[1] =3D delta =3D exp( -r * toend*tadjust);
				rvalues[2] =3D rvalues[3] =3D rvalues[6] =3D 0.0;
				rvalues[4] =3D (-expd) * prem/DAYSYR;
				rvalues[5] =3D (-r)*prem/DAYSYR;
			}
			else{		/* Put  option is far out of the money */
				prem =3D ( kold - avg ) * exp( -r * toend*tadjust);
                prem =3D prem*(prem>0);
                rvalues[0] =3D prem =3D prem*(prem>0);
				rvalues[1] =3D delta =3D 0.0;
				rvalues[2] =3D rvalues[3] =3D  rvalues[6] =3D 0.0;
				rvalues[4] =3D 0.0;
				rvalues[5] =3D 0.0;
			}
		} else {
			FastAsian( s, k, r, volin, set, expd, tonext, toend, tradedays, callflag,=
 rvalues);
			fac   =3D daysleft/totdays;
			rvalues[0] *=3D fac;
			rvalues[1] *=3D fac;
			rvalues[2] *=3D fac;
			rvalues[3] *=3D fac;
			rvalues[4] *=3D fac;
			rvalues[5]  =3D rvalues[5]*fac - rvalues[0]/totdays;
			rvalues[6] *=3D fac;
		}
	}

	for( i=3D0; i<7; i++)
		if( fabs(rvalues[i]) < 1e-20 ) rvalues[i] =3D 0.0;
	return;
}


/*------------------------------------------------------------------
 *
 *	triinterp.c
 *
 *	Does tri-variate interpolation.
 *
 *
 ------------------------------------------------------------------*/

double triinterp( double  f[3][3][3], double p, double q, double r)
/* double	p, q, r, f[3][3][3]; */
{

	double value;

	value =3D f[0][0][0] +
		0.5*( p*(f[1][0][0]-f[2][0][0]) + q*(f[0][1][0]-f[0][2][0]) + r*(f[0][0][1=
]-f[0][0][2])
		+ p*p*(f[1][0][0]-2.*f[0][0][0]+f[2][0][0])
		+ q*q*(f[0][1][0]-2.*f[0][0][0]+f[0][2][0])
		+ r*r*(f[0][0][1]-2.*f[0][0][0]+f[0][0][2]) );

	value +=3D  p*q*(f[1][1][0]-f[1][0][0]-f[0][1][0]+f[0][0][0])
		+ p*r*(f[1][0][1]-f[1][0][0]-f[0][0][1]+f[0][0][0])
		+ q*r*(f[0][1][1]-f[0][1][0]-f[0][0][1]+f[0][0][0])
		+ p*q*r*(f[1][1][1]-f[1][0][1]-f[0][1][1]+f[0][0][1] -=20
			 f[1][1][0]+f[1][0][0]+f[0][1][0]-f[0][0][0]);

	return( value );
}

#undef  DAYSYR

--------------000506070003020302060604
Content-Type: text/plain; name="Getrvs2.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Getrvs2.c"

#include  <math.h>
#include  "M_PI.h"

#define MAXTS           9002         /* max number of time steps + 2 */

void getrvs2( out, n)
double out[];
int n;
{
        double sam1[MAXTS], a0 ;
        int i, n1;
        double std_random();

        n1 =3D 2*n;
        for(i=3D0;i<n1;i++)
            sam1[i]=3Dstd_random();

        for (i=3D0;i<n;i++)
        {
            a0=3Dsqrt(-2*log(sam1[i]));
            out[2*i]     =3D a0*cos(2*M_PI*sam1[n+i]);
            out[(2*i)+1] =3D a0*sin(2*M_PI*sam1[n+i]);
        }
}
#undef MAXTS

--------------000506070003020302060604
Content-Type: text/plain; name="Glook.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Glook.c"

/*---------------------------------------------------
 *
 *	file: glook.c
 *
 *	V0.0	20jul93  following Mark Garman's strike bonus decomposition. psg.
 *
 *	Lookback Option Model for "stock" with continuous dividend yield q.
 *
 *
 * 	s    spot price     =20
 * 	k    strike price  =20
 * 	r    annualized riskfree rate
 * 	q    continuous dividend yield
 * 	vol  annualized volatility =20
 * 	expd days to expiration=20
 * 	call 1 for call, 0 for put.
 * 	daysyr	number of simulation days in a year.


    COPYRIGHT C 1993, BY ENRON GAS SERVICES, ALL RIGHTS RESERVED.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON GAS SERVICES.
-----------------------------------------------------*/

#include  <math.h>
#include  "M_PI.h"

double glook( s, k, r, q, vol, expd, call, daysyr)
double s, k, r, q, expd, vol, daysyr;
int	call;
{
    double time, sigt, d1, d2, value, Nd1, Nd2;
    double bonus, y, lambda;
    double cumnorm();

    time =3D expd/daysyr;
    sigt =3D vol*sqrt(time);

    d1 =3D (log(s/k)+(r-q+vol*vol/2)* time)/sigt;
    d2 =3D d1-sigt ;

    Nd1 =3D cumnorm(d1);
    Nd2 =3D cumnorm(d2);

    y =3D -d1;
    lambda =3D 2.*(r-q)/(vol*vol);

    if( call ){
        value =3D s*Nd1*exp(-q*time) - k*Nd2*exp(-r*time);

        if( r !=3D q )
            bonus =3D (s/lambda)*( exp(-r*time) * pow(s/k,-lambda) * cumnorm=
(y+lambda*sigt)
                    - exp(-q*time)*cumnorm(y) );
        else
            bonus =3D s*exp(-r*time)*sigt*( exp(-y*y/2.0)/sqrt(2.0*M_PI) + y=
*cumnorm(y));
        value +=3D bonus;
    }
    else{ /** put **/

        value =3D s*(Nd1-1.0)*exp(-q*time) - k*(Nd2-1.0)*exp(-r*time);

        if( r !=3D q )
            bonus =3D (s/lambda)*( exp(-r*time) * pow(s/k,-lambda) *=20
                    (cumnorm(y+lambda*sigt)-1.0) - exp(-q*time)*(cumnorm(y)-=
1.0) );
        else
            bonus =3D s*exp(-r*time)*sigt*( exp(-y*y/2.0)/sqrt(2.0*M_PI) + y=
*(cumnorm(y)-1.0) );
        value +=3D bonus;
    }

    return( value );
}

--------------000506070003020302060604
Content-Type: text/plain; name="Impeuro.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Impeuro.c"

/*
Uses Brent's method of finding root, which seems to take=20
far fewer iteration steps (by about a factor of 3) than
the bisection method. Note this contains its own
option model routine -- aside from some
Numerical Recipes routines, no other files are
necessary.
*/
#include <stdio.h>
#include <math.h>
#include <ctype.h>
#include <stddef.h>
#include <stdlib.h>
#include "nrutil.h"

#define TRUE 1
#define FALSE 0
#define SUCCESS 1
#define FAILURE 0



#define ABS(x) ( (x)>0 ? (x) : (-x))
#define SGN(x) ( (x)>0 ? (1) : (-1))


void do_error(char error_text[])
/* Standard error handler. */
{
  fprintf(stderr, "Error encountered...\n");
  fprintf(stderr, "%s\n", error_text);
 /* exit(FAILURE); */
}



/*    implied euro */

#define NRANSI
#define ITMAX 500=20
#define EPS 3.0e-8



#define E               2.718281828
#define PI              3.14159265359
#define B1              0.4361836
#define B2             -0.1201676
#define B3              0.937298
#define B4             -1.821255978
#define B5              1.330274429
#define A               0.33267
#define RT2PI           2.506628275

/* Lifted without modifications from /research/joy/rms/rms1.4 */
static double  Power( double a, int b) {
/* raises a to the b Power, returns result as double */

  double c;
  int i;
  c =3D 1;
  for (i=3D1; i<=3Db; i++)
		c =3D c * a;
  return c;
}


/* Lifted without modifications from /research/joy/rms/rms1.4 */
double  CalcBseries( double in_val) {

  double out_val;
  out_val =3D   B1*(1/(1+(A*fabs(in_val))))
					+ B2 * (Power(1/(1+(A*fabs(in_val))),2))
					+ B3 * (Power(1/(1+(A*fabs(in_val))),3));
  return out_val;
}



/* Lifted without modifications from /research/joy/rms/rms1.4 */
double  CalcND1( double D1, double Bseries1) {

  double ND1;
   if ( D1 > 40.)
      return(1.0);
   else if ( D1 < -40.)
      return(0.0);

   ND1 =3D 1-(1/sqrt(2 * PI) * exp((-D1*D1)/2) * Bseries1);
   if (D1<0)
       ND1 =3D 1 - ND1;
   return ND1;
}

/* Lifted from /research/joy/rms/rms1.4 -- MODIFIED TO ALLOW FOR ARBITRARY Y=
IELD. */=20
double  CalcCall( double IntRt, double Yield, double Time, double FwdPr, dou=
ble ND1, double FixPr, double ND2) {

  double Call;
  Call =3D exp(-Yield * Time) * FwdPr * ND1 - exp(-IntRt * Time) * FixPr * N=
D2;
  return Call;
}

/* Lifted from /research/joy/rms/rms1.4 -- MODIFIED TO ALLOW FOR ARBITRARY Y=
IELD. */=20
static double  CalcPut( double IntRt, double Yield, double Time, double FwdP=
r, double FixPr, double NegND1, double NegND2) {

  double Put;

  Put =3D exp(-IntRt * Time) * FixPr * NegND2  - exp(-Yield * Time) * FwdPr =
* NegND1;
  return Put;
}

/* Lifted from /research/joy/rms/rms1.4 -- MODIFIED TO ALLOW FOR ARBITRARY Y=
IELD. */=20
double  bscall0( double s, double k, double time, double r, double q, double=
 vol1  ) {

  double d1, d2, Bseries1, Bseries2, call, Nd1, Nd2;

  d1 =3D (log(s/k)+(r - q + vol1*vol1/2)* time)/(vol1 * sqrt(time));
  d2 =3D d1-(vol1*sqrt(time));

  /* d1=3D CalcD1(mo_qty,s,k,vol1,time); d2=3DCalcD2(mo_qty,s,k,vol1,time); =
*/

    Bseries1 =3D CalcBseries(d1);
    Bseries2 =3D CalcBseries(d2);
    Nd1=3D CalcND1(d1, Bseries1);
    Nd2 =3D CalcND1(d2, Bseries2);
    call =3D CalcCall(r,q,time,s,Nd1,k,Nd2);
  return( call );
}

/* Lifted from /research/joy/rms/rms1.4 -- MODIFIED TO ALLOW FOR ARBITRARY Y=
IELD. */=20
double  bsput0( double s, double k, double time, double r, double q, double =
vol1  ) {
 =20
  double negd1, negd2, Bseries1, Bseries2, put, Nd1, Nd2;

    negd1 =3D (log(s/k)+(r - q + vol1*vol1/2)* time)/(-vol1 * sqrt(time));
    negd2 =3D vol1*sqrt(time) + negd1;

    Bseries1 =3D CalcBseries(negd1);
    Bseries2 =3D CalcBseries(negd2);
    Nd1=3D CalcND1(negd1, Bseries1);
    Nd2 =3D CalcND1(negd2, Bseries2);

    put =3D k * exp(-r*time) * Nd2 - s *  exp(-r*time) * Nd1;
    return( put );
}


/* Lifted from /research/joy/rms/rms1.4=20
  -- MODIFIED TO ALLOW FOR ARBITRARY YIELD=20
  -- also days2expiry variable has been
  substituted with tenor. */=20

double bseuro(int pc, double s, double k, double amount, double tenor, doubl=
e vol1, double r, double q  ){
  if( pc =3D=3D 1)
    return(amount * bscall0(s, k, tenor, r, q, vol1  ) );   // call
  else if( pc =3D=3D 0)
    return(amount * bsput0( s, k, tenor, r, q, vol1  ) );   // put
  else if( pc =3D=3D 2)					   // straddle =3D call + put
	return(amount * (bsput0( s, k, tenor, r, q, vol1  )+  \
	                 bscall0(s, k, tenor, r, q, vol1  )  ) );

  else{
    do_error("Error in bseuro\n");
  }
  return((double) FAILURE);
}



/* Modified from Numer. Recip. */
double zbrent_e(double (*bseuro)(int, double, double, double, double, double=
, double, double),
	     double x1, double x2, double tol,
	     int putcallind, double spot, double strike, double amount, double teno=
r, double actual_premium,
	     double rate, double yield, int maxiter)
{
	int iter;
	double a=3Dx1,b=3Dx2,c=3Dx2,d,e,min1,min2;
	double fa=3D(*bseuro)(putcallind, spot, strike, amount, tenor, a, rate, yie=
ld)-actual_premium,
	       fb=3D(*bseuro)(putcallind, spot, strike, amount, tenor, b, rate, yie=
ld)-actual_premium,
	       fc,p,q,r,s,tol1,xm;

	if ((fa > 0.0 && fb > 0.0) || (fa < 0.0 && fb < 0.0)){
	  // do_error("Root must be bracketed in zbrent_e");
		return -1.0;  // maxvol too small
	 }
	fc=3Dfb;
	for (iter=3D1;iter<=3D ( maxiter <=3D ITMAX ? maxiter : ITMAX) ;iter++) {

		if ((fb > 0.0 && fc > 0.0) || (fb < 0.0 && fc < 0.0)) {
			c=3Da;
			fc=3Dfa;
			e=3Dd=3Db-a;
		}
		if (fabs(fc) < fabs(fb)) {
			a=3Db;
			b=3Dc;
			c=3Da;
			fa=3Dfb;
			fb=3Dfc;
			fc=3Dfa;
		}
		tol1=3D2.0*EPS*fabs(b)+0.5*tol;
		xm=3D0.5*(c-b);
		if (fabs(xm) <=3D tol1 || fb =3D=3D 0.0) return b;
		if (fabs(e) >=3D tol1 && fabs(fa) > fabs(fb)) {
			s=3Dfb/fa;
			if (a =3D=3D c) {
				p=3D2.0*xm*s;
				q=3D1.0-s;
			} else {
				q=3Dfa/fc;
				r=3Dfb/fc;
				p=3Ds*(2.0*xm*q*(q-r)-(b-a)*(r-1.0));
				q=3D(q-1.0)*(r-1.0)*(s-1.0);
			}
			if (p > 0.0) q =3D -q;
			p=3Dfabs(p);
			min1=3D3.0*xm*q-fabs(tol1*q);
			min2=3Dfabs(e*q);
			if (2.0*p < (min1 < min2 ? min1 : min2)) {
				e=3Dd;
				d=3Dp/q;
			} else {
				d=3Dxm;
				e=3Dd;
			}
		} else {
			d=3Dxm;
			e=3Dd;
		}
		a=3Db;
		fa=3Dfb;
		if (fabs(d) > tol1)
			b +=3D d;
		else
			b +=3D SIGN(tol1,xm);
		fb=3D(*bseuro)(putcallind, spot, strike, amount, tenor, b, rate, yield)-ac=
tual_premium;
	}
	//do_error("Maximum number of iterations exceeded in zbrent_e");
	return -2.0;
}
/* #undef ITMAX */
#undef EPS
#undef NRANSI
/* (C) Copr. 1986-92 Numerical Recipes Software L-4jn>#(. */


double impeuro(int putcallind, double actual_premium, double spot, double st=
rike,
	     double tenor, double rate, double yield, double maxvol, double accurac=
y, int maxiter)
{

  double amount=3D1.0;

/*
  if(maxiter >=3D ITMAX)
    printf("Warning: max. # of iterations has been reduced to %d\n", ITMAX);=
 */




  return( zbrent_e(bseuro, accuracy/4, maxvol, accuracy, putcallind, spot,
					 strike, amount, tenor, actual_premium, rate, yield, maxiter));
}



#if 0
void main(){

 char yes[2];
 double retval;

/*  double impeuro(char putcallind, double actual_premium, \=20
	     double spot, double strike, double amount, \
	     double tenor, double rate, double yield, double maxvol,\
		 double accuracy, int maxiter)  */

 retval=3Dimpeuro('s', 0.2, 2.0, 2.1, 1.0,
	     .05, .06, .06, 10., 0.0002, 100);

 printf("impvol=3D %lf\n", retval);


 scanf("%s",yes);

 return;
}

#endif





--------------000506070003020302060604
Content-Type: text/plain; name="Lookback.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Lookback.c"

/*-------------------------------------------------------------

  file: lookback.c

  V0.0  26jul93  analytical solution, finite-diff greeks. -psg


  LookBack Option in Continuous Time


      rvalues[] =3D  value           [0]
                   delta           [1]
                   gamma           [2]
                   lambda (vega)   [3]
                   rho             [4]
                   theta           [5]
                   dDdV            [6]  not implemented=20

    COPYRIGHT C 1993, BY ENRON GAS SERVICES, ALL RIGHTS RESERVED.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON GAS SERVICES.
------------------------------------------------------------------------*/

#include  <stdio.h>
#include  <math.h>

#define EPS			0.001

void lookback( s, k, r, q, vol, expd, call, daysyr, rvalues )
double 		s,		/* price of Underlying 	*/
		k,		/* Strike               */
		r,		/* annualized cost of money, for discounting */
		q,		/* annualized dividend yield (=3Dr for commodity */
		vol,		/* annualized volatility, eg. 0.30 	*/
		expd,		/* days until option expiration */
		daysyr,		/* number of days in an effective year  */
		rvalues[];	/* number of days in an effective year  */
int		call;		/* 1=3DCall, 0=3DPut  */
{
double	value;
double	delta, gamma, vega, rho, theta, sigdelta;
double	glook();

	value  =3D  glook( s, k, r, q, vol, expd, call, daysyr);
	delta  =3D ( glook( s*(1.+EPS), k, r, q, vol, expd, call, daysyr) -value) /=
 (s*EPS);
	gamma  =3D ( glook( s*(1.+EPS), k, r, q, vol, expd, call, daysyr)
		+ glook( s*(1.-EPS), k, r, q, vol, expd, call, daysyr)
		-2.*value) / (s*EPS*s*EPS);
	vega   =3D ( glook( s, k, r, q, vol*(1.+EPS), expd, call, daysyr)-value)/(v=
ol*EPS);

	/* commodity rho */
	if( r=3D=3D 0.0 )
		rho =3D 0.0;
	else
		rho    =3D ( glook( s, k, r*(1.+EPS), q*(1.+EPS), vol, expd, call, daysyr)=
-value)/(r*EPS);

	theta  =3D ( glook( s, k, r, q, vol, (expd-1.0), call, daysyr)-value)/ (1./=
daysyr);

	sigdelta =3D ( glook( s*(1.+EPS), k, r, q, vol*(1.+EPS), expd, call, daysyr=
)
		    +glook( s*(1.-EPS), k, r, q, vol*(1.-EPS), expd, call, daysyr)
		    -glook( s*(1.-EPS), k, r, q, vol*(1.+EPS), expd, call, daysyr)
		    -glook( s*(1.+EPS), k, r, q, vol*(1.-EPS), expd, call, daysyr)
		   ) / (4.0*s*EPS*vol*EPS);

	rvalues[0] =3D  value;
	rvalues[1] =3D  delta;
	rvalues[2] =3D  gamma;
	rvalues[3] =3D  vega;
	rvalues[4] =3D  rho;
	rvalues[5] =3D  theta;
	rvalues[6] =3D  sigdelta;

}
#undef EPS

--------------000506070003020302060604
Content-Type: text/plain; name="M_pi.h"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="M_pi.h"

#ifndef M_PI
#define M_PI 3.141592653589793
#endif
--------------000506070003020302060604
Content-Type: text/plain; name="N.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="N.c"

/*-------------------------------------------------------
	function   N()

	Calculates cumulative normal
=09
-------------------------------------------------------*/

double N(a)
double a;
{
  double cumnorm();

  return (cumnorm(a));
}


--------------000506070003020302060604
Content-Type: text/plain; name="NEWSPREAD.C"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="NEWSPREAD.C"

#include <stdio.h>
#include <math.h>
#include "spdopt.h"

/* Changed London version 9th March 1999 by Anjam Ahmad to ensure that cross=
 gamma */
/* is greek number five to match output from existing Exotic options library=
 */

void setup(double s1,double s2,double strike,double r, \
		   double q1, double q2,double vol1,double vol2,double correl,\
		   double tmat){

	double A;
=09
	S.s1		=3Ds2;
	S.s2		=3Ds1;
	S.strike	=3Dstrike;
	S.r			=3Dr;
	S.q1		=3Dq2;
	S.q2		=3Dq1;
	S.vol1		=3Dvol2;
	S.vol2		=3Dvol1;
	S.correl	=3Dcorrel;
	S.tmat		=3Dtmat;

// calculate some constants
	S.temp=3DS.correl*S.vol2/S.vol1;

	A=3D S.r*(1.0-S.temp)
	    - (S.q2-S.q1*S.temp)
		+ S.correl*S.vol1*S.vol2*(1.0-S.temp)*0.5;
	A *=3D S.tmat;

	S.expA=3Dexp(A);
	=09
	S.m1=3Dlog(S.s1) + (S.r-S.q1-S.vol1*S.vol1*0.5)*S.tmat;
	S.m2=3Dlog(S.s2) + (S.r-S.q2-S.vol2*S.vol2*0.5)*S.tmat;
	S.vol=3DS.vol2*sqrt( (1.0-S.correl*S.correl)*S.tmat);
	S.volt=3DS.vol1*sqrt(S.tmat);
	S.disc=3Dexp(-S.r*S.tmat);
	S.expq1=3Dexp(-S.q1*S.tmat);
	S.expq2=3Dexp(-S.q2*S.tmat);

}


double intrinsic(double s1, double s2, double strike, int opttype){

   if(opttype)
	   return DMAX((s1-s2) - strike,0.0);
   else
	   return DMAX(strike - (s1-s2),0.0);

}


double root(double alpha, double beta, double K, double s){
	double x, xp;
	int count=3D0;

	if(fabs(alpha-1.0)<EPSD ){// singular case with alpha=3Dbeta=3D1
	=09
		if(fabs(beta-1.0)>EPSD)
		 	xp=3DK/(beta-1.0);
		else=20
		    xp=3D-1.0;

        return xp;
	}


	x=3Ds; // initialization
=09
	do {
	  xp=3Dx-(beta*pow(x,alpha)-x-K)/(beta*alpha*pow(x,alpha-1.0)-1.0);  //Newt=
on-Raphson
	  x=3Dxp;
	  count++;
	} while(fabs(xp-x)>EPSD || count<MAX_ITER);

	return xp;
}




double UnitCorrPremium(double s1, double s2, double strike, double r,
			   double vol1, double vol2,=20
			   double correl, double tmat, int opttype){
=20

	double alpha, beta;
	double x1,x2,x1p;
	double s1T, q1, q2;
	double retval;

	if (tmat<=3D0.0)
		return intrinsic(s1, s2, strike, opttype);

	q1=3Dq2=3Dr;
=09
	setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat);

=20
// icorrel=3D1
  =20
	if(S.correl>0.0) { // correl=3D1
		alpha=3DS.vol2/S.vol1;
		beta=3DS.s2*pow(S.s1,-alpha)*exp(0.5*S.vol2*S.vol1*(1.0-alpha)*S.tmat);

	    s1T=3Droot(alpha,beta,S.strike,S.s1);
		if(s1T<0.0)
			return intrinsic(S.s2,S.s1,strike,opttype)*S.disc;

		x1p=3D(log(S.s1/s1T) +(alpha-0.5)*S.vol1*S.vol1*S.tmat)/(S.volt);
		x1 =3D(log(S.s1/s1T) +0.5*S.vol1*S.vol1*S.tmat)/(S.volt);
		x2=3D x1-S.volt;

		if(opttype){ //call
		   if(alpha>=3D1.0)
			 retval=3Dbeta*exp(alpha*(S.m1+0.5*S.vol1*S.vol1*S.tmat*alpha))*cumnorm(x=
1p) \
	              -S.s1*cumnorm(x1)-S.strike*cumnorm(x2);
		   else=20
			 retval=3Dbeta*exp(alpha*(S.m1+0.5*S.vol1*S.vol1*S.tmat*alpha))*cumnorm(-=
x1p) \
	              -S.s1*cumnorm(-x1)-S.strike*cumnorm(-x2);=09
		  =20
		}
		else{ //put
		   if(alpha>=3D1.0)
		     retval=3DS.strike*cumnorm(-x2) \
			     -beta*exp(alpha*(S.m1+0.5*S.vol1*S.vol1*S.tmat*alpha))*cumnorm(-x1p)=
 \
				 + S.s1*cumnorm(-x1);=20
		   else
			 retval=3DS.strike*cumnorm(x2) \
			     -beta*exp(alpha*(S.m1+0.5*S.vol1*S.vol1*S.tmat*alpha))*cumnorm(x1p) =
\
				 + S.s1*cumnorm(x1);=20

		}
	}
	else { //correl=3D-1
		alpha=3D-S.vol2/S.vol1;
		beta=3D(S.s2*pow(S.s1,-alpha))*exp(-0.5*S.vol2*S.vol1*(1.0-alpha)*S.tmat);
		s1T=3Droot(alpha,beta,S.strike,S.s1);

		x1p=3D(log(S.s1/s1T) +(alpha-0.5)*S.vol1*S.vol1*S.tmat)/(S.volt);
		x1 =3D(log(S.s1/s1T) +0.5*S.vol1*S.vol1*S.tmat)/(S.volt);
		x2=3D x1-S.volt;
        if(opttype){ //call
		     retval=3Dbeta*exp(alpha*(S.m1+0.5*S.vol1*S.vol1*S.tmat*alpha))*cumnor=
m(-x1p) \
			     -S.s1*cumnorm(-x1)-S.strike*cumnorm(-x2);
		}
		else{  //put
			 retval=3DS.strike*cumnorm(x2) \
			    -beta*exp(alpha*(S.m1+0.5*S.vol1*S.vol1*S.tmat*alpha))*cumnorm(x1p) \
			    + S.s1*cumnorm(x1);

		}
    }


	return (retval*S.disc);

}




/* extern DllExport=20
double __stdcall */ double UnitCorrSpd(double s1, double s2, double strike, =
double r,
			   double vol1, double vol2,=20
			   double correl, double tmat, int opttype, int rettype){
	double premium, up, down, retval;
	double rem1, rem, up2, up_1, up_2;

	premium=3DUnitCorrPremium(s1,s2,strike,r,vol1,vol2,correl,tmat,opttype);

	switch (rettype){
		case 0:
			return premium;
		case 1://deta1
			up=3DUnitCorrPremium(s1+EPSD,s2,strike,r,vol1,vol2,correl,tmat,opttype);
			down=3DUnitCorrPremium(s1-EPSD,s2,strike,r,vol1,vol2,correl,tmat,opttype)=
;
			retval=3D(up-down)/(2.0*EPSD);
			return retval;
		case 2://deta2
			up=3DUnitCorrPremium(s1,s2+EPSD,strike,r,vol1,vol2,correl,tmat,opttype);
			down=3DUnitCorrPremium(s1,s2-EPSD,strike,r,vol1,vol2,correl,tmat,opttype)=
;
			retval=3D(up-down)/(2.0*EPSD);
			return retval;
		case 3://gamma1
            up=3DUnitCorrPremium(s1+EPSD,s2,strike,r,vol1,vol2,correl,tmat,o=
pttype);
			down=3DUnitCorrPremium(s1-EPSD,s2,strike,r,vol1,vol2,correl,tmat,opttype)=
;
			retval=3D(up+down-2.0*premium)/(EPSD*EPSD);
			return retval;
		case 4://gamma2
		    up=3DUnitCorrPremium(s1,s2+EPSD,strike,r,vol1,vol2,correl,tmat,opttype=
);
			down=3DUnitCorrPremium(s1,s2-EPSD,strike,r,vol1,vol2,correl,tmat,opttype)=
;
			retval=3D(up+down-2.0*premium)/(EPSD*EPSD);
			return retval;
		case 5://cross gamma
            up2=3DUnitCorrPremium(s1+EPSD,s2+EPSD,strike,r,vol1,vol2,correl,=
tmat,opttype);
			up_1=3DUnitCorrPremium(s1+EPSD,s2,strike,r,vol1,vol2,correl,tmat,opttype)=
;
			up_2=3DUnitCorrPremium(s1,s2+EPSD,strike,r,vol1,vol2,correl,tmat,opttype)=
;
			retval=3D(up2-up_1-up_2 + premium)/(EPSD*EPSD);
			return retval;
		case 6://vega1
			up=3DUnitCorrPremium(s1,s2,strike,r,vol1*(1.0+EPSD),vol2,correl,tmat,optt=
ype);
			down=3DUnitCorrPremium(s1,s2,strike,r,vol1*(1.0-EPSD),vol2,correl,tmat,op=
ttype);
			retval=3D(up-down)/(2.0*vol1*EPSD);
			return retval;
		case 7://vega2
			up=3DUnitCorrPremium(s1,s2,strike,r,vol1,vol2*(1.0+EPSD),correl,tmat,optt=
ype);
			down=3DUnitCorrPremium(s1,s2,strike,r,vol1,vol2*(1.0-EPSD),correl,tmat,op=
ttype);
			retval=3D(up-down)/(2.0*vol2*EPSD);
			return retval;
		case 8://eta
			retval=3D0.0;
			return retval;
		case 9: //rho
			up=3DUnitCorrPremium(s1,s2,strike,r+EPSD,vol1,vol2,correl,tmat,opttype);
			down=3DUnitCorrPremium(s1,s2,strike,r-EPSD,vol1,vol2,correl,tmat,opttype)=
;
			retval=3D(up-down)/(2.0*EPSD);
			return retval;
		case 10://theta
			up=3DUnitCorrPremium(s1,s2,strike,r,vol1,vol2,correl,tmat*(1.0-EPSD),optt=
ype);
			down=3DUnitCorrPremium(s1,s2,strike,r,vol1,vol2,correl,tmat*(1+EPSD),optt=
ype);
			retval=3D(up-down)/(2.0*tmat*EPSD);
			return retval;
		case 11://charm1
			up=3DUnitCorrPremium(s1+EPSD,s2,strike,r,vol1,vol2,correl,tmat*(1.0-EPSD)=
,opttype);
			down=3DUnitCorrPremium(s1-EPSD,s2,strike,r,vol1,vol2,correl,tmat*(1.0-EPS=
D),opttype);
			rem=3D(up-down)/(2.0*EPSD);

			up=3DUnitCorrPremium(s1+EPSD,s2,strike,r,vol1,vol2,correl,tmat*(1.0+EPSD)=
,opttype);
			down=3DUnitCorrPremium(s1-EPSD,s2,strike,r,vol1,vol2,correl,tmat*(1.0+EPS=
D),opttype);
			rem1=3D(up-down)/(2.0*EPSD);

			retval=3D(rem-rem1)/(2.0*tmat*EPSD);
			return retval;
		case 12: //charm2
			up=3DUnitCorrPremium(s1,s2+EPSD,strike,r,vol1,vol2,correl,tmat*(1.0-EPSD)=
,opttype);
			down=3DUnitCorrPremium(s1,s2-EPSD,strike,r,vol1,vol2,correl,tmat*(1.0-EPS=
D),opttype);
			rem=3D(up-down)/(2.0*EPSD);

			up=3DUnitCorrPremium(s1,s2+EPSD,strike,r,vol1,vol2,correl,tmat*(1.0+EPSD)=
,opttype);
			down=3DUnitCorrPremium(s1,s2-EPSD,strike,r,vol1,vol2,correl,tmat*(1.0+EPS=
D),opttype);
			rem1=3D(up-down)/(2.0*EPSD);

			retval=3D(rem-rem1)/(2.0*tmat*EPSD);
			return retval;

		default:
		    return ERR_RETURN;
	}

}



/* extern DllExport=20
double __stdcall */ double Spread(double s1, double s2, double strike, doubl=
e r,
			   double vol1, double vol2,=20
			   double correl, double tmat, int opttype, int rettype){

	double f0,f1, retval, CUT;

//return intrinsic value
	if(tmat<EPSD && tmat>=3D0.0){
		if(rettype=3D=3D0)
			 return intrinsic(s1,s2,strike,opttype);
		else
			 return 0.0;
	}
	=09
	else if (tmat<0.0){
			return 0.0;
	}

	if(fabs(correl)<=3DUpCorr){=20
		retval=3DOSpread( s1, s2,  strike,  r, vol1,  vol2, correl,  tmat,  opttyp=
e,  rettype);
	    return retval;
	}
	else{
		if(rettype=3D=3D7){//do not interpolate eta
			CUT=3Dcorrel;
=09
			if (correl>0.9999)
				  CUT=3D0.9999;
		    if (correl<-0.9999)
				  CUT=3D-0.9999;

			retval=3DOSpread( s1, s2,  strike,  r, vol1,  vol2, CUT,  tmat,  opttype,=
  rettype);
			return retval;
		}
		else if(rettype>4 && rettype !=3D7 && rettype !=3D5){ // first orders are =
fine
			retval=3DOSpread( s1, s2, strike, r, vol1, vol2, correl, tmat, opttype, r=
ettype);
			return retval;
		=09
		}
		else{// do liner interpolation for rettype <5 and rettype=3D5(cross gamma)

			if(correl>UpCorr){ //correl=3D +1
				f0=3DOSpread( s1, s2,  strike,  r, vol1,  vol2, UpCorr,  tmat,  opttype,=
  rettype);
				f1=3DUnitCorrSpd( s1, s2,  strike,  r, vol1,  vol2, UpCorr,  tmat,  optt=
ype,  rettype);
				retval=3Df0+((f1-f0)/(1.0-UpCorr))*(correl-UpCorr);
				return retval;
			}
			else{  //correl=3D -1
				f0=3DOSpread( s1, s2,  strike,  r, vol1,  vol2, LowCorr,  tmat,  opttype=
,  rettype);
				f1=3DUnitCorrSpd( s1, s2,  strike,  r, vol1,  vol2, LowCorr,  tmat,  opt=
type,  rettype);
				retval=3Df1+((f0-f1)/(LowCorr+1.0))*(correl+1.0);
				return retval;
			}
		}
	}
}







=20
double OSpread(double s1, double s2, double strike, double r,
			   double vol1, double vol2,=20
			   double correl, double tmat, int opttype, int rettype){

	double retval, premium, up, down, rem,rem1,rem2, delta;
	double q1, q2;
	int flip=3D0;

	q1=3Dq2=3Dr;




// flip call to put
    if(strike<0.0){   =20
		strike=3D-strike;
	    rem=3Ds1; s1=3Ds2; s2=3Drem;
		rem=3Dvol1; vol1=3Dvol2; vol2=3Drem;
		rem=3Dq1; q1=3Dq2; q2=3Drem;
		opttype=3D1-opttype;
		flip=3D1;
	}




// populate the structure=20

	setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat);

    if(opttype){ //call

	switch (rettype){
	case 0:	=20
	   retval=3DS.disc*gauherInt(Ffunc0);
 	   return (retval/SQRTPI);
	case 2:
		if(!flip){
	     retval=3DS.disc*gauherInt(Ffunc1);
 	     return (retval/SQRTPI);
		}else{
		 retval=3DS.disc*gauherInt(Ffunc2);
 	     return (retval/SQRTPI);
		}

	case 1:
		if(!flip){
		 retval=3DS.disc*gauherInt(Ffunc2);
 		 return (retval/SQRTPI);
		}else{
		 retval=3DS.disc*gauherInt(Ffunc1);
 		 return (retval/SQRTPI);
		}
		=20
	case 4:
	   if(!flip){
		retval=3DS.disc*gauherInt(Ffunc3);
 		return (retval/SQRTPI);
	   }else{
		retval=3DS.disc*gauherInt(Ffunc4);
 		return (retval/SQRTPI);
	   }
	=09
	case 3:
       if(!flip){
		retval=3DS.disc*gauherInt(Ffunc4);
 		return (retval/SQRTPI);
	   }else{
		retval=3DS.disc*gauherInt(Ffunc3);
 		return (retval/SQRTPI);
	   }

	case 5: // cross gamma
		setup(s1,s2+EPSD,strike,r,q1,q2,vol1,vol2,correl,tmat);
		up=3DS.disc*gauherInt(Ffunc2)/SQRTPI;
		setup(s1,s2-EPSD,strike,r,q1,q2,vol1,vol2,correl,tmat);
		down=3DS.disc*gauherInt(Ffunc2)/SQRTPI;
		retval=3D (up-down)/(2.0*EPSD);	  =20
 		return retval;

	case 6:  //vega1
	   if(!flip){
		setup(s1,s2,strike,r,q1,q2,vol1+EPSD,vol2,correl,tmat);
		up=3DS.disc*gauherInt(Ffunc0);
		setup(s1,s2,strike,r,q1,q2,vol1-EPSD,vol2,correl,tmat);
		down=3DS.disc*gauherInt(Ffunc0);
		retval=3D (up-down)/(2.0*EPSD);	  =20
 		return (retval/SQRTPI);
	   }else{
	    setup(s1,s2,strike,r,q1,q2,vol1,vol2+EPSD,correl,tmat);
	    up=3DS.disc*gauherInt(Ffunc0);
	    setup(s1,s2,strike,r,q1,q2,vol1,vol2-EPSD,correl,tmat);
	    down=3DS.disc*gauherInt(Ffunc0);
	    retval=3D (up-down)/(2.0*EPSD);	  =20
 	    return (retval/SQRTPI);
	   }

	case 7:	 //vega2
	   if(!flip){
		setup(s1,s2,strike,r,q1,q2,vol1,vol2+EPSD,correl,tmat);
		up=3DS.disc*gauherInt(Ffunc0);
		setup(s1,s2,strike,r,q1,q2,vol1,vol2-EPSD,correl,tmat);
		down=3DS.disc*gauherInt(Ffunc0);
		retval=3D (up-down)/(2.0*EPSD);	  =20
 		return (retval/SQRTPI);
	   }else{
		setup(s1,s2,strike,r,q1,q2,vol1+EPSD,vol2,correl,tmat);
		up=3DS.disc*gauherInt(Ffunc0);
		setup(s1,s2,strike,r,q1,q2,vol1-EPSD,vol2,correl,tmat);
		down=3DS.disc*gauherInt(Ffunc0);
		retval=3D (up-down)/(2.0*EPSD);	  =20
 		return (retval/SQRTPI);
	   }


	case 8: //eta
	   setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl+1.e-8,tmat);
	   up=3DS.disc*gauherInt(Ffunc0);
	   setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl-1.e-8,tmat);
	   down=3DS.disc*gauherInt(Ffunc0);
	   retval=3D (up-down)/(2.0*1.e-8);	  =20
 	   return (retval/SQRTPI);

	case 9: //rho
	   premium=3DS.disc*gauherInt(Ffunc0)/SQRTPI;
	   rem=3DS.disc;
	   setup(s1,s2,strike,r+EPSD,q1+EPSD,q2+EPSD,vol1,vol2,correl,tmat);
	   up=3DgauherInt(Ffunc0);
	   setup(s1,s2,strike,r-EPSD,q1-EPSD,q2-EPSD,vol1,vol2,correl,tmat);
	   down=3DgauherInt(Ffunc0);
	   retval=3D (up-down)/(2.0*EPSD);	  =20
 	   return (rem*retval/SQRTPI)-S.tmat*premium;

	case 10: //theta
	   premium=3DS.disc*gauherInt(Ffunc0)/SQRTPI;
	   rem=3DS.disc;
	   setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat+EPSD);
	   up=3DgauherInt(Ffunc0);
	   setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat-EPSD);
	   down=3DgauherInt(Ffunc0);
	   retval=3D (up-down)/(2.0*EPSD);	  =20
 	   return -(rem*(retval/SQRTPI)-S.r*premium);

	case 11: // charm 1
	   if(!flip){
	    delta=3DS.disc*gauherInt(Ffunc2)/SQRTPI;
	    rem=3DS.disc;
	    setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat+EPSD);
	    up=3DgauherInt(Ffunc2);
	    setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat-EPSD);
	    down=3DgauherInt(Ffunc2);
	    retval=3D (up-down)/(2.0*EPSD);	  =20
 	    return -(rem*retval/SQRTPI-S.r*delta);
	   }else{
	    delta=3DS.disc*gauherInt(Ffunc1)/SQRTPI;
	    rem=3DS.disc;
	    setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat+EPSD);
	    up=3DgauherInt(Ffunc1);
	    setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat-EPSD);
	    down=3DgauherInt(Ffunc1);
	    retval=3D (up-down)/(2.0*EPSD);	  =20
 	    return -(rem*retval/SQRTPI-S.r*delta);
	   }

	case 12:// charm 2	   delta=3DS.disc*gauherInt(Ffunc2);
       if(!flip){
		delta=3DS.disc*gauherInt(Ffunc1)/SQRTPI;
		rem=3DS.disc;
		setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat+EPSD);
		up=3DgauherInt(Ffunc1);
		setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat-EPSD);
		down=3DgauherInt(Ffunc1);
		retval=3D (up-down)/(2.0*EPSD);	  =20
 		return -(rem*retval/SQRTPI-S.r*delta);
	   }else{
		delta=3DS.disc*gauherInt(Ffunc2)/SQRTPI;
	    rem=3DS.disc;
	    setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat+EPSD);
	    up=3DgauherInt(Ffunc2);
	    setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat-EPSD);
	    down=3DgauherInt(Ffunc2);
	    retval=3D (up-down)/(2.0*EPSD);	  =20
 	    return -(rem*retval/SQRTPI-S.r*delta);
	   }

	default:
		return ERR_RETURN;
	}
	}else
	{
	switch (rettype){
	case 0:	=20
	   retval=3DS.disc*gauherInt(Ffunc0);
 	   return (retval/SQRTPI)-S.expq2*S.s2+S.expq1*S.s1+S.disc*S.strike;
	case 2:
	   if(!flip){
		retval=3DS.disc*gauherInt(Ffunc1);
 		return (retval/SQRTPI)+S.expq2;
	   }else{
		 retval=3DS.disc*gauherInt(Ffunc2);
 	     return (retval/SQRTPI)-S.expq1;
	   }
	case 1:
	   if(!flip){
		 retval=3DS.disc*gauherInt(Ffunc2);
 	     return (retval/SQRTPI)-S.expq1;
	   }else{
		retval=3DS.disc*gauherInt(Ffunc1);
 		return (retval/SQRTPI)+S.expq2;
	   }

	case 4:
	   if(!flip){
		retval=3DS.disc*gauherInt(Ffunc3);
 		return (retval/SQRTPI);
	   }else{
		retval=3DS.disc*gauherInt(Ffunc4);
 		return (retval/SQRTPI);
	   }

	case 3:
	   if(!flip){
		retval=3DS.disc*gauherInt(Ffunc4);
 		return (retval/SQRTPI);
	   }else{
		retval=3DS.disc*gauherInt(Ffunc3);
 		return (retval/SQRTPI);
	   }

	case 5: // cross gamma
	 =20
		setup(s1,s2+EPSD,strike,r,q1,q2,vol1,vol2,correl,tmat);
		up=3DS.disc*gauherInt(Ffunc2)/SQRTPI;  //note: Ffunc2 refers to Delta1 in =
Enron's convension
		setup(s1,s2-EPSD,strike,r,q1,q2,vol1,vol2,correl,tmat);
		down=3DS.disc*gauherInt(Ffunc2)/SQRTPI;
		retval=3D (up-down)/(2.0*EPSD);	  =20
 		return retval;

	case 6:  //vega1
	   if(!flip){
		setup(s1,s2,strike,r,q1,q2,vol1+EPSD,vol2,correl,tmat);
	    up=3DS.disc*gauherInt(Ffunc0);
	    setup(s1,s2,strike,r,q1,q2,vol1-EPSD,vol2,correl,tmat);
	    down=3DS.disc*gauherInt(Ffunc0);
	    retval=3D (up-down)/(2.0*EPSD);	  =20
 	    return (retval/SQRTPI);
	   }else{
	    setup(s1,s2,strike,r,q1,q2,vol1,vol2+EPSD,correl,tmat);
		up=3DS.disc*gauherInt(Ffunc0);
		setup(s1,s2,strike,r,q1,q2,vol1,vol2-EPSD,correl,tmat);
		down=3DS.disc*gauherInt(Ffunc0);
		retval=3D (up-down)/(2.0*EPSD);	  =20
 		return (retval/SQRTPI);
	   }

	case 7:	 //vega2
	   if(!flip){
		setup(s1,s2,strike,r,q1,q2,vol1,vol2+EPSD,correl,tmat);
		up=3DS.disc*gauherInt(Ffunc0);
		setup(s1,s2,strike,r,q1,q2,vol1,vol2-EPSD,correl,tmat);
		down=3DS.disc*gauherInt(Ffunc0);
		retval=3D (up-down)/(2.0*EPSD);	  =20
 		return (retval/SQRTPI);
	   }else{
		setup(s1,s2,strike,r,q1,q2,vol1+EPSD,vol2,correl,tmat);
	    up=3DS.disc*gauherInt(Ffunc0);
	    setup(s1,s2,strike,r,q1,q2,vol1-EPSD,vol2,correl,tmat);
	    down=3DS.disc*gauherInt(Ffunc0);
	    retval=3D (up-down)/(2.0*EPSD);	  =20
 	    return (retval/SQRTPI);
	   }
	=09
	case 8: //eta
	   setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl+1.e-8,tmat);
	   up=3DS.disc*gauherInt(Ffunc0);
	   setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl-1.e-8,tmat);
	   down=3DS.disc*gauherInt(Ffunc0);
	   retval=3D (up-down)/(2.0*1.e-8);	  =20
 	   return (retval/SQRTPI);

	case 9: //rho
	   premium=3DS.disc*gauherInt(Ffunc0)/SQRTPI;
	   rem=3DS.disc; rem1=3DS.expq1; rem2=3DS.expq2;
	   setup(s1,s2,strike,r+EPSD,q1+EPSD,q2+EPSD,vol1,vol2,correl,tmat);
	   up=3DgauherInt(Ffunc0);
	   setup(s1,s2,strike,r-EPSD,q1-EPSD,q2-EPSD,vol1,vol2,correl,tmat);
	   down=3DgauherInt(Ffunc0);
	   retval=3D (up-down)/(2.0*EPSD);	  =20
 	   return (rem*retval/SQRTPI)-S.tmat*premium +\
		       S.tmat*(rem2*S.s2-rem1*S.s1-rem*S.strike);=20

	case 10: //theta
	   premium=3DS.disc*gauherInt(Ffunc0)/SQRTPI;
	   rem=3DS.disc; rem1=3DS.expq1; rem2=3DS.expq2;
	   setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat+EPSD);
	   up=3DgauherInt(Ffunc0);
	   setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat-EPSD);
	   down=3DgauherInt(Ffunc0);
	   retval=3D (up-down)/(2.0*EPSD);	  =20
 	   return -(rem*(retval/SQRTPI)-S.r*premium)- \
		      S.r*(rem2*S.s2-rem1*S.s1-rem*S.strike);
	case 11: // charm 1
	   if(!flip){
		delta=3DS.disc*gauherInt(Ffunc2)/SQRTPI;
		rem=3DS.disc; rem1=3DS.expq1;=20
		setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat+EPSD);
		up=3DgauherInt(Ffunc2);
		setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat-EPSD);
		down=3DgauherInt(Ffunc2);
		retval=3D (up-down)/(2.0*EPSD);	  =20
 		return -(rem*retval/SQRTPI-S.r*delta) - S.q1*rem1;
	   }else{
		delta=3DS.disc*gauherInt(Ffunc1)/SQRTPI;
		rem=3DS.disc; rem2=3DS.expq2;
		setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat+EPSD);
		up=3DgauherInt(Ffunc1);
		setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat-EPSD);
		down=3DgauherInt(Ffunc1);
		retval=3D (up-down)/(2.0*EPSD);	  =20
 		return -(rem*retval/SQRTPI-S.r*delta)+S.q2*rem2;
	   }

	case 12:// charm 2	=20
	   if(!flip){
		delta=3DS.disc*gauherInt(Ffunc1)/SQRTPI;
		rem=3DS.disc; rem2=3DS.expq2;
		setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat+EPSD);
		up=3DgauherInt(Ffunc1);
		setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat-EPSD);
		down=3DgauherInt(Ffunc1);
		retval=3D (up-down)/(2.0*EPSD);	  =20
 		return -(rem*retval/SQRTPI-S.r*delta)+S.q2*rem2;
	   }else{
		delta=3DS.disc*gauherInt(Ffunc2)/SQRTPI;
		rem=3DS.disc; rem1=3DS.expq1;=20
		setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat+EPSD);
		up=3DgauherInt(Ffunc2);
		setup(s1,s2,strike,r,q1,q2,vol1,vol2,correl,tmat-EPSD);
		down=3DgauherInt(Ffunc2);
		retval=3D (up-down)/(2.0*EPSD);	  =20
 		return -(rem*retval/SQRTPI-S.r*delta) - S.q1*rem1;
	   }

	default:
		return ERR_RETURN;
	}
    }


}


double lognorm(double s1T){
	double temp;
	temp=3D(log(s1T) - S.m1);
	return exp(-temp*temp/(2.0*S.volt*S.volt))/(SQRT2PI*S.volt)/s1T;
}

double norm(double x){
	return exp(-x*x*0.5)/SQRT2PI;
}

double dnorm(double x){
	return -x*exp(-x*x*0.5)/SQRT2PI;
}






double Ffunc0(double s1T){
=09
	double x1, x2, M2, retval;
	double Nx1, Nx2,temp;


	M2 =3D S.m2+S.correl*S.vol2*( log(s1T)-S.m1 )/S.vol1;

	temp=3Dlog(DMAX( (s1T+S.strike),0.0)  );

	x1=3D(M2+S.vol*S.vol-temp)/S.vol;
	x2=3D(M2-temp)/S.vol;

	Nx1=3Dcumnorm(x1);
	Nx2=3Dcumnorm(x2);

	retval=3D S.expA*S.s2*pow(s1T/S.s1, S.temp)*Nx1  \
		    -(s1T+S.strike)*Nx2;

	return retval;

}

double Ffunc1(double s1T){  //delta1
=09
	double retval;
	double Nx1,DNx1;
	double Nx2,DNx2, x2;

	double exp1,exp2,exp3, c, c2, c3;

    c=3D-log(DMAX( (s1T+S.strike),0.0));
	c2=3Dpow(s1T/S.s1,S.temp);
	c3=3Dsqrt((1-S.correl*S.correl)*S.tmat);

    exp1=3Dlog(s1T)-S.m1;
	exp2=3D(S.m2+S.temp*exp1+S.vol*S.vol+c)/S.vol;
	exp3=3DS.expA;

	Nx1=3Dcumnorm(exp2);
	DNx1=3Dnorm(exp2);

	x2=3D(S.m2+S.temp*exp1+c)/S.vol;
	Nx2=3Dcumnorm(x2);
	DNx2=3Dnorm(x2);



	retval=3D (-exp3*S.s2*c2*S.correl*S.vol2*Nx1/(S.vol1*S.s1) - \
		        exp3*S.s2*c2*DNx1*S.correl/(S.vol1*S.s1*c3) + \
				(s1T+S.strike)*DNx2*S.correl/(S.vol1*S.s1*c3) )*
				lognorm(s1T);
	retval+=3D(exp3*S.s2*c2*Nx1-(s1T+S.strike)*Nx2)*exp1*lognorm(s1T)/(S.s1*S.v=
ol1*S.vol1*S.tmat);


	return retval/lognorm(s1T);

}

double Ffunc2(double s1T){  //delta2
=09
	double retval;
	double Nx1,DNx1;
	double Nx2,DNx2, x2;

	double exp1,exp2,exp3, c, c2, c3;

    c=3D-log(DMAX( (s1T+S.strike),0.0));
	c2=3Dpow(s1T/S.s1,S.temp);
	c3=3Dsqrt((1-S.correl*S.correl)*S.tmat);

    exp1=3Dlog(s1T)-S.m1;
	exp2=3D(S.m2+S.temp*exp1+S.vol*S.vol+c)/S.vol;
	exp3=3DS.expA;

	Nx1=3Dcumnorm(exp2);
	DNx1=3Dnorm(exp2);

	x2=3D(S.m2+S.temp*exp1+c)/S.vol;
	Nx2=3Dcumnorm(x2);
	DNx2=3Dnorm(x2);



	retval=3D (exp3*c2*Nx1 +\
		        exp3*c2*DNx1/(S.vol2*c3) - \
				(s1T+S.strike)*DNx2/(S.vol2*S.s2*c3) );
//				*lognorm(s1T);


	return retval;  // /lognorm(s1T);

}

double Ffunc3(double s1T){  //gamma1
=09
	double retval;
	double Nx1,DNx1,DDNx1;
	double Nx2,DNx2,DDNx2;

	double exp1,exp2,exp4,exp5,exp6,exp7, c, c2, c3,c4,c5;

    c=3D-log(DMAX( (s1T+S.strike),0.0));
	c2=3Dpow(s1T/S.s1,S.temp);
	c3=3Dsqrt((1-S.correl*S.correl)*S.tmat);
	c4=3Dpow(S.volt,3.0);
	c5=3Dpow(S.volt,5.0);


    exp1=3Dlog(s1T)-S.m1;
	exp2=3Dexp(-0.5*exp1*exp1/(S.volt*S.volt));
	exp4=3D(S.m2+S.temp*exp1+c)/S.vol;
	exp5=3D(S.m2+S.temp*exp1+S.vol*S.vol+c)/(S.vol);
	exp6=3DS.expA;
=09
 =20
	Nx1=3Dcumnorm(exp5);
	DNx1=3Dnorm(exp5);
	DDNx1=3Ddnorm(exp5);

	Nx2=3Dcumnorm(exp4);
	DNx2=3Dnorm(exp4);
	DDNx2=3Ddnorm(exp4);

	exp7=3Dexp6*S.s2*c2*Nx1-(s1T+S.strike)*Nx2;


	retval=3D(
		   S.temp*(1+S.temp)*exp6*S.s2*c2*Nx1/(S.s1*S.s1) + \
		   2.0*exp6*S.s2*c2*S.correl*S.correl*S.vol2*DNx1/(S.vol1*S.vol1*S.s1*S.s1=
*c3)+\
		   exp6*S.s2*c2*DDNx1*S.correl*S.correl/(S.s1*S.s1*S.vol1*S.vol1*c3*c3)+\
		   exp6*S.s2*c2*DNx1*S.correl/(S.s1*S.s1*S.vol1*c3) - \
		   (s1T+S.strike)*DDNx2*S.correl*S.correl/(S.s1*S.s1*S.vol1*S.vol1*c3*c3)-=
\
		   (s1T+S.strike)*DNx2*S.correl/(S.s1*S.s1*S.vol1*c3)
		   ) * exp2/(SQRT2PI*S.volt*s1T)+ \
		   (
		   -exp6*S.s2*c2*S.correl*S.vol2*Nx1/(S.vol1*S.s1) -\
		   exp6*S.s2*c2*DNx1*S.correl/(S.s1*S.vol1*c3) +\
		   (s1T+S.strike)*DNx2*S.correl/(S.s1*S.vol1*c3) \
		   )*exp1*exp2*2.0/(c4*SQRT2PI*S.s1*s1T);
=09
	retval+=3D -exp7*exp2/(S.s1*S.s1*c4*SQRT2PI*s1T)   \
		     -exp7*exp1*exp2/(S.s1*S.s1*c4*SQRT2PI*s1T) \
		     +exp7*exp1*exp1*exp2/(S.s1*S.s1*c5*SQRT2PI*s1T);

=09

	return retval/lognorm(s1T);

}

double Ffunc4(double s1T){  //gamma2
=09
	double retval;
	double Nx1,DNx1,DDNx1;
	double Nx2,DNx2,DDNx2;

	double exp1,exp4,exp5, c, c2;

    c=3D-log(DMAX( (s1T+S.strike),0.0));
	c2=3Dpow(s1T/S.s1,S.temp);



    exp1=3Dlog(s1T)-S.m1;
	exp4=3D(S.m2+S.temp*exp1+c)/S.vol;
	exp5=3D(S.m2+S.temp*exp1+S.vol*S.vol+c)/(S.vol);

=09
 =20
	Nx1=3Dcumnorm(exp5);
	DNx1=3Dnorm(exp5);
	DDNx1=3Ddnorm(exp5);

	Nx2=3Dcumnorm(exp4);
	DNx2=3Dnorm(exp4);
	DDNx2=3Ddnorm(exp4);


	retval=3DS.expA*c2*(DNx1/(S.s2*S.vol)+DDNx1/(S.s2*S.vol*S.vol)) \
		   -(s1T+S.strike)*DDNx2/(S.s2*S.s2*S.vol*S.vol)\
		   +(s1T+S.strike)*DNx2/(S.s2*S.s2*S.vol);


	return retval;

}


#if 0
double Ffunc5(double s1T){  //vega1   not right!
=09
	double retval;
	double Nx1,DNx1;
	double Nx2,DNx2;

	double exp1,exp4,exp5, c, c2, c3;

    c=3D-log(DMAX( (s1T+S.strike),0.0));
	c2=3Dpow(s1T/S.s1,S.temp);
	c3=3Dsqrt((1-S.correl*S.correl)*S.tmat);



    exp1=3Dlog(s1T)-S.m1;
	exp4=3D(S.m2+S.temp*exp1+c)/S.vol;
	exp5=3D(S.m2+S.temp*exp1+S.vol*S.vol+c)/S.vol;

=09
	Nx1=3Dcumnorm(exp5);
	DNx1=3Dnorm(exp5);

	Nx2=3Dcumnorm(exp4);
	DNx2=3Dnorm(exp4);

	retval=3D((S.r-S.q1)*S.temp/S.vol1+0.5*S.temp*S.vol1*(1.0-S.temp)+\
		0.5*S.vol1*S.temp*S.temp)*S.expA*S.s2*c2*Nx1- S.expA*S.s2*c2* \
		S.temp*log(s1T/S.s1)*Nx1/S.vol1+\
		S.expA*S.s2*c2*DNx1*S.temp*S.vol1*(S.tmat-exp1/(S.vol1*S.vol1) )/S.vol;
	retval +=3D -(s1T+S.strike)*DNx2*S.temp*S.vol1*(S.tmat-exp1/(S.vol1*S.vol1)=
 )/S.vol;

	retval +=3D (S.expA*S.s2*c2*Nx1-(s1T+S.strike)*Nx2)*(-exp1/S.vol1+exp1*exp1=
/(pow(S.vol1,3.0)*S.tmat));
    retval +=3D -(S.expA*S.s2*c2*Nx1-(s1T+S.strike)*Nx2)/S.vol1;


	return retval;

}

double Ffunc6(double s1T){  //vega2  =20
=09
	double retval;
	double Nx1,DNx1;
	double Nx2,DNx2;

	double exp1,exp4,exp5, c, c2, c3;

    c=3D-log(DMAX( (s1T+S.strike),0.0));
	c2=3Dpow(s1T/S.s1,S.temp);
	c3=3Dsqrt((1-S.correl*S.correl)*S.tmat);



    exp1=3Dlog(s1T)-S.m1;
	exp4=3D(S.m2+S.temp*exp1+c)/S.vol;
	exp5=3D(S.m2+S.temp*exp1+S.vol*S.vol+c)/(S.vol);

=09
 =20
	Nx1=3Dcumnorm(exp5);
	DNx1=3Dnorm(exp5);

	Nx2=3Dcumnorm(exp4);
	DNx2=3Dnorm(exp4);



	retval=3D((S.q1-S.r)*S.correl/S.vol1+0.5*S.correl*S.vol1*(1-S.temp)-0.5*S.c=
orrel*S.correl*S.vol2)\
		    *S.expA*S.s2*c2*Nx1 + S.expA*S.s2*c2*S.correl*log(s1T/S.s1)*Nx1/S.vol1=
 +\
            S.expA*S.s2*c2*DNx1*((-S.vol2*S.tmat+S.correl*exp1/S.vol1+2.0*S.=
vol*c3)/S.vol -\
			exp5/(S.vol2*S.vol)) -\
			(s1T+S.strike)*DNx2*((-S.vol2*S.tmat+S.correl*exp1/S.vol1)/S.vol-\
			exp4/S.vol2 );


	return retval;

}

#endif






double gauherInt(double (*func)()){
	double y, sum;
//taken from 175 points gauher output, trancated +- 4.57 stdev
static double x[]=3D{
4.573341,
4.400629E+00,
4.228311E+00,
4.056370E+00,
3.884786E+00,
3.713542E+00,
3.542620E+00,
3.372004E+00,
3.201676E+00,
3.031621E+00,
2.861821E+00,
2.692262E+00,
2.522928E+00,
2.353804E+00,
2.184874E+00,
2.016124E+00,
1.847539E+00,
1.679105E+00,
1.510808E+00,
1.342634E+00,
1.174568E+00,
1.006597E+00,
8.387076E-01,
6.708853E-01,
5.031169E-01,
3.353889E-01,
1.676877E-01,
2.242078E-44,
-1.676877E-01,
-3.353889E-01,
-5.031169E-01,
-6.708853E-01,
-8.387076E-01,
-1.006597E+00,
-1.174568E+00,
-1.342634E+00,
-1.510808E+00,
-1.679105E+00,
-1.847539E+00,
-2.016124E+00,
-2.184874E+00,
-2.353804E+00,
-2.522928E+00,
-2.692262E+00,
-2.861821E+00,
-3.031621E+00,
-3.201676E+00,
-3.372004E+00,
-3.542620E+00,
-3.713542E+00,
-3.884786E+00,
-4.056370E+00,
-4.228311E+00,
-4.400629E+00,
-4.573341E+00
};
static double w[]=3D{
1.426828E-10,
6.706174E-10,
2.959809E-09,
1.227385E-08,
4.784717E-08,
1.754311E-07,
6.052523E-07,
1.965797E-06,
6.013053E-06,
1.732909E-05,
4.706964E-05,
1.205425E-04,
2.911473E-04,
6.634207E-04,
1.426557E-03,
2.895505E-03,
5.548767E-03,
1.004151E-02,
1.716394E-02,
2.771569E-02,
4.228569E-02,
6.096484E-02,
8.306826E-02,
1.069803E-01,
1.302329E-01,
1.498695E-01,
1.630425E-01,
1.676855E-01,
1.630425E-01,
1.498695E-01,
1.302329E-01,
1.069803E-01,
8.306826E-02,
6.096484E-02,
4.228569E-02,
2.771569E-02,
1.716394E-02,
1.004151E-02,
5.548767E-03,
2.895505E-03,
1.426557E-03,
6.634207E-04,
2.911473E-04,
1.205425E-04,
4.706964E-05,
1.732909E-05,
6.013053E-06,
1.965797E-06,
6.052523E-07,
1.754311E-07,
4.784717E-08,
1.227385E-08,
2.959809E-09,
6.706174E-10,
1.426828E-10

};=20

	int i;
	double temp;


    sum=3D0.0;
	for (i=3D0;i<NP;i++){
		y =3D exp(SQRTTWO*x[i]*S.volt+ S.m1);
		temp =3Dfunc(y);
		sum +=3D w[i]*temp;
	}


	return sum;
}








--------------000506070003020302060604
Content-Type: text/plain; name="Nrutil.h"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Nrutil.h"

#ifndef _NR_UTILS_H_
#define _NR_UTILS_H_

static float sqrarg;
#define SQR(a) ((sqrarg=3D(a)) =3D=3D 0.0 ? 0.0 : sqrarg*sqrarg)

static double dsqrarg;
#define DSQR(a) ((dsqrarg=3D(a)) =3D=3D 0.0 ? 0.0 : dsqrarg*dsqrarg)

static double dmaxarg1,dmaxarg2;
#define DMAX(a,b) (dmaxarg1=3D(a),dmaxarg2=3D(b),(dmaxarg1) > (dmaxarg2) ?\
        (dmaxarg1) : (dmaxarg2))

static double dminarg1,dminarg2;
#define DMIN(a,b) (dminarg1=3D(a),dminarg2=3D(b),(dminarg1) < (dminarg2) ?\
        (dminarg1) : (dminarg2))

static float maxarg1,maxarg2;
#define FMAX(a,b) (maxarg1=3D(a),maxarg2=3D(b),(maxarg1) > (maxarg2) ?\
        (maxarg1) : (maxarg2))

static float minarg1,minarg2;
#define FMIN(a,b) (minarg1=3D(a),minarg2=3D(b),(minarg1) < (minarg2) ?\
        (minarg1) : (minarg2))

static long lmaxarg1,lmaxarg2;
#define LMAX(a,b) (lmaxarg1=3D(a),lmaxarg2=3D(b),(lmaxarg1) > (lmaxarg2) ?\
        (lmaxarg1) : (lmaxarg2))

static long lminarg1,lminarg2;
#define LMIN(a,b) (lminarg1=3D(a),lminarg2=3D(b),(lminarg1) < (lminarg2) ?\
        (lminarg1) : (lminarg2))

static int imaxarg1,imaxarg2;
#define IMAX(a,b) (imaxarg1=3D(a),imaxarg2=3D(b),(imaxarg1) > (imaxarg2) ?\
        (imaxarg1) : (imaxarg2))

static int iminarg1,iminarg2;
#define IMIN(a,b) (iminarg1=3D(a),iminarg2=3D(b),(iminarg1) < (iminarg2) ?\
        (iminarg1) : (iminarg2))

#define SIGN(a,b) ((b) >=3D 0.0 ? fabs(a) : -fabs(a))

#if defined(__STDC__) || defined(ANSI) || defined(NRANSI) /* ANSI */

void nrerror(char error_text[]);
float *vector(long nl, long nh);
int *ivector(long nl, long nh);
unsigned char *cvector(long nl, long nh);
unsigned long *lvector(long nl, long nh);
double *dvector(long nl, long nh);
float **matrix(long nrl, long nrh, long ncl, long nch);
double **dmatrix(long nrl, long nrh, long ncl, long nch);
int **imatrix(long nrl, long nrh, long ncl, long nch);
float **submatrix(float **a, long oldrl, long oldrh, long oldcl, long oldch,
	long newrl, long newcl);
float **convert_matrix(float *a, long nrl, long nrh, long ncl, long nch);
float ***f3tensor(long nrl, long nrh, long ncl, long nch, long ndl, long ndh=
);
void free_vector(float *v, long nl, long nh);
void free_ivector(int *v, long nl, long nh);
void free_cvector(unsigned char *v, long nl, long nh);
void free_lvector(unsigned long *v, long nl, long nh);
void free_dvector(double *v, long nl, long nh);
void free_matrix(float **m, long nrl, long nrh, long ncl, long nch);
void free_dmatrix(double **m, long nrl, long nrh, long ncl, long nch);
void free_imatrix(int **m, long nrl, long nrh, long ncl, long nch);
void free_submatrix(float **b, long nrl, long nrh, long ncl, long nch);
void free_convert_matrix(float **b, long nrl, long nrh, long ncl, long nch);
void free_f3tensor(float ***t, long nrl, long nrh, long ncl, long nch,
	long ndl, long ndh);

#else /* ANSI */
/* traditional - K&R */

void nrerror();
float *vector();
float **matrix();
float **submatrix();
float **convert_matrix();
float ***f3tensor();
double *dvector();
double **dmatrix();
int *ivector();
int **imatrix();
unsigned char *cvector();
unsigned long *lvector();
void free_vector();
void free_dvector();
void free_ivector();
void free_cvector();
void free_lvector();
void free_matrix();
void free_submatrix();
void free_convert_matrix();
void free_dmatrix();
void free_imatrix();
void free_f3tensor();

#endif /* ANSI */

#endif /* _NR_UTILS_H_ */

--------------000506070003020302060604
Content-Type: text/plain; name="Option.h"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Option.h"

/*------------------------------------------------------------------------
 *
 *    file: option.h
 *
 *	header file for option library.
 * =20
 *  All the option pricing functions called from ALL_WRAP.C declared here
 *  Modified for new IMPVOL routines
 *------------------------------------------------------------------------*/

#define ERR_RETVAL -999999999.12345

 enum OptionCalcs
{
        OPT_PREMIUM   =3D    0 ,
        OPT_DELTA     =3D    1 ,
        OPT_GAMMA     =3D    2 ,
        OPT_VEGA      =3D    3 ,
        OPT_RHO       =3D    4,
        OPT_THETA     =3D    5 ,
        OPT_DELTAVEGA =3D    6 ,
        OPT_CHARM     =3D    7 ,
		OPT_ETA       =3D    8=20
};=20
typedef struct Optrisk
	{
	double	*Premium;		/* option premium */
	double	*Delta;
	double	*Gamma;
	double	*Charm;
	double	*DeltaVega;
	double	*Vega;
	double	*Rho;
	double	*Theta;
	double	*Eta;			/* derivative w.r.t. correlation coefficient */
	} Optresults;


double	disc_semiann( 	double ,	/* semi-annual interest rate */
						double); 		/* time to expiry (years)    */
		=09
/*
 ***************************************************************************=
********************
 *							OPTION LIBRARY: FUNCTION PROTOTYPE DECLARATION
 ***************************************************************************=
********************
 */
void amer(double fwd, double strike, double time, double r, double q, double=
 vol, int callflag,=20
				Optresults *out, int dorisk);

/* American Option Pricing using Binomial Tree Method */
void amerb(double spot, double strike, double tenor, double rate,=20
		   double yield, double sigma, int callflag,=20
		   double *result, int dorisk, int steps);

double annualstrip2(double *s, double *k, double *r, double *vol, double *to=
setdate, double *begin,=20
			double *end, double *dailyqty,double annoptq, int callflag, int maxmon, i=
nt flag);
/*=20
 * 	s         spot prices    =20
 * 	k         strike prices =20
 * 	r         interest rates
 * 	vol       annualized volatilities
 *	tosetdate days to beginning of period (days to forward start)
 * 	begin     days from beginning of period to beginning of strip
 * 	end       days from beginning of period to end of strip
 *	dailyqty  maximum daily swing quantity
 *	annoptq   maximum annual option qty.
 *  callflag  1=3Dcall 0=3Dput
 *	maxmon    number of months in the strip
 *
 *	bidflag is tens digit of "flag"
 *	bidflag   0 =3D max value strip
 *	          1 =3D ave value strip
 *	          2 =3D min value strip
 *
 *	risk is ones unit of "flag" and indicates return value type:
 *	risk	0 =3D premium
 *			1 =3D delta of forward start options
 *			2 =3D delta of fixed strike  options
 */

void asianstrip2(	double fwd[],	/* forward prices 		*/
			double Strike,	/* strike price 		*/
			double IntRt, 	/* interest rate to expiry	*/
			double vol[],	/* volatilities			*/
			double Rho,	/* correlation			*/
			double SetPr,	/* average price to date	*/
			int    settles[], /* number of price samples for each asset */
			int    setdays, /* number of price samples determined */
			double ExpDt, 	/* calendar days to expiration	*/
			double begin[],	/* days to beging avg		*/
			double end[],	/* days to end avg		*/
			int    flag,	/* 0 =3D put, */
					/* 1 =3D call,*/
			int    nmonths, /* number of forward prices (assets) in avg */
			int    risk, 	 /* specify return value type, see enum above */
			Optresults *out);/* structure containing results	*/

double baskvol(
		double	*fwd,		/* vector of asset prices */
		double	*vol,		/* vector of asset price volatilities (annualized) */
		double	*mu,		/* vector of price drifts (risk neutral) (annualized) */
		double	*wgt,		/* vector of weightings in basket */
		double	*correl,	/* vector containing correlation matrix */
					/* Must be the full matrix even though the matrix is symmetric. */
		int	n,		/* number of assets in basket */
		double	exptime		/* time to expiration (Years) */
	);


double barrieropt( /*s, k, v, r, y, expdays, barr, reba, call, io, valtype) =
*/
		double		s,		/*   forward price of underlying  */
		double		k,		/*   strike of the option         */
		double		v,		/*   voltility 			*/
		double		r,		/*   interest rate  		*/
		double		y,		/*   yield 			*/
		double		expdays,/*   time to maturity (days)	*/
		double		barr,   /*   barrier price		*/
		double		reba,   /*   rebate  			*/
		int			call,	/*     1=3Dcall, 0=3Dput  		*/
		int			io,     /*     1=3Dknockin,  0=3Dknockout	*/
		int			valtype);/*   Type of return value:
							premium         0
                   			delta           1
                   			gamma           2
                   			vega            3
                   			rho             4
                   			theta           5
							vegadelta       6  */


void codopt( /* prem, s, k, r, q, vol, expd, call, rvalues ) */
		double 		prem,	/* Option contingent premium amount */
		double 		s,		/* price of Underlying 	*/
		double 		k,		/* Strike               */
		double 		r,		/* annualized cost of money, for discounting */
		double 		q,		/* annualized dividend yield (=3Dr for commodity */
		double 		vol,	/* annualized volatility, eg. 0.30 	*/
		double 		expd,	/* days until option expiration */
		int			call,	/* 1=3DCall, 0=3DPut  */
		double 		*rvalues);/* return values, see above explanation */


double codpremium( /*s, k, r, q, vol, expd, call) */
		double 		s,		/* price of Underlying 	*/
		double 		k,		/* Strike               */
		double 		r,		/* annualized cost of money, for discounting */
		double 		q,		/* annualized dividend yield (=3Dr for commodity */
		double 		vol,	/* annualized volatility, eg. 0.30 	*/
		double 		expd,	/* days until option expiration */
		int			call);	/* 1=3DCall, 0=3DPut  */


double compvopt(
		double S,		/* price of underlying */
		double xa,      /* strike price for receiving/putting the option at ta  */
      	double xb,		/* strike price for receiving/putting the underlying at t=
b */
      	double ta,		/* time to expiration of compound option (days) */
      	double tb,      /* time to expiration of underlying option (days)  */
       	double r,       /* risk free rate */
       	double q,       /* dividend yield  (=3Drisk free rate for futures) *=
/
   		double volab,   /* volatility of underlying at time "ta" */
    	double volb,    /* present  volatility of underlying */
		int	optype,		/* specifies type of compound option:
							1  Call on a Call
                            2  Put  on a Call
                            3  Call on a Put
                            4  Put  on a Put
                            5  implied vola 	*/

		int valtype);  /* 	premium		0
					delta		1
					gamma		2
					vega		3
					rho			4
					theta		5	( annualized )  */


double euroopt(double Fwd, double Strike, double ExpDt, double IntRt, double=
 Yield, double Vol,=20
			   int Callflag, int Index);
 /*	Calculates premium or risk parameters of an European option
 *
 * 	Fwd		spot price     =20
 * 	Strike  strike price  =20
 * 	ExpDt	time to exipration (years)
 * 	IntRt	annualized riskfree rate
 * 	Yield	continuous dividend yield
 * 	Vol		annualized volatility =20
 *	Callflag 1 for call and 0 for put
 *  Index	for  risk:
 *		 0  premium
 *	     1 	delta
 *	     2  gamma
 *	     3  vega
 *	     4 	commodity rho
 *	     5 	theta
 *	     6 	rho (not valid for r=3Dq)
 *	     7 	d(delta)/d(vol)
 *	     8 	charm:  d(delta)/dt
 */


double eurostrip(double s, double k, double period, double start, double end=
, double r, double q,=20
				 double vol, int callflag, int risk );
/* 	Strip of Daily Call Options
 * 	s         spot price     =20
 * 	d         strike price  =20
 *	period    days to beginning of period
 * 	start     days from beginning of period to beginning of strip
 * 	end       days from beginning of period to end of strip
 * 	r         annualized riskfree rate
 * 	q         annualized dividend rate
 * 	vol       annualized volatility =20
 *  callflag  1=3Dcall 0=3Dput
 *
 *  risk 0  premium
 *	     1 	delta
 *	     2  gamma
 *	     3  vega
 *	     4 	commodity rho
 *	     5 	theta
 *	     6 	delta on forward strike date
 */

void FastAsian(double s, double k, double r, double volin, double set, doubl=
e expd,
				double sta, double toend, double tradedays, int callflag, double *rvalue=
s );
/*   ASIAN CALL OPTION WITH ONE CONTINUOUS AVERAGING PERIOD
=20
      rvalues[] =3D  call premium,   [0]
                   delta           [1]
                   gamma           [2]
                   lambda (vega)   [3]
                   rho             [4]
                   theta           [5]
                   d(delta)/d(vol) [6]
*/

double ImpVol_Amerb(double prem, double spot, double strike, double tenor,=20
		   double rate, double yield, double maxvol, int callflag, int steps,=20
		   double accuracy);
/* Implied Volatility for the American Option using Binomial Tree */

double impeuro(int putcallind, double actual_premium, double spot, double st=
rike,
	     double tenor, double rate, double yield, double maxvol, double accurac=
y, int maxiter);
/* Implied Volatility for the European Options=20
putcallind 0->put, 1->call 2->straddle=20
*/

void lookback( /* s, k, r, q, vol, expd, call, daysyr, rvalues) */
	/*  LookBack Option in Continuous Time */
		double 	s,		/* price of Underlying 	*/
		double 	k,		/* Strike               */
		double 	r,		/* annualized cost of money, for discounting */
		double 	q,		/* annualized dividend yield (=3Dr for commodity */
		double 	vol,	/* annualized volatility, eg. 0.30 	*/
		double 	expd,	/* days until option expiration */
		int		call,	/* 1=3DCall, 0=3DPut  */
		double 	daysyr,	/* number of days in an effective year  */
		double 	rvalues[]);/*value           [0]
							delta           [1]
							gamma           [2]
                   			lambda (vega)   [3]
                   			rho             [4]
                   			theta           [5]
                   			dDdV            [6]  not implemented */


/* used in XCOL: Option on a collar strip */
double opoptree( /* s, rates, vol2, tmat2, vol, spread, tmat, cap, floor, r,=
 nsteps, nmonths) */
		double	*s,			/* beginning prices			*/
		double	*rates,		/* interest rates 			*/
		double	*vol2,		/* volatility at time "tmat"		*/
		double	*tmat2,		/* time to maturity of underlying option (years) */
		double	vol,		/* present volatility			*/
		double	spread,		/* used as offer-mid and mid-bid vol    */
		double	tmat,		/* time to maturity of overlying option	 (years) */
		double	cap,    	/* cap strike price			*/
		double	floor, 		/* floor strike  price			*/
		double	r,			/* interest rate			*/
		int		nsteps,		/* number of time steps			*/
		int		nmonths);	/* number of months in collar		*/


/* spread option where the 1-D integration is done using Gaussian Quadrature=
 */
/* modified for new more accurate integration method Dec-98 Anjam/Zimin */

double Spread( double Xo, double Yo, double Ko, double intr,
			 double volX, double volY, double rho,
			 double time, int Callflag, int Sens);
/* time is # of days */

double rainbowopt(
		double sa,		/* price of underlying */
		double sb,      /* price of underlying */
       	double K,       /* strike price */
       	double r,       /* interest rate */
      	double qa,      /* yield of underlying a */
      	double qb,      /* yield of underlying b */
 		double expdays, /* time to expiration (days)  */
    	double vola,    /* volatility of Sa */
    	double volb,    /* volatility of Sb */
    	double corr,    /* correlation of sa and sb    */
		int opttype,	/* Option type:
                                1  Max( 0, max[sa,sb]-K )   "call on max of =
two assets"
                                2  Max( 0, min[sa,sb]-K )   "call on min of =
two assets"
                                3  Max( 0, K-max[sa,sb] )   "put  on max of =
two assets"
                                4  Max( 0, K-min[sa,sb] )   "put  on min of =
two assets"
                                5  Max( 0, sb-sa )          "option to excha=
nge sb for sa"
                                6  Max( 0, max[sa,sb,K] )   "max of two asse=
ts or cash"    */
		int valtype);	/* premium         0
				   delta1          1
                   delta2          2
                   gamma1          3
                   gamma2          4
                   gamma12         5
                   vega1           6
                   vega2           7
                   eta             8
                   rho             9
                   theta           10  */
=20

double strikeroot(double brk, double fwd, double expd, double r, double q, d=
ouble vol, int callput);
/* for Pricing a Boston Option */

/* spread option assuming the spread is normally distributed */

double wcxspread(
	double F, 		/* forward price for spread */
	double K, 		/* strike price */
	double r,		/* risk free rate */
	double sigma, 		/* spread annualized standard deviation */
	double t, 		/* time (years) to option expiration */
	int flag_cp,		/* 1=3Dcall, 0=3Dput */=20
	int flag_r		/* flag for return value */
	);

/* New AsianStrip model added Feb/Mar 2000 */

double AsianStrip(
			double *fwd,	 /* forward prices 			*/
			double Strike,	 /* strike price 			*/
			double IntRt, 	 /* interest rate to expiry	*/
			double *vol,	 /* volatilities			*/
			double Rho,		 /* correlation				*/
			double SetPr,	 /* average price to date	*/
			int    *settles, /* number of price samples for each asset */
			int    setdays,	 /* number of price samples determined	   */
			double ExpDt, 	 /* calendar days to expiration		*/
			double *begin,	 /* days to beging avg				*/
			double *end,	 /* days to end avg					*/
			int    flag,	 /* 0 =3D put, 1 =3D call,				*/
			int    nmonths,	 /* number of forward prices in avg	*/
			int    risk, 	 /* specify return value type		*/
			int	   retmonth	 /* return month for greeks			*/
						   );
--------------000506070003020302060604
Content-Type: text/plain; name="Optoptvo.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Optoptvo.c"

/*-------------------------------------------------------


	function optoptvol()

	Calculates premium of option on an option=20
	using a two point term structure of volatility.

	V0.0 2aug1993   An intuitive extension of the compound option model. Not ve=
rified. -psg
	V1.0 23aug93    changed units of input time from years to days.  -psg


-------------------------------------------------------*/

#include <math.h>
#include <stdio.h>

#define		DAYSYR		365.35

double optoptvol(S, xa, xb, daysa, daysb, r, q, volab, volb, type)

double S,			/* price of underlying */
      xa,			/* strike price for receiving/putting the option at ta  */
      xb,			/* strike price for receiving/putting the underlying at tb */
   daysa,			/* time to expiration of compound option (days) */
   daysb,			/* time to expiration of underlying option (days)  */
       r,			/* risk free rate */
       q,			/* dividend yield  (=3Drisk free rate for futures) */
   volab,			/* volatility of underlying at time "ta" */
    volb;			/* present  volatility of underlying */
int type;			/* specifies type of compound option:
					1  Call on a Call
					2  Put  on a Call
					3  Call on a Put
					4  Put  on a Put
					5  implied vola
				*/
{

     double a1, a2, b1, b2, conc, ponc, conp, ponp, rho;=20
     double ta, tb, Sstar, vola, var;=20
     double cumnorm(), Callroot(), Putroot(), binorm();

     ta =3D daysa/DAYSYR;
     tb =3D daysb/DAYSYR;

     var  =3D  (tb*volb*volb-(tb-ta)*volab*volab) / ta;
     if( var < 0.0 )
         return( -1.0 );

     vola =3D sqrt( (tb*volb*volb-(tb-ta)*volab*volab)/ta );
     if( type =3D=3D 5 )
         return vola;

     if( type < 3 )   /*  Underlying option is a call */
         Sstar =3D Callroot( xa, xb, (daysb-daysa), r, volab, 0.001, 10000. =
 );
     else
         Sstar =3D  Putroot( xa, xb, (daysb-daysa), r, volab, 0.001, 10000. =
 );

     a1 =3D (log(S/Sstar)+(r-q+vola*vola/2.0)*ta)/(vola*sqrt(ta));
     a2 =3D a1 - vola*sqrt(ta);

     b1 =3D (log(S/xb)+(r-q+volb*volb/2.0)*tb)/(volb*sqrt(tb));
     b2 =3D b1 - volb*sqrt(tb);
   =20
     rho =3D sqrt(ta/tb)*vola/volb;
    =20

 switch(type)
 {
    case 1:		/* Call on a Call */
    {
     conc =3D S*exp(-q*tb)*binorm(a1,b1,rho)-xb*exp(-r*tb)*binorm(a2,b2,rho)=
-exp(-r*ta)*xa*cumnorm(a2);
     return conc;
     break;
    }
    case 2:		/* Put  on a Call */
    {
     ponc  =3D xb*exp(-r*tb)*binorm(-a2,b2,-rho)-S*exp(-q*tb)*binorm(-a1,b1,=
-rho)+exp(-r*ta)*xa*cumnorm(-a2);
     return ponc;
     break;
    }=20
    case 3:		/* Call on a Put  */
    {=20
     conp  =3D xb*exp(-r*tb)*binorm(-a2,-b2,rho)-S*exp(-q*tb)*binorm(-a1,-b1=
,rho)-exp(-r*ta)*xa*cumnorm(-a2);=20
     return conp;
     break;
    }
    case 4:		/* Put  on a Put  */
    {
     ponp   =3D S*exp(-q*tb)*binorm(a1,-b1,-rho)-xb*exp(-r*tb)*binorm(a2,-b2=
,-rho)+exp(-r*ta)*xa*cumnorm(a2);
     return ponp;
     break;
    }
    default:
		return (-999999999.999); /* exit(0); */

 }
}
#undef DAYSYR

/** main for testing **/
/******
main()
{
double res;
double S =3D 2.50,
	xa =3D 0.15,
	xb =3D 2.1248,
	ta =3D 0.2519,
	tb =3D 0.3949,
	r =3D 0.04,
	q =3D 0.04,
	volab =3D 0.33,
	volb  =3D 0.33;
int	type =3D 3;

res =3D optoptvol(S, xa, xb, ta, tb, r, q, volab, volb, type);
printf("%f\n", res);
}
*******/

--------------000506070003020302060604
Content-Type: text/plain; name="Put.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Put.c"

/*----------------------------------------
 * Black-Scholes's European Put  Option Model
 *    for "stock" with continuous dividend rate q.
 *
 *	V1.0	 4aug93		changed units of "time" from days to years.
 *
 * s    spot price                =20
 * k    strike price             =20
 * time tenor
 * r    annualized riskfree rate
 * q	continuous dividend yield
 * vol1 annualized volatility =20

    COPYRIGHT C 1993, BY ENRON GAS SERVICES, ALL RIGHTS RESERVED.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON GAS SERVICES.
------------------------------------------*/

#include  <math.h>

double put( s, k, time, r, q, vol1 )
double s, k, time, r, q, vol1;
{
    double negd1, negd2, putprem, Nd1, Nd2;
    double cumnorm();

    negd1 =3D (log(s/k)+(r-q+vol1*vol1/2)* time)/(-vol1 * sqrt(time));
    negd2 =3D vol1*sqrt(time) + negd1;

    Nd1 =3D cumnorm(negd1);
    Nd2 =3D cumnorm(negd2);
    putprem =3D exp(-r*time)*k*Nd2 - exp(-q*time)*s*Nd1 ;
    return( putprem );
}

--------------000506070003020302060604
Content-Type: text/plain; name="Putr.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Putr.c"

/*----------------------------------------
 * Black-Scholes's European Put  Option Model
 *    for "stock" with continuous dividend rate q.
 *
 *	V0.1	22jul93	added d(delta)/d(vol) to risk params. psg.
 *
 * s    spot price                =20
 * k    strike price             =20
 * expd days to expiration      =20
 * r    annualized riskfree rate
 * q	continuous dividend yield
 * vol  annualized volatility =20
 *      risk[0] delta
 *          [1] gamma
 *          [2] vega
 *          [3] rho
 *          [4] theta
 *          [5] commodity rho
 *          [6] d(delta)/d(vol)

    COPYRIGHT C 1993, BY ENRON GAS SERVICES, ALL RIGHTS RESERVED.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON GAS SERVICES.
------------------------------------------*/

#include  <math.h>
#include  "M_PI.h"

double putr( s, k, expd, r, q, vol, risk )
double s, k, expd, r, q, vol, *risk;
{
    double time, negd1, negd2, put, Nd1, Nd2;
    double NPrimeD1, volt, expqt;
    double cumnorm();
    time =3D expd/365.25;
    expqt=3D exp(-q*time);
    volt =3D vol*sqrt(time);

    negd1 =3D (log(s/k)+(r-q+vol*vol/2)* time)/(-volt);
    negd2 =3D volt + negd1;
    NPrimeD1 =3D (1.0 / sqrt(2.0*M_PI)) * exp(-negd1*negd1/2.0);

    Nd1 =3D cumnorm(negd1);
    Nd2 =3D cumnorm(negd2);
    put =3D exp(-r*time)*k*Nd2 - exp(-q*time)*s*Nd1 ;

    risk[0] =3D -Nd1 *  expqt;                   		/** delta **/
    risk[1] =3D (expqt * NPrimeD1) / (s * volt);  	/** gamma **/
    risk[2] =3D expqt * s * NPrimeD1 * sqrt(time);	/** vega  **/
    risk[3] =3D (-time)*exp(-r*time)*k*Nd2;       	/** rho   **/
                                                	/** theta **/
    risk[4] =3D (-s*NPrimeD1*vol*expqt)/(2.0*sqrt(time)) - q*s*Nd1*expqt + r=
*k*exp(-r*time) *Nd2;
    risk[5] =3D (-time)*put;
    risk[6] =3D expqt * NPrimeD1 * (sqrt(time) + negd1/vol);
    return( put );
}

--------------000506070003020302060604
Content-Type: text/plain; name="Qspread.h"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Qspread.h"

/* #include <windows.h>		*/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

struct dSpreadVariables{
	double Xo;
	double Yo;
	double K;
	double muY;
	double expn;
	double varn;
	double disc;
	double volyrtt;
	double volnrtt;
	double drift;
	double expqt;
	double tt;
} ;

struct dInputVariables {
	double price[2];
	double ONvol[2];
	double UNvol[2];
	double UOvol[2];
	double corr;
	double Ostrike;
	double Ustrike;
	double ONrate;
	double UNrate;
	double UOrate;
	double drift[2];
	double ONtime;
	double UNtime;
	double UOtime;
	int	Ocode;
	int Ucode;
	double hstep;
};=09

double fValueDeal(void);
double fValueUnderlyingOption(double marg);
double fOverlying(double x, double y);
void   fSpreadSetup(void);
double fSpread(double x, double y, double strk);
double fSpreadCall(double y);
double fSpreadPut(double y);

double fQgaus1(double (*func)() ,double a, double b);
double fAdaptQgaus1(double (*func)(), double mid, double end, double step);

void fGlo16(double *x, double *a, double c, double d);
double fQgaus2(double (*func)(), double aa, double bb, double fl, double fu,
	double *X, double *A, int MM1, int MM2);
double cumnorm(double x);
double fSquare(double (*func)(), double xo, double yo,
		double hx, double hy);
double f2DIntegH6(double (*func)(), double minX, double maxX,
		double minY, double maxY, double hx, double hy);
--------------000506070003020302060604
Content-Type: text/plain; name="Rainbow.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Rainbow.c"

/*-------------------------------------------------------


	function rainbow()

	Calculates premium of various dual commodity options:

	V0.0 6aug1993 -psg

-------------------------------------------------------*/

#include <stdio.h>
#include <math.h>
#include "option.h"

#define MAX(x, y) ((x > y) ? x : y)
#define MIN(x, y) ((x < y) ? x : y)

#define EPSD 0.000030517578125
/* EPSD =3D 2^-15 for numerical differentiation, it is important   =20
 * to choose EPS to be a machine representable number. =20
 * See "Numerical Recipes p. 186=20
 * Any number between -EPSD and +EPSD=20
 * is treated equal to zero in the program below */

double euroopt(double s, double k, double time, double r, double q, double v=
ol,
			   int callflag, int risk );


double rainbow( sa, sb, K, r, qa, qb, time, vola, volb, corr, type)

double sa,			/* price of underlying */
      sb,			/* price of underlying */
       K,			/* strike price */
       r,			/* interest rate */
      qa,			/* yield of underlying a */
      qb,			/* yield of underlying b */
    time,			/* time to expiration (years)  */
    vola,			/* volatility of Sa */
    volb,			/* volatility of Sb */
    corr;			/* correlation of sa and sb    */

int type;/* Option type:
				1  Max( 0, max[sa,sb]-K )   "call on max of two assets"
				2  Max( 0, min[sa,sb]-K )   "call on min of two assets"
				3  Max( 0, K-max[sa,sb] )   "put  on max of two assets"
				4  Max( 0, K-min[sa,sb] )   "put  on min of two assets"
				5  Max( 0, sa-sb )          "option to exchange sb for sa"
				6  Max( 0, max[sa,sb,K] )   "max of two assets or cash"
	*/
{

    =20
     double psa, psb, msa, msb, ysa, ysb, za, zb, strike;
     double prem, callmax2, callmax3, callmaxK, callminK, callmin2, marg, rt=
time, vol;
     double cumnorm(), binorm();
     double temp;
     int marg_done =3D 0; /* flag to indicate if Margrabe option valuation d=
one */


if (time >=3D EPSD) {
     rttime =3D sqrt(time);

	 if (vola < EPSD) { /* vola is zero */
		marg_done =3D 1;
		if (volb < EPSD)  /* volb is also zero */
			marg =3D MAX(sa*exp(-qa*time) - sb*exp(-qb*time), 0);
		else=20
			marg =3D euroopt(sb, sa*exp((r-qa)*time), time, r, qb, volb, 0, 0);
	 }
	 else if (volb < EPSD) { /* volb is zero */
			marg_done =3D 1;
			marg =3D euroopt(sa, sb*exp((r-qb)*time), time, r, qa, vola, 1, 0);
		 }

		vol =3D sqrt( vola*vola + volb*volb - 2.0*corr*vola*volb );
		if (vol < EPSD) {
		 if (!marg_done) marg =3D MAX(sa*exp(-qa*time) - sb*exp(-qb*time), 0);
		 vol =3D EPSD;
		 ysa =3D (log(sa/sb) + (qb-qa + vol*vol/2.0)*time ) / (vol*rttime);
		 ysb =3D (log(sb/sa) + (qa-qb + vol*vol/2.0)*time ) / (vol*rttime);
		}
		else {
		 ysa =3D (log(sa/sb) + (qb-qa + vol*vol/2.0)*time ) / (vol*rttime);
		 ysb =3D (log(sb/sa) + (qa-qb + vol*vol/2.0)*time ) / (vol*rttime);
		 if (!marg_done) marg =3D sa*exp(-qa*time)*cumnorm(ysa)=20
				- sb*exp(-qb*time)*cumnorm(ysa-vol*rttime);
		}
		marg_done =3D 1;


 if( K >=3D EPSD ){
	if ((vola >=3D EPSD) && (volb >=3D EPSD)) {
	psa =3D (log(sa/K)+(r-qa+vola*vola/2.0)*time)/(vola*rttime);
	psb =3D (log(sb/K)+(r-qb+volb*volb/2.0)*time)/(volb*rttime);

	msa =3D psa - vola*rttime;
	msb =3D psb - volb*rttime;

	za =3D (corr*volb - vola)/vol;
	zb =3D (corr*vola - volb)/vol;


     	/** callmax3 is value of call on max of two assets or cash amount "K" =
**/

	callmax3 =3D    sa*exp(-qa*time)* ( cumnorm(ysa)-binorm(-psa,ysa,za) )
		    + sb*exp(-qb*time)* ( cumnorm(ysb)-binorm(-psb,ysb,zb) )
		    + K*exp(-r*time) *  binorm( -msa, -msb, corr);
	}
	else if (vola < EPSD)  {  /* vola is zero */
		strike =3D MAX(K, sa*exp((r-qa)*time));
		callmax3 =3D euroopt(sb, strike, time, r, qb, volb, 1, 0)
			+ exp(-r*time) * strike;
		}
	       else  if (volb < EPSD) {  /* volb is zero */
		strike =3D MAX(K, sb*exp((r-qb)*time));
		callmax3 =3D euroopt(sa, strike, time, r, qa, vola, 1, 0)
			+ exp(-r*time) * strike;
		}
		else { /* both vols are zero */
			strike =3D MAX(K, sb*exp((r-qb)*time));
			callmax3 =3D MAX(strike, sa*exp((r-qa)*time));
		}


        /** callmaxK  is value of call on max of two assets with exercise pr=
ice K **/

        callmaxK =3D callmax3 - K*exp(-r*time);

     	/** callmax2 is value of call on max of two assets with exercise price=
 0.0 **/

	callmax2 =3D ( sb*exp(-qb*time) + marg);

     }else{  /** when K=3D0, then all cases are the same **/

	callmax3 =3D  sb*exp(-qb*time) + marg;
	callmaxK =3D callmax2 =3D callmax3;

     }


     switch(type)
     {
        case 1:	/* call on the max of two assets (exercise price K)  */
        {
         prem =3D callmaxK;
         break;
        }
        case 2:	/* call on the min of two assets (exercise price K)  */
        {
         prem   =3D euroopt( sa,K,time,r,qa,vola, 1, 0) + euroopt(sb,K,time,=
r,qb,volb, 1, 0) - callmaxK;
         break;
        }=20
        case 3:	/* put  on the max of two assets (exercise price K)  */
        {=20
			prem  =3D K*exp(-r*time) - callmax2 + callmaxK;
			break;
        }
        case 4:	/* put  on the min of two assets (exercise price K)  */
        {
			callminK =3D euroopt(sa,K,time,r,qa,vola, 1, 0) + euroopt(sb,K,time,r,qb,=
volb, 1, 0) - callmaxK;
			callmin2 =3D sa*exp(-qa*time) + sb*exp(-qb*time)  - callmax2;
			prem   =3D K*exp(-r*time) - callmin2 + callminK;
			break;
        }
        case 5:	/* option to exchange sb for sa  */
        {
			prem   =3D marg;
			break;
        }
        case 6:	/* max of two assets or cash  */
        {
			prem   =3D callmax3;
			break;
        }
        default:
			prem =3D ERR_RETVAL;
     }
	 }
	 else {   /* time to expiration is negative or zero */
     switch(type)
     {
        case 1:	/* call on the max of two assets (exercise price K)  */
        {
			temp =3D MAX(sa, sb) - K;
			prem =3D MAX(temp, 0);
         break;
        }
        case 2:	/* call on the min of two assets (exercise price K)  */
        {
			temp =3D MIN(sa, sb) - K;
			prem =3D MAX(temp, 0);
         break;
        }=20
        case 3:	/* put  on the max of two assets (exercise price K)  */
        {=20
			temp =3D K - MAX(sa, sb);
			prem  =3D MAX(temp, 0);
			break;
        }
        case 4:	/* put  on the min of two assets (exercise price K)  */
        {
			temp =3D K - MIN(sa, sb);
			prem =3D MAX(temp, 0);
			break;
        }
        case 5:	/* option to exchange sb for sa  */
        {
			prem   =3D MAX(sa - sb, 0);
			break;
        }
        case 6:	/* max of two assets or cash  */
        {
			temp =3D MAX(sa, sb);
			prem   =3D MAX(temp, K);
			break;
        }
        default:
			prem =3D ERR_RETVAL;
     }
	 }

     return prem;
}

--------------000506070003020302060604
Content-Type: text/plain; name="Rainbowo.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Rainbowo.c"

/*-------------------------------------------------------------

  file: rainbowopt.c

  V0.0  04aug93  analytical solution for premium, finite-diff greeks. -psg
  V0.1  25aug93  corrected special cases for Eta. -psg
  V0.2  25aug93  change time from year to calendar days for consistency. -ps=
g
  V0.3  31jan97  added charm1 and charm2, and made the finite differencing
		convention consistent with that for spread options
		time input now in years   -vs

  Various Dual Commodity Options



    COPYRIGHT C 1993, BY ENRON GAS SERVICES, ALL RIGHTS RESERVED.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON GAS SERVICES.
------------------------------------------------------------------------*/

#include  <stdio.h>
#include  <math.h>
#include "option.h"

#define EPSD 0.000030517578125
/* EPSD =3D 2^-15 for numerical differentiation, it is important   =20
 * to choose EPS to be a machine representable number. =20
 * See "Numerical Recipes p. 18 */

double rainbow( double sa, double sb, double K, double r, double qa,
			   double qb, double time, double vola, double volb,
			   double corr, int type);
=20

double rainbowopt( sa, sb, K, r, qa, qb, time, vola, volb, corr, opttype, va=
ltype)
double sa,                      /* price of underlying */
      sb,                       /* price of underlying */
       K,                       /* strike price */
       r,                       /* interest rate */
      qa,                       /* yield of underlying a */
      qb,                       /* yield of underlying b */
	time,                       /* time to expiration (years)  */
    vola,                       /* volatility of Sa */
    volb,                       /* volatility of Sb */
    corr;                       /* correlation of sa and sb    */

int opttype;/* Option type:
                                1  Max( 0, max[sa,sb]-K )   "call on max of =
two assets"
                                2  Max( 0, min[sa,sb]-K )   "call on min of =
two assets"
                                3  Max( 0, K-max[sa,sb] )   "put  on max of =
two assets"
                                4  Max( 0, K-min[sa,sb] )   "put  on min of =
two assets"
                                5  Max( 0, sb-sa )          "option to excha=
nge sb for sa"
                                6  Max( 0, max[sa,sb,K] )   "max of two asse=
ts or cash"    */

int   valtype;  /* premium         0
                   delta1          1
                   delta2          2
                   gamma1          3
                   gamma2          4
                   gamma12         5
                   vega1           6
                   vega2           7
                   eta             8
                   rho             9
                   theta           10 =20
				   charm1          11
				   charm2          12  */

{
double	prem, value, sqrteps;
int	type;
double f1, f2, f3;

	if ((sa < EPSD) || (sb < EPSD) || (corr < -1) || (corr > 1) || (r < 0)
	|| (vola < 0) || (volb < 0))=20
		return (ERR_RETVAL);

  type =3D opttype;
  prem  =3D rainbow( sa, sb, K, r, qa, qb, time, vola, volb, corr, type);

  if (opttype =3D=3D 5 &&   /* check special case only for Margrabe */
	  ((vola < EPSD) && (volb < EPSD))) {
	  switch(valtype)
	  {
		case 0:		/* premium */
		{
		 value =3D prem;
         break;
		}
		case 1:		/* delta 1 */
		{
		value =3D ((sa*exp(-qa*time) >=3D (sb*exp(-qb*time)+EPSD)) =20
					? exp(-qa*time)
					: ((sa*exp(-qa*time) > (sb*exp(-qb*time)-EPSD))
					? 0.5 * exp(-qa*time)
					: 0));
		break;
		}
		case 2:		/* delta 2 */
		{
		value =3D ((sa*exp(-qa*time) >=3D (sb*exp(-qb*time)+EPSD)) =20
					? - exp(-qb*time)
					: ((sa*exp(-qa*time) > (sb*exp(-qb*time)-EPSD))
					? - 0.5 * exp(-qb*time)
					: 0));
		break;
		}
		case 3:		/* gamma 1 */
		{
		value =3D ((fabs(sa*exp(-qa*time) - sb*exp(-qb*time)) < EPSD) =20
					? ERR_RETVAL
					: 0);
		break;
		}
		case 4:		/* gamma 2 */
		{
		value =3D ((fabs(sa*exp(-qa*time) - sb*exp(-qb*time)) < EPSD) =20
					? ERR_RETVAL
					: 0);
		break;
		}
		case 5:		/* gamma 12 */
		{
		value =3D ((fabs(sa*exp(-qa*time) - sb*exp(-qb*time)) < EPSD) =20
					? ERR_RETVAL
					: 0);
		break;
		}
		case 6:		/* vega 1 */
		{
		value =3D 0;
		break;
		}
		case 7:		/* vega 2 */
		{
		value =3D 0;
		break;
		}
		case 8:		/* eta: correlation risk */
		{
		value =3D 0;
		break;
		}
	   case 9:		/* commodity rho */
		{
		value  =3D ((sa*exp(-qa*time) >=3D (sb*exp(-qb*time)+EPSD)) =20
					? -time * prem
					: 0);
		break;
		}
		case 10:		/* theta */
		{
		value =3D ((sa*exp(-qa*time) >=3D (sb*exp(-qb*time)+EPSD)) =20
					? qa * sa * exp(-qa*time) - qb * sb * exp(-qb*time)=20
					: 0);
		break;
		}
		case 11:        /* charm 1 */
			value =3D ((sa*exp(-qa*time) >=3D (sb*exp(-qb*time)+EPSD)) =20
					? qa * exp(-qa * time)
					: ((sa*exp(-qa*time) > (sb*exp(-qb*time)-EPSD))
						? qa * 0.5 * exp(-qa*time)
						: 0));
		break;
		case 12:        /* charm 2 */
		value =3D ((sa*exp(-qa*time) >=3D (sb*exp(-qb*time)+EPSD)) =20
					? -qb * exp(-qb*time)
					: ((sa*exp(-qa*time) > (sb*exp(-qb*time)-EPSD))
						? -qb * 0.5 * exp(-qb*time)
						: 0));
		break;
		default:=20
			value =3D ERR_RETVAL;
	 }

}
else {
=09
	sqrteps =3D sqrt(EPSD);

  switch(valtype)
  {
    case 0:		/* premium */
	{
	 value =3D prem;
         break;
	}
    case 1:		/* delta 1 */
	{
	 value =3D (rainbow(sa + EPSD,sb,K,r,qa,qb,time,vola,volb,corr,type) - prem=
)/EPSD;
	 break;
	}
    case 2:		/* delta 2 */
	{
	 value =3D (rainbow(sa,sb+EPSD,K,r,qa,qb,time,vola,volb,corr,type) - prem)/=
EPSD;
	 break;
	}
    case 3:		/* gamma 1 */
	{
	 value =3D( rainbow(sa+sqrteps,sb,K,r,qa,qb,time,vola,volb,corr,type)
	        + rainbow(sa-sqrteps,sb,K,r,qa,qb,time,vola,volb,corr,type)
                -2.0*prem ) / (EPSD);
	 break;
	}
    case 4:		/* gamma 2 */
	{
	 value =3D( rainbow( sa, sb+sqrteps, K, r, qa, qb, time, vola, volb, corr, =
type)
	         +rainbow( sa, sb-sqrteps, K, r, qa, qb, time, vola, volb, corr, ty=
pe)
                 -2.0*prem ) / (EPSD);
	 break;
	}
    case 5:		/* gamma 12 */
	{
	 value =3D(rainbow( sa+sqrteps, sb+sqrteps, K, r, qa, qb, time,vola,volb,co=
rr,type)
	   + rainbow( sa-sqrteps, sb-sqrteps, K, r, qa, qb, time, vola, volb, corr,=
 type)
	   - rainbow( sa+sqrteps, sb-sqrteps, K, r, qa, qb, time, vola, volb, corr,=
 type)
	   - rainbow( sa-sqrteps, sb+sqrteps, K, r, qa, qb, time, vola, volb, corr,=
 type))
			/ (4.0*EPSD);
	 break;
	}
    case 6:		/* vega 1 */
	{
	 value =3D (rainbow(sa,sb,K,r,qa,qb,time,vola+EPSD,volb,corr,type)-prem)/EP=
SD;
	 break;
	}
    case 7:		/* vega 2 */
	{
	 value =3D (rainbow(sa,sb,K,r,qa,qb,time,vola,volb+EPSD,corr,type)-prem)/EP=
SD;
	 break;
	}
    case 8:		/* eta: correlation risk */
	{
	 if( corr + EPSD <=3D 1)
	     value =3D (rainbow(sa,sb,K,r,qa,qb,time,vola,volb, corr + EPSD,type)-p=
rem)/EPSD;
	 else
	     value =3D (rainbow(sa,sb,K,r,qa,qb,time,vola,volb,corr-EPSD,type)-prem=
)/(-EPSD);
	 break;
	}
    case 9:		/* commodity rho */
	{
	 /* commodity rho */
	value =3D (rainbow(sa,sb,K,r+EPSD,qa+EPSD,qb+EPSD,time,vola,volb,corr,type)
		-prem)/EPSD;
	 break;
    }
	case 10:		/* theta */
	{
	 value =3D (rainbow(sa,sb,K,r,qa,qb,time-EPSD,vola,volb,corr,type)-prem)/EP=
SD;
	 break;
	}
	case 11:        /* charm 1 */
		f1 =3D rainbow(sa+sqrteps, sb, K, r, qa, qb, time, vola, volb, corr, type)=
;
		f2 =3D rainbow(sa+sqrteps, sb, K, r, qa, qb, time-sqrteps, vola, volb, cor=
r, type);
		f3 =3D rainbow(sa, sb, K, r, qa, qb, time-sqrteps, vola, volb, corr, type)=
;
		value =3D ((f2-f3)-(f1-prem))/EPSD;
		break;
	case 12:        /* charm 2 */
		f1 =3D rainbow(sa, sb+sqrteps, K, r, qa, qb, time, vola, volb, corr, type)=
;
		f2 =3D rainbow(sa, sb+sqrteps, K, r, qa, qb, time-sqrteps, vola, volb, cor=
r, type);
		f3 =3D rainbow(sa, sb, K, r, qa, qb, time-sqrteps, vola, volb, corr, type)=
;
		value =3D ((f2-f3)-(f1-prem))/EPSD;
		break;
	default:=20
		value =3D ERR_RETVAL;
  }
}
  return value;
}
#undef EPSD

/*******
main()
{
double sa=3D2.05,
      sb=3D2.10,
       K=3D2.00,
       r=3D0.04,
      qa=3D0.04,
      qb=3D0.04,
    time=3D1.0,=09
    vola=3D0.30,
    volb=3D0.20,
    corr=3D -1.0;
double  rain, rainbow();
int type;

printf("type ?");
scanf("%d", &type);

rain =3D rainbowopt( sa, sb, K, r, qa, qb, time, vola, volb, corr, type, 0);
printf("%f\n", rain);

qa=3D0.06,
rain =3D rainbowopt( sa, sb, K, r, qa, qb, time, vola, volb, corr, type, 0);

}
********/

--------------000506070003020302060604
Content-Type: text/plain; name="Sgn.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Sgn.c"


int sgn(x)
double x;
{
  if ( x > 0.0 ) return 1;
  if ( x < 0.0 ) return -1;
  return 0;
}


--------------000506070003020302060604
Content-Type: text/plain; name="Shellsor.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Shellsor.c"

/*-------------------------------------------------------
 *
 *	function shellsort()
 *
 *	Finds an index array which orders a vector.
 *	Uses "shell sort" algorithm from "Numerical Recipes."
 *
 *	V0.0	10sept93  -psg
 *
 *
 *      n       length of vector
 *      vec     vector to be ordered  (is not altered by shellsort)
 *      index   index which orders vector "vec"  (return value)
 *
 *-------------------------------------------------------*/
#include <math.h>

#define   ALN2I 1.442695022
#define   TINY  1.0e-5

void shellsort( n, vec, index)
double *vec;
int n, *index;
{
	int nn, m, j, i, lognb2;
	int indxt;
	double t;

	for( i=3D0; i<n; i++) index[i] =3D i;

	lognb2 =3D (int) (log( (double)n )*ALN2I+TINY);
	m =3D n;

	for ( nn=3D1; nn<=3Dlognb2; nn++) {
		m >>=3D 1;
		for ( j=3Dm; j<n; j++) {
			i =3D j - m;
			t =3D vec[ (indxt=3Dindex[j]) ];
			while ( i >=3D 0 && vec[ index[i] ] > t) {
				index[i+m] =3D index[i];
				i -=3D m;
			}
			index[i+m] =3D indxt;
		}
	}
}

#undef ALN2I
#undef TINY

--------------000506070003020302060604
Content-Type: text/plain; name="Spdopt.h"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Spdopt.h"

#define TRUE 1
#define FALSE 0
#define SQRTPI  1.772453850905
#define SQRTTWO 1.414213562373
#define SQRT2PI 2.506628274631
#define YEAR 365.25
#define NP 55
#define UpCorr 0.999
#define LowCorr -0.999
#define TINY   1.e-10
#define  EPSD  0.000030517578125
#define  SqrEPSD 0.00552427172802

#define  MAX_ITER 40
#define  ERR_RETURN -9999999.1234

static double dDMAXarg1,dDMAXarg2;
#define DMAX(a,b) (dDMAXarg1=3D(a),dDMAXarg2=3D(b),(dDMAXarg1) > (dDMAXarg2)=
 ?\
        (dDMAXarg1) : (dDMAXarg2))

#define DllImport		__declspec(dllimport)
#define DllExport		__declspec(dllexport)


typedef	struct
{
	double s1;
	double s2;
	double strike;
	double r;
	double q1;
	double q2;
	double vol1;
	double vol2;
	double correl;
	double tmat;


	double expA;
	double m1;
	double m2;
	double vol;
	double volt;
    double disc;
	double temp;
	double expq1;
	double expq2;

} StructInput;


StructInput S;

double gauherInt(double (*func)());
double cumnorm( double x );
double Ffunc0(double s1T);
double Ffunc1(double s1T);
double Ffunc2(double s1T);
double Ffunc3(double s1T);
double Ffunc4(double s1T);
double Ffunc5(double s1T);
double Ffunc6(double s1T);
double Ffunc7(double s1T);
double Ffunc8(double s1T);
double Ffunc9(double s1T);
double Ffunc10(double s1T);
double Ffunc11(double s1T);

double UnitCorrPremium(double s1, double s2, double strike, double r,
			   double vol1, double vol2,=20
			   double correl, double tmat, int opttype);

double OSpread(double s1, double s2, double strike, double r,
			   double vol1, double vol2,=20
			   double correl, double tmat, int opttype, int rettype);

/* extern DllExport=20
double __stdcall */ double UnitCorrSpd(double s1, double s2, double strike, =
double r,
			   double vol1, double vol2,=20
			   double correl, double tmat, int opttype, int rettype);

/* extern DllExport=20
double __stdcall */ double Spread(double s1, double s2, double strike, doubl=
e r,
			   double vol1, double vol2,=20
			   double correl, double tmat, int opttype, int rettype);






--------------000506070003020302060604
Content-Type: text/plain; name="Spdopts.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Spdopts.c"

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "M_PI.h"

/* #define max(x, y) ( (x) > (y) ? (x) : (y) ) */
#define abs(x) ( (x) > 0 ? (x) : (-x) )

#define OK 0
#define FAIL 1
#define TRUE 1
#define FALSE 0

typedef short Status;

void swap(double *A, double *B) {
    static double temp;
   =20
    temp=3D*A;
    *A=3D*B;
    *B=3Dtemp;
}

#define RTPI 2.5066282746310    /* This is the value of sqrt(2*PI) */
#define EPS 0.000030517578125
/* EPS =3D 2^-15, it is important to choose EPS to be a machine
   representable number.  See "Numerical Recipes p. 186
*/

/*----------------------------------------------*/
/* Compute the Standard Normal Density Function */
/*----------------------------------------------*/
static double dN(double x)
{                              =20
        return exp(-.5 * x * x) / RTPI;
}

/*------------------------------------------------------*/
/* Compute the Cummulative Normal Distribution Function */
/* From Hull, "Options..." p. 226                       */
/*------------------------------------------------------*/
static double N(double x)
{
static double
  g=3D0.2316419,
  a1=3D0.319381530,
  a2=3D-0.356563782,
  a3=3D1.7814779937,
  a4=3D-1.821255978,
  a5=3D1.330274429;
 =20
double k=3D1./(1.+g*x);

    if (x > 4.0)
      return 1.0;
                    =20
    if (x >=3D 0.0)
      return (1.-dN(x)*(((((a5*k+a4)*k+a3)*k)+a2)*k+a1)*k);
    else
      return 1.-N(-x);
}

#undef RTPI

/* The following routine was written by Boris Moro of TMG financial products=
 & published in Risk Magazine */

/* routine calculates inverse of cumulative normal distribution function for
 argument u from the interval (0,1)=20
 Good accuracy is achieved for 1.0E-10 < u < 1.0-1.0E-10,=20
 however even if u=3DO(1.0E-15) the result will still have at least first th=
ree figures correct*/

static double invN(double u){
   =20
static double xsum  =3D 4.2454686881376569;
static double xdif  =3D 0.4179886424926431;

static double cofa[4]=3D{
    2.50662823884,
  -18.61500062529,
   41.39119773534,
  -25.44106049637
  };
static double cofb[4]=3D{
   -8.47351093090,
   23.08336743743,
  -21.06224101826,
    3.13082909833
  };


static double cof8[9]=3D{
     7.7108870705487895,
     2.7772013533685169,
     0.3614964129261002,
     0.0373418233434554,
     0.0028297143036967,
     0.0001625716917922,
     0.0000080173304740,
     0.0000003840919865,
     0.0000000129707170
     };

double ndev,x,r,z,zz,yy,y;
int i;

x=3Du-0.5;
zz=3Dfabs(x);
if(zz < 0.42)
  {
    r=3Dx*x;
    ndev=3Dx*(((cofa[3]*r+cofa[2])*r+cofa[1])*r+cofa[0])/
           ((((cofb[3]*r+cofb[2])*r+cofb[1])*r+cofb[0])*r+1.0);
    return(ndev);
  }

r=3Dlog(-log(0.5-zz));

r=3D(r + r - xsum)*xdif;

z=3D0.0;
zz=3D0.0;
        y=3D2.0*r;
        for (i=3D8;i>=3D1;i--)
          {
                yy=3Dz;
                z=3Dy*z-zz+cof8[i];
                zz=3Dyy;
        }
        ndev=3Dr*z-zz+0.5*cof8[0];
    if(x < 0.0)ndev=3D-ndev;
return(ndev);

}

/*------------------------------------------------*/
/* Routine to compute normal random numbers       */
/* Based on routine gasdev.c which is             */
/* (C) Copr. 1986-92 Numerical Recipes Software   */
/* Note here that I am using rand(), the standard */
/* ANSI C random number generator, which is known */
/* to be somewhat problematic as a random number  */
/* generator.  However, it is faster than the     */
/* using the more exact rand1 from Numerical      */
/* recipies in C.  Also, the fact that we call    */
/* rand several times for each deviate should     */
/* help things out here.                          */
/*------------------------------------------------*/
static double nrv()
{
        static int iset=3D0;
        static double gset;
        double fac,rsq,v1,v2;

        if  (iset =3D=3D 0) {
                do {
                        v1=3D2.0*rand()/(double)RAND_MAX-1.0;
                        v2=3D2.0*rand()/(double)RAND_MAX-1.0;
                        rsq=3Dv1*v1+v2*v2;
                } while (rsq >=3D 1.0 || rsq =3D=3D 0.0);
                fac=3Dsqrt(-2.0*log(rsq)/rsq);
                gset=3Dv1*fac;
                iset=3D1;
                return v2*fac;
        } else {
                iset=3D0;
                return gset;
        }
}

/*------------------------------------------------------*/
/* Routine to generate multiple gaussian deviates       */
/* Returns count values into the array rvs[], starting  */
/* at element number zero and ending at element count-1 */
/*------------------------------------------------------*/
Status nrvs(double rvs[], int count) {
  int i;

  for (i=3D0; i<count; i++)
    rvs[i]=3Dnrv();

  return OK;
}


/*----------------------------------------------------------*/
/* Faure sequence generator, to generate quasirandom        */
/* Normal deviates.                                         */
/* Usage:                                                   */
/* Generate n random variables and store them in out.       */
/* MaxN=3D maximum number of path simulations and out[]       */
/* represents one sample path. I.E. Out is one vector from  */
/* the Faure sequence of length s.                          */
/* This program is a direct translation of the FORTRAN      */
/* program by Fox, P. "ALGORITHM 647: Implementation and    */
/* Relative Efficiency of Quasirandom Sequence Generators." */
/* ACM Trans. Math. Software, 12 (1986), p. 362-376         */
/*----------------------------------------------------------*/
=20
#define NORMAL                      /* -- This causes getrvsf to return Norm=
al
                                     * rvs by the inverse cum norm function =
*/



Status rvsf(double out[], int s, int MaxN)
{

#define MAXCHOOSE 20

        static int      StartN, maxdigits, r, choose[MAXCHOOSE][MAXCHOOSE], =
y[MAXCHOOSE], hisum,
                        nextn, digit_flip, init =3D 0;
        static double   rinv;

        double          rtemp, *x;

        int             i, j, k, n, sumy;

#define MAXPRIME 59
        static int      primes[MAXPRIME] =3D {2, 2, 3, 5, 5, 7, 7, 11, 11, 1=
1, 11, 13, 13, 17, 17, 17,
                17, 19, 19, 23, 23, 23, 23, 29, 29, 29, 29, 29, 29, 31, 31, =
37, 37, 37, 37, 37,
        37, 41, 41, 41, 41, 43, 43, 47, 47, 47, 47, 53, 53, 53, 53, 53, 53, =
59, 59, 59, 59, 59, 59};

        div_t           divn;


        if (init =3D=3D 0) {

                if (s > MAXPRIME) {
                        fprintf(stderr, "Error! Number of time steps %d is t=
oo large!\n", s);
                        return FAIL;
                }

                r =3D primes[s - 1];      /* Find the smallest prime that is=
 >=3D
                                         * to s */

                StartN =3D 3 ;
                maxdigits =3D (int) (log(MaxN + StartN) / log(r));

                if (maxdigits > MAXCHOOSE) {=20
                  fprintf(stderr, "Error! Too many iterations requested of t=
he Faure routine \n");
                  return FAIL;
                }

                /* Compute Choose Functions modulo r */
                choose[0][0] =3D 1;
                for (i =3D 1; i <=3D maxdigits; i++) {
                        choose[i][0] =3D 1;
                        choose[i][i] =3D 1;
                }

                /*
                 * Generate Remaining Coefficients via the binomial tree
                 * recursion choose(i,j)=3Dchoose(i-1,j)+choose(i-1,j-1) and
                 * using the fact that mod(b+c,d)=3Dmod(mod(b,d)+mod(c,d),d)
                 */
                for (j =3D 1; j <=3D maxdigits; j++)
                        for (i =3D 1 + j; i <=3D maxdigits; i++) {
                                choose[i][j] =3D (choose[i - 1][j] + choose[=
i - 1][j - 1]) % r;
                        }



                nextn =3D StartN - 1;     /* start out at r^2-1 to avoid
                                         * clustering near zero */
                hisum =3D (int) floor(log(nextn)/log(r)); /* r^2-1 has 2 dig=
its in base r */
                digit_flip =3D StartN/r;  /* Increment Hisum when last=20
                                         * digit is zero */

                init =3D 1;
        }                       /* End initialization */
        x =3D out - 1;            /* Offset to return array starting at zero
                                 * instead of 1 */

        /* Compute First Element in the nth Faure Sequence */
        n =3D nextn;
        for (j =3D 0; j <=3D hisum; j++) {
                divn =3D div(n, r);
                y[j] =3D divn.rem;
                n =3D divn.quot;
        }

        /* Compute x(1) via sum(i=3D0, hisum) { y(i)r^(-i-1) } */
        rinv =3D 1.0 / r;
        x[1] =3D y[hisum];
        for (i =3D hisum - 1; i >=3D 0; i--)
                x[1] =3D y[i] + x[1] * rinv;
        x[1] *=3D rinv;

#ifdef FAURE
        printf("faure[1]=3D%f ", x[1]);
#endif

#ifdef NORMAL
        x[1] =3D invN(x[1]);
#endif

        /* Apply the map C via New y(j)=3D sum Old y(j) * choose(i,j) mod r =
 */

        for (k =3D 2; k <=3D s; k++) {

                        x[k] =3D 0;

                rtemp =3D rinv;
                for (j =3D 0; j <=3D hisum; j++) {
                        sumy =3D 0;
                        for (i =3D j; i <=3D hisum; i++)
                                sumy +=3D choose[i][j] * y[i];
                        y[j] =3D sumy % r;
                        x[k] +=3D ((double) y[j]) * rtemp;
                        rtemp *=3D rinv;
                }               /* end for j */

#ifdef FAURE
                printf("faure[%d]=3D%f ", k, x[k]);
#endif

#ifdef NORMAL
                x[k] =3D invN(x[k]);
#endif

        }                       /* end for k */

        nextn++;
        if ((nextn % digit_flip) =3D=3D 0) {
                hisum++;
                if (hisum > MAXCHOOSE) {
                   fprintf(stderr,"Error! Max number of digits for choose ex=
ceeded \n");
                   return FAIL;
                }
                digit_flip *=3D r;
        }

#ifdef FAURE
        printf("\n");
#endif

        return 0;               /* Everything went O.K. */

}                               /* end rvsf */


/*------------------------------------------------------*/
/* Routine to generate a deviate from the               */
/* bivariate normal distribution with mean 0, sd1,      */
/* sd2, and correlation rho                             */
/* This routine based on Hull, p.332.                   */
/*------------------------------------------------------*/
Status bivar(double rv[], double sd1, double sd2, double p) {

#if 1
   /* These first two lines generate bivariate standard normal deviates */
   rv[0]=3Dnrv();
   rv[1]=3Dp*rv[0]+sqrt(1-p*p)*nrv();
#endif

#if 0
   rvsf(rv,(int)2,(int)8000);
   rv[1]=3Dp*rv[0]+sqrt(1-p*p)*rv[1];
#endif

   /* Next we scale up by the appropriate standard deviations */
   rv[0]*=3Dsd1;
   rv[1]*=3Dsd2;

   return OK;
 =20
}

#if 0
/*------------------------------------------------------*/
/* Class to perform Spread Option Valuation             */
/*------------------------------------------------------*/
class spread_opt {
  public:
  Status spd_call();
  Status spd_put();
  Status excg_call();
  Status excg_put();
  Status mc_spd_call();
  Status mc_spd_put();
 =20
  /* Input Parameters For Option Valuation */
    double S1,
            S2,
            X,
            a,
            b,
            rho,
            r,
            q1,
            q2,
            vol1,
            vol2,
            T,
            t;=20
	int     steps;
 =20
  /* Output Parameters For Option Valuation */
    double value;


};

#endif

/*--------------------------------------------------------*/
/* Function to compute value of option to exchange asset  */
/* a*S1 and receive b*S2 via Margrabe's formula.          */
/* The option priced is max(0, b*S2+a*S1)=3Dmax(a*S1,b*S2)  */
/* where b > 0 and a < 0 */
/* as an extension if b < 0, a > 0 max(0, a*S1 + b*S2) is priced */
/*--------------------------------------------------------*/
Status excg_call(double S1, double S2, double X, double a, double b, double =
rho, double r, double q1, double q2, double vol1, double vol2, double T, dou=
ble t, double *value) {
   double d1, d2, var, vol, abs_a, abs_b;
   int swap_flag;

   if (X !=3D 0 ) { /* Margrabe's option requires a zero strike */
       *value=3D0.0;
       return FAIL;
   }
   if ((a < 0 && b <0) || (a > 0 && b > 0)){ /* Option must be on a spread *=
/
       *value=3D0.0;
       return FAIL;
   }
   if (b < 0 && a > 0) {
       swap(&S1, &S2);
       swap (&a,&b);=20
       swap(&q1,&q2);
	   swap_flag =3D TRUE;
   }
   else
	   swap_flag =3D FALSE;

   abs_a=3Dabs(a);
   abs_b=3Dabs(b);
   vol1=3Dmax(vol1,0.0001);
   vol2=3Dmax(vol2,0.0001);
  =20
  =20
   T-=3Dt;
   t=3D0.0;
   var=3Dvol1*vol1-2.0*vol1*vol2*rho+vol2*vol2;
   vol=3Dsqrt(var*T);
   d1=3D(log(abs_b*S2/S1/abs_a)+(q1-q2+0.5*var)*T)/vol;
   d2=3Dd1-vol;
   *value=3Dabs_b*S2*exp(-q2*T)*N(d1)-abs_a*S1*exp(-q1*T)*N(d2);

   if (swap_flag) {
       swap(&S1, &S2);
       swap (&a,&b);=20
       swap(&q1,&q2);
   }
   return OK;
}

=20
#define SPD_CTRL TRUE
/*---------------------------------------------------------*/
/* Function to compute Calls on Spread Options             */
/* This method is due to K. Ravindran, "Low Fat Spreads"   */
/* Risk, Vol. 6, No. 10, Oct. 1993                         */
/* Margrabe as a control variate was suggested by          */
/* Peter Carr of Cornell University                        */
/* Option computed is max(a*S1+b*S2+c, 0)                  */
/* This code can also be used to price a two asset basket  */
/* option when a>0 and b>0.                                */
/* NOTE!! Basket functionality not tested!!                */
/* steps =3D 50 seems to work well for most spread options   */
/*---------------------------------------------------------*/
Status spd_call(double S1, double S2, double X, double a, double b, double r=
ho, double r, double q1, double q2, double vol1, double vol2, double T, doub=
le t, int steps, double *value) {
  double  g1, g2, mu, d1, d2, K, log_S2T, epsilon, c,
          mu1, mu2, sd2, vol, var, val, ctr_K, ctr_d1, ctr_d2, ctr_val,
          marg;      =20
  double i, add, rat1, rat2;
  int    val_pts;
 =20
  c=3D-X;

  if (a < 0 && b < 0) { /* Use symmetry to value this case */
     a=3D-a;
     b=3D-b;
     c=3D-c;
  }
 =20
  marg=3D0.0;
  #if SPD_CTRL /* Use Margrabe as a control variate */
  if (!(a > 0 && b >0) ) /* If option is a basket, don't use Margrabe */
  {
    X=3D0.0;
    excg_call(S1, S2, X, a, b, rho, r, q1, q2, vol1, vol2, T, t, value);
    if (c=3D=3D0.0)  /* If strike is actually zero we're done */
      return OK;
    marg=3D*value;
  }
  #endif

  if (a < 0.0) { /* Internally we require a>0 and b<0 */
    swap (&S1, &S2);
    swap (&a,&b);
    swap (&vol1,&vol2);
    swap (&q1,&q2);
  }

  vol1=3Dmax(vol1,0.0001);
  vol2=3Dmax(vol2,0.0001);

  g1=3Dr-q1;
  g2=3Dr-q2;         =20
  T-=3Dt;
  t=3D0.0;
 =20
  mu1=3Dlog(S1)+(g1-0.5*vol1*vol1)*T;
  mu2=3Dlog(S2)+(g2-0.5*vol2*vol2)*T;
  sd2=3Dvol2*sqrt(T);
  var=3DT*vol1*vol1*(1-rho*rho);
  vol=3Dsqrt(var);

  /* steps =3D 50 */
  if (marg !=3D 0.0) /* We have a ctrl variate so need fewer sims */
    val_pts=3Dsteps;
  else
    val_pts=3Dsteps*4;
   =20
  val=3D0.0;
  ctr_val=3D0.0;
  rat1=3D-b/a;
  rat2=3Dc/a;
  add=3D1.0/val_pts;
  for (i=3D0.5/val_pts; i<1.0; i+=3Dadd) {=20
    epsilon=3DinvN(i);
   =20
    /* Valuation for a given level of epsilon */
    log_S2T=3Dmu2+epsilon*sd2;
    mu=3Dmu1+rho*vol1/vol2*(log_S2T-mu2);

    if (marg>0.0) {       =20
      ctr_K=3Drat1*exp(log_S2T);
      ctr_d2=3D(mu-log(ctr_K))/vol;
      ctr_d1=3Dctr_d2+vol;
      ctr_val+=3Dexp(mu+var/2)*N(ctr_d1)-ctr_K*N(ctr_d2);
      K=3Dctr_K-rat2;
    }
    else=20
      K=3Drat1*exp(log_S2T)-rat2;

    if (K<=3D0.0) { /* Handle negative strike case */
      val+=3Dexp(mu+var/2)-K;
    } else {
      d2=3D(mu-log(K))/vol;
      d1=3Dd2+vol;       =20
      val+=3Dexp(mu+var/2)*N(d1)-K*N(d2);
    }
  }

  if (marg>0.0) =20
  *value=3Da*exp(-r*T)*(val-ctr_val)/val_pts+marg;
  else
  *value=3Da*exp(-r*T)*val/val_pts;

  return OK;
}

/*----------------------------------------------------------*/
/* Function to compute Puts on Spread Options               */
/* This method is due to K. Ravindran, "Low Fat Spreads"    */
/* Risk, Vol. 6, No. 10, Oct. 1993                          */
/* Option computed is max(X-(a*S1+b*S2), 0) where (a>0, b<0 */
/* and X>0) or (a<0, b>0 and X>0).                          */
/*----------------------------------------------------------*/
Status spd_put(double S1, double S2, double X, double a, double b, double rh=
o, double r, double q1, double q2, double vol1, double vol2, double T, doubl=
e t, int steps, double *value) {
Status stat;

/* Use put/call symmetry to value spread put */
  a=3D-a;
  b=3D-b;
  X=3D-X;
 =20
  stat=3Dspd_call( S1,  S2,  X,  a,  b,  rho,  r,  q1,  q2,  vol1,  vol2, T,=
  t, steps,  value);
 =20
return stat;
}

#if 0
/*--------------------------------------------------------*/
/* Function to compute Calls on Spread Options via brute  */
/* force Monte Carlo                                      */
/* Option computed is max(a*S1+b*S2+c, 0)                 */
/*--------------------------------------------------------*/
Status spread_opt::mc_spd_call() {
   int i;
   double rv[2], S1_T, S2_T, g1, g2, mu1, mu2, sd1, sd2, c, val,
           marg, ctr_val;

  c=3D-X;
  g1=3Dr-q1;
  g2=3Dr-q2;
  T-=3Dt;
  t=3D0.0;
 =20
  /* Use Margrabe as a control variate if this is not a basket */
  if (!((a<0 && b<0) || (a>0 && b>0)) ) {
    X=3D0.0;
    excg_call();
    marg=3Dvalue;
  } else
    marg=3D0.0;
 =20
  mu1=3Dlog(S1)+(g1-0.5*vol1*vol1)*T;
  mu2=3Dlog(S2)+(g2-0.5*vol2*vol2)*T;
  sd1=3Dvol1*sqrt(T);
  sd2=3Dvol2*sqrt(T);

  val=3D0.0;
  ctr_val=3D0.0;
  #define SPD_MC 160000
  for (i=3D0; i<SPD_MC; i++) {
      bivar(rv, sd1, sd2, rho);
      S1_T=3Dexp(mu1+rv[0]);
      S2_T=3Dexp(mu2+rv[1]);
      val +=3Dmax(a*S1_T+b*S2_T+c, 0);
      ctr_val +=3Dmax(a*S1_T+b*S2_T, 0);
  }

  if (marg>0.0)
    value=3Dexp(-r*T)*(val-ctr_val)/SPD_MC+marg;
  else
    value=3Dexp(-r*T)*val/SPD_MC;
   =20
  return OK;=20
}

/*----------------------------------------------------------*/
/* Function to compute Puts on Spread Options via brute     */
/* force Monte Carlo                                        */
/* Option computed is max(c-(a*S1+b*S2), 0)                 */
/*----------------------------------------------------------*/
Status spread_opt::mc_spd_put() {
   int i;
   double rv[2], S1_T, S2_T, g1, g2, mu1, mu2, sd1, sd2, c, val;

  c=3DX;=20
  g1=3Dr-q1;
  g2=3Dr-q2;         =20
  T-=3Dt;
  t=3D0.0;
  =20
  mu1=3Dlog(S1)+(g1-0.5*vol1*vol1)*T;
  mu2=3Dlog(S2)+(g2-0.5*vol2*vol2)*T;
  sd1=3Dvol1*sqrt(T);
  sd2=3Dvol2*sqrt(T);

  val=3D0.0;

  #define SPD_MC_PUT 160000
  for (i=3D0; i<SPD_MC_PUT; i++) {
      bivar(rv, sd1, sd2, rho);
      S1_T=3Dexp(mu1+rv[0]);
      S2_T=3Dexp(mu2+rv[1]);
      val +=3Dmax(c-(a*S1_T+b*S2_T), 0);
  }

  value=3Dexp(-r*T)*val/SPD_MC_PUT;

  return OK;=20
}
  =20

#endif

/*
 new_spread
 *
 *	returns premium of spread option
 *
 *     time is in years
 *
 *     Call pays  max( 0, x-y-K) =3D max(0, x-K'),  K'=3D y+K
 *     Put  pays  max( 0, K-x+y) =3D max(0, K'-x),  K'=3D y+K
 *
 *      inputs: volX	annualized volatility of X
 *		volY	annualized volatility of Y
 *		rho	correlation of X and Y
 *		intr	interest rate
 *		Xo	forward price of X
 *		Yo	forward price of Y
 *		time	time to expiration, years
 *		K	strike
 *		Callflag =3D1 for call  0 for put
 *
 */
void  new_spread_prem( double Xo, double Yo, double Ko, double intr,
			 double volX, double volY, double rho,
			 double time, int Callflag, int steps, double *ptr)  {
#if 0
 spread_opt opt;

 opt.S1=3DXo;
 opt.S2=3DYo;
 opt.X=3DKo;
 opt.a=3D1;
 opt.b=3D-1;
 opt.rho=3Drho;
 opt.r=3Dintr;
 opt.q1=3Dopt.r;
 opt.q2=3Dopt.r;
 opt.vol1=3DvolX;
 opt.vol2=3DvolY;
 opt.T=3Dtime;
 opt.t=3D0.0;
 opt.steps =3D steps;
#endif

 if (Callflag =3D=3D 1)
     spd_call(Xo, Yo, Ko, 1, -1, rho, intr, intr, intr, volX, volY, time, 0.=
0, steps, ptr) ;
 else
     spd_put(Xo, Yo, Ko, 1, -1, rho, intr, intr, intr, volX, volY, time, 0.0=
, steps, ptr) ;
}

double new_spread_sens( double Xo, double Yo, double Ko, double intr,
			 double volX, double volY, double rho,
			 double time, int Callflag, int Sens, int steps)  {

	double f0, f1, f2, f3;
=09
	/* For more details about why we compute derivs
	   the way we do see "Numerical Recipes" p. 186
	*/

	new_spread_prem(Xo,Yo,Ko, intr, volX, volY, rho,
			 time, Callflag, steps, &f0);
	switch (Sens) {
	case 0: /* Premium */
		return f0;
	case 1: /* Delta X */
		new_spread_prem(Xo+EPS,Yo,Ko, intr, volX, volY, rho,
			 time, Callflag, steps, &f1);
		return (f1 - f0)/EPS;
	case 2: /* Delta Y */
		new_spread_prem(Xo,Yo+EPS,Ko, intr, volX, volY, rho,
			 time, Callflag, steps, &f1);
		return (f1 - f0)/EPS;
	case 3: /* Gamma X */
		new_spread_prem(Xo+EPS,Yo,Ko, intr, volX, volY, rho,
			 time, Callflag, steps, &f1);
		new_spread_prem(Xo-EPS,Yo,Ko, intr, volX, volY, rho,
			 time, Callflag, steps, &f2);
		return (f1 - 2*f0 + f2)/EPS/EPS;
	case 4: /* Gamma Y */
		new_spread_prem(Xo,Yo+EPS,Ko, intr, volX, volY, rho,
			 time, Callflag, steps, &f1);
		new_spread_prem(Xo,Yo-EPS,Ko, intr, volX, volY, rho,
			 time, Callflag, steps, &f2);
		return (f1 - 2*f0 + f2)/EPS/EPS;
	case 5: /* Vega X */
		new_spread_prem(Xo,Yo,Ko, intr, volX+EPS, volY, rho,
			 time, Callflag, steps, &f1);
		return (f1 - f0)/EPS;
	case 6: /* Vega Y */
		new_spread_prem(Xo,Yo,Ko, intr, volX, volY+EPS, rho,
			 time, Callflag, steps, &f1);
		return (f1 - f0)/EPS;
	case 7: /* Eta : dV/d(correlation) */
		new_spread_prem(Xo,Yo,Ko, intr, volX, volY, rho+EPS,
			 time, Callflag, steps, &f1);
		return (f1 - f0)/EPS;
	case 8: /* Rho : dV/dr*/
		new_spread_prem(Xo,Yo,Ko, intr+EPS, volX, volY, rho,
			 time, Callflag, steps, &f1);
		return (f1 - f0)/EPS;
	case 9: /* Theta */
		new_spread_prem(Xo,Yo,Ko, intr, volX, volY, rho,
			 time*(1-EPS), Callflag, steps, &f1);
		return (f1 - f0)/(time*EPS);
	case 10: /* Charm X */
		new_spread_prem(Xo+EPS,Yo,Ko, intr, volX, volY, rho,
			time, Callflag, steps, &f1);
		new_spread_prem(Xo+EPS,Yo,Ko, intr, volX, volY, rho,
			time*(1-EPS), Callflag, steps, &f2);
		new_spread_prem(Xo,Yo,Ko, intr, volX, volY, rho,
			time*(1-EPS), Callflag, steps, &f3);
		return ((f2-f3) - (f1-f0))/(time*EPS*EPS);
	case 11: /* Charm Y */
		new_spread_prem(Xo,Yo+EPS,Ko, intr, volX, volY, rho,
			time, Callflag, steps, &f1);
		new_spread_prem(Xo,Yo+EPS,Ko, intr, volX, volY, rho,
			time*(1-EPS), Callflag, steps, &f2);
		new_spread_prem(Xo,Yo,Ko, intr, volX, volY, rho,
			time*(1-EPS), Callflag, steps, &f3);
		return ((f2-f3) - (f1-f0))/(time*EPS*EPS);
	default:
		return 0.0;
	}
}

void  new_spread( double Xo, double Yo, double Ko, double intr,
			 double volX, double volY, double rho,
			 double time, int Callflag, int steps, double *ptr)  {
=09
	double f0, f1, f2, f3, f4;
=09
	/* For more details about why we compute derivs
	   the way we do see "Numerical Recipes" p. 186
	*/
=09
	new_spread_prem(Xo,Yo,Ko, intr, volX, volY, rho,
			 time, Callflag, steps, &f0);

	/* Premium */
	ptr[0]=3Df0;

	/* Gamma X */
   new_spread_prem(Xo+EPS,Yo,Ko, intr, volX, volY, rho,
		time, Callflag, steps, &f1);
	new_spread_prem(Xo-EPS,Yo,Ko, intr, volX, volY, rho,
		time, Callflag, steps, &f2);
	ptr[3]=3D(f1 - 2.0*f0 + f2)/EPS/EPS;

	/* Delta X */
	ptr[1]=3D(f1 - f2)/2.0/EPS;

	/* Charm X */
	new_spread_prem(Xo+EPS,Yo,Ko, intr, volX, volY, rho,
		time*(1-EPS), Callflag, steps, &f3);
	new_spread_prem(Xo-EPS,Yo,Ko, intr, volX, volY, rho,
		time*(1-EPS), Callflag, steps, &f4);
	ptr[10]=3D((f3-f4) - (f1-f2))/(2.0*time*EPS*EPS);

	/* Gamma Y */
	new_spread_prem(Xo,Yo+EPS,Ko, intr, volX, volY, rho,
		time, Callflag, steps, &f1);
	new_spread_prem(Xo,Yo-EPS,Ko, intr, volX, volY, rho,
		time, Callflag, steps, &f2);
	ptr[4]=3D(f1 - 2.0*f0 + f2)/EPS/EPS;

   /* Delta Y */
	ptr[2]=3D(f1 - f2)/2.0/EPS;

	 /* Charm Y */
	/* f2 =3D Chg wrt Time from Charm X */
	new_spread_prem(Xo,Yo+EPS,Ko, intr, volX, volY, rho,
		time*(1-EPS), Callflag, steps, &f3);
	new_spread_prem(Xo,Yo-EPS,Ko, intr, volX, volY, rho,
		time*(1-EPS), Callflag, steps, &f4);
	ptr[11]=3D((f3-f4) - (f1-f2))/(2.0*time*EPS*EPS);

	/* Theta */
	new_spread_prem(Xo,Yo,Ko, intr, volX, volY, rho,
		time*(1-EPS), Callflag, steps, &f1);
	ptr[9]=3D(f1 - f0)/time/EPS;

	/* Vega X */
	new_spread_prem(Xo,Yo,Ko, intr, volX+EPS, volY, rho,
		time, Callflag, steps, &f1);
	ptr[5]=3D(f1 - f0)/EPS;
	/* Vega Y */
	new_spread_prem(Xo,Yo,Ko, intr, volX, volY+EPS, rho,
		time, Callflag, steps, &f1);
	ptr[6]=3D(f1 - f0)/EPS;
	/* Rho X */
	new_spread_prem(Xo,Yo,Ko, intr, volX, volY, rho+EPS,
		time, Callflag, steps, &f1);
	ptr[7]=3D(f1 - f0)/EPS;
	/* Rho Y */
	new_spread_prem(Xo,Yo,Ko, intr+EPS, volX, volY, rho,
		time, Callflag, steps, &f1);
	ptr[8]=3D(f1 - f0)/EPS;
=09
=09
=09
}


--------------000506070003020302060604
Content-Type: text/plain; name="Std_rand.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Std_rand.c"

/* std_rand.h
 *
 * generates random numbers between 0 and 1 using rand()
 *
 */

#include <stdlib.h>

double std_random()=20
{
	double randval;

	randval =3D rand()/RAND_MAX;
	return(randval);
}
--------------000506070003020302060604
Content-Type: text/plain; name="TSECCHECKNEW.C"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="TSECCHECKNEW.C"

/*--------------------------------------------------------------------------=
--
=20
	file: TSECCHECK.C

	File with security check function for the exotic pricing routines.
	Created MAR-96 by P.V.Krishnarao

	Modified for speed improvement 17-Mar-99 by Anjam Ahmad, London
	[Now only makes a single check for the security file on the first function =
call
	only - results in speed improvement by factor of up to 5]

	[LONDON VERSION]

    COPYRIGHT C 1999, BY ENRON CAPITAL & TRADE RESOURCES, ALL RIGHTS RESERVE=
D.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON CAPITAL & TRADE RESOURCES.
----------------------------------------------------------------------------=
--*/

#include  <stdio.h>
#define SECFILE  "T:\\READWRTE\\ectres.txt"
#define ERR_RETVAL -999999999.12345
/* first function call tries to open this as a security measure */

int unauth_optlib_call(double *retval)
{
	static int firstcall;
	static int returnvalue;
	FILE *fp;
=09
	if(!firstcall)
	{
		firstcall =3D 1;
	=09
		fp =3D fopen(SECFILE,"r");
		if (!fp) {
			*retval =3D ERR_RETVAL;
		/*	printf("Unauthorized call to ECT Exotic Option Library\n"); */
			returnvalue =3D 1;
			}
		else
		{
			returnvalue =3D 0;
		}
		fclose(fp);
	}	=09
	return(returnvalue);
=09
}

--------------000506070003020302060604
Content-Type: text/plain; name="Wcxsprea.c"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="Wcxsprea.c"

/***************************************

	wcxspread()

	Wilcox model for spread option.

	This model assumes that the spread is normally distributed
	with given standard deviation.

flag_cp -> call-put flag, 1 - call, 0 - put
flag_r  -> return flag, see "switch"
***************************************/
#include <math.h>

#define	CALL	1

double wcxspread(
	double F, 		/* forward price for spread */
	double K, 		/* strike price */
	double r,		/* risk free rate */
	double sigma, 		/* spread annualized standard deviation */
	double t, 		/* time (years) to option expiration */
	int flag_cp,		/* 1=3Dcall, 0=3Dput */=20
	int flag_r		/* flag for return value */
	)
{
	double	cumnorm();
	double	call;	/* premium */
	double	disc, d, N ,Np;

	d  =3D (F-K)/sigma/sqrt(t);
	N  =3D cumnorm(d);
	Np =3D 1/sqrt(2*3.1416)*exp(-d*d/2);
	disc =3D exp(-r*t);
	call =3D  disc *((F-K)*N + sigma*sqrt(t)*Np);

/**
fprintf(stderr, "fkr sig t %f %f %f %f %f\n", F,K,r,sigma,t);
fprintf(stderr, "d N Np df call %f %f %f %f %f\n", d, N, Np, disc, call);
**/

	if( flag_cp =3D=3D CALL )
	{

		switch( flag_r )
		{
		case(0):		/* premium */
			return (call);
		case(1):		/* delta */
			return ( disc*N );
		case(2):		/* gamma */
			return(  disc*Np/sigma/sqrt(t) );
		case(3):		/* vega */
			return ( disc*Np*sqrt(t) );
		case(4):		/* rho */
			return ( -t*call );
		case(5):		/* theta */
			return ( r*call - disc*sigma*Np/2/sqrt(t) );
		case(8):		/* charm */
			return ( disc * (r*N + d*Np/2/t) );
		default:
			return( 0.0 );
		}

	} else
	{
		switch( flag_r )
		{
		case(0):		/* premium */
			return (call+disc*(K-F) );
		case(1):		/* delta */
			return ( disc*(N-1) );
		case(2):		/* gamma */
			return( disc*Np/sigma/sqrt(t) );
		case(3):		/* vega */
			return ( disc*Np*sqrt(t) );
		case(4):		/* rho */
			return ( -t*(call+disc*(K-F)) );
		case(5):		/* theta */
			return ( r*call - disc*(sigma*Np/2/sqrt(t) -r*(F-K)) );
		case(8):		/* charm */
			return ( disc * (r*N + d*Np/2/t -r ) );
		default:
			return( 0.0 );
		}
	} /* else option is a put */
}
#undef	CALL

--------------000506070003020302060604
Content-Type: text/plain; name="ALL_WRAP8.C"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename="ALL_WRAP8.C"

/*--------------------------------------------------------------------------=
--
=20
	file: ALL_WRAP7.C

	File with DLL-wrapper functions for all the exotic pricing routines.
	Created MAR-96 by P.V.Krishnarao
	Modified FEB-97 by Vasant Shanbhogue to make the interface uniform
	All functions now return a status value (-1 for ERROR, 0 for SUCCESS).
	To handle new spread option code Dec 98 Anjam/Zimin for London Exotics

    Modified MAR-99 To incorporate new IMPVOLAB(), WSPREAD() and new spread
	option model correcting numerical errors for very high or low correlations
	by Anjam Ahmad [LONDON VERSION]

	Modified 28 February 1999 to include new AsianStrip model that provides Gre=
eks

    COPYRIGHT C 1999, BY ENRON CAPITAL & TRADE RESOURCES, ALL RIGHTS RESERVE=
D.
    THIS SOURCE CODE, OR PARTS THEREOF, MAY NOT BE REPRODUCED IN ANY
    FORM WITHOUT THE WRITTEN PERMISSION OF ENRON CAPITAL & TRADE RESOURCES.
----------------------------------------------------------------------------=
--*/

#include  <stdio.h>
#include  <math.h>
#include  <malloc.h>
#include  "option.h"

#define DllImport		__declspec(dllimport)
#define DllExport		__declspec(dllexport)

#define SPRD_STEPS		50
#define DAYS_YR			365.25=20

int unauth_optlib_call(double *retval);

/***************************************************************************=
********************
 *									AMERICAN OPTIONS & IMPLIED VOLATILITY
 ***************************************************************************=
********************
 */
extern DllExport=20
int __stdcall AMER_DLL(Fwd, Strike, ExpDt, IntRt, Yield, Vol, Callflag, retv=
al)							=09
double Fwd, Strike, ExpDt, IntRt, Yield, Vol, *retval;
int	Callflag;
{=09
	Optresults output;
	double *result, temp;
	int i;
=09
if (!unauth_optlib_call(result)) {
	result =3D (double *) malloc(10*sizeof(double));
	output.Premium =3D result;
	output.Delta =3D result+1;
	output.Gamma =3D result+2;
	output.Vega =3D result+3;
	output.Rho =3D result+4;
	output.Theta =3D result+5;
	output.DeltaVega =3D result+6;
	output.Charm =3D result+7;
	output.Eta =3D &temp;
	amer(Fwd, Strike, ExpDt/DAYS_YR, IntRt, Yield, Vol, Callflag%10, &output, C=
allflag/10);
	for (i=3D0; i<8; i++) {		/* only first 8 used in AMER */
		retval[i] =3D result[i];
	}
	free(result);
}

if (retval[0] < 0)  /* Premium cannot be negative */
	return (-1); /* ERROR */
else return 0;
}

extern DllExport=20
int __stdcall AMERB_DLL(double spot, double strike, double rate, double yiel=
d,=20
		double sigma, double expdays, int callflag, int steps, double *results)
/* Using Binomial Tree method */
{=09
	if (!unauth_optlib_call(results)) {
		amerb(spot, strike, expdays/DAYS_YR, rate, yield, sigma, callflag%10, resu=
lts, callflag/10, steps);
	}=09
	if (results[0] < 0)  /* Premium cannot be negative */
		return (-1); /* ERROR */
	else return 0;
}
										=09
extern DllExport=20
int __stdcall BASVOL_DLL(
		double	*fwd,		/* vector of asset prices */
		double	*vol,		/* vector of asset price volatilities (annualized) */
		double	*mu,		/* vector of price drifts (risk neutral) (annualized) */
		double	*wgt,		/* vector of weightings in basket */
		double	*correl,	/* vector containing correlation matrix */
							/* Must be the full matrix even though the matrix is symmetric. */
		int	n,				/* number of assets in basket */
		double	exptime,
		double * result)	/* time to expiration (Years) */
{
	double retval;

	if (!unauth_optlib_call(&retval))
		retval =3D baskvol(fwd, vol, mu, wgt, correl, n, exptime);
	*result =3D retval;
	if (retval < 0)  /* Volatility cannot be negative */
		return (-1); /* ERROR */
	else return 0;
}

extern DllExport=20
double __stdcall IMPVOLAB_DLL(double prem, double spot, double strike, doubl=
e rate,=20
			double yield, double maxvol, double expdays,=20
			int callflag, int steps, double accuracy)
/* Implied Vol of American Option Using Binomial Tree method */
{
	double impvol;

	if (!unauth_optlib_call(&impvol)) {
		impvol =3D ImpVol_Amerb(prem, spot, strike, expdays/DAYS_YR, rate,=20
				yield, maxvol, callflag, steps, accuracy);
	}
	return(impvol);
}

extern DllExport
double __stdcall IMPVOLEU_DLL(int putcallind, double actual_premium, double =
spot, double strike,
	     double expdays, double rate, double yield, double maxvol, double accur=
acy, int maxiter)
{

/* Implied Vol of European Option  */

	double impvol, tenor;

	tenor =3D expdays/DAYS_YR;

	if (!unauth_optlib_call(&impvol)) {
		impvol =3D impeuro(putcallind, actual_premium, spot, strike, \
	             tenor, rate,  yield, maxvol,  accuracy, maxiter);

	}
	return(impvol);
}

/***************************************************************************=
********************
 *									ASIAN OPTIONS
 ***************************************************************************=
********************
 */

extern DllExport
double __stdcall ASIANSTRIP_DLL(double *fwd, double Strike, double IntRt, do=
uble *vol,=09
							 double Rho, double SetPr, int *settles, int setdays,=20
							 double ExpDt, double *begin, double *end, int flag,=20
							 int nmonths, int risk, int retmonth)
{
	double retval;

	if (!unauth_optlib_call(&retval))
	{
		retval =3D AsianStrip(fwd, Strike, IntRt, vol, Rho, SetPr,=20
							settles, setdays, ExpDt, begin, end,
							flag, nmonths, risk, retmonth);
	}
	return(retval);=20
}

extern DllExport=20
int __stdcall ASV_DLL(double s, double k, double r, double volin, double set=
, double expd,
					double sta, double toend, double tradedays, int callflag, double *retva=
ls)
{
	if (!unauth_optlib_call(retvals))
		FastAsian(s, k, r, volin, set, expd, sta, toend, tradedays, callflag, retv=
als);
	if (retvals[0] < 0)  /* premium cannot be negative */
		return (-1);  /* ERROR */
	else return 0;
}

extern DllExport=20
int __stdcall ASTRIP_DLL (s, k, r, volin, corr, setpr, settles, setdays, exp=
d, sta, toend, flag, nmonths, risk, result)=20
	int     settles[], setdays, flag, nmonths, risk;
	double	s[], k, r, volin[], corr, setpr,expd, sta[], toend[];													=09
	double	*result;
{
	Optresults output;
=09
	double prem;
=09
	if (unauth_optlib_call(result))
		return (-1);  /* ERROR */
=09
	output.Premium =3D &prem;
	switch( risk )
    {
        case (OPT_PREMIUM):
			output.Premium =3D result;
			break;
		case (OPT_ETA):
			output.Eta =3D result;
			break;
		case (OPT_RHO):
			output.Rho =3D result;
			break;
        case (OPT_VEGA):
			output.Vega =3D result;
			break;
        case (OPT_DELTA):
			output.Delta =3D result;
			break;
        case (OPT_GAMMA):
			output.Delta =3D (double *) malloc(nmonths*sizeof(double));
			output.Gamma =3D result;
			break;
	}
	asianstrip2(s, k, r, volin, corr, setpr, settles, setdays, expd, sta, toend=
, flag, nmonths, risk, &output);
	if (risk=3D=3DOPT_GAMMA) {
		free(output.Delta);
	}

	if (*result <=3D ERR_RETVAL)
		return (-1);  /* ERROR */
	else return 0;
}


/***************************************************************************=
********************
 *									BARRIER OPTIONS
 ***************************************************************************=
********************
 */
extern DllExport=20
int __stdcall BOSTON_DLL(Breakeven, Fwd, ExpDays, IntRt, Yield, Vol, Callfla=
g, result)
	double Breakeven, Fwd, ExpDays, IntRt, Yield, Vol;
	int    Callflag;
	double * result;
{
	double retval;

	if (unauth_optlib_call(&retval))
		return(-1);  /* ERROR */

    if (Vol=3D=3D0.0 ||  ExpDays<=3D0.0 || Fwd=3D=3D0.0)
		*result =3D 0.0;
	else
        *result =3D  strikeroot(Breakeven, Fwd, ExpDays/365.25, IntRt, Yield=
, Vol, Callflag );
	if (*result < 0)  /* Premium cannot be negative */
		return (-1);  /* ERROR */
	else return 0;
}


/***************************************************************************=
********************
 *									BARRIER OPTIONS
 ***************************************************************************=
********************
 */
extern DllExport=20
int __stdcall BARRIER_DLL(s, k, v, r, y, expdays, barr, reba, callput, io, v=
altype, result)
	double	s, k, v, r, y, expdays, barr, reba;
	int		callput, io, valtype;
	double * result;
{
	double res;

	if (!unauth_optlib_call(&res))
		res =3D barrieropt(s, k, v, r, y, expdays, barr, reba, callput, io, valtyp=
e);
	*result =3D res;
	if (res <=3D ERR_RETVAL)
		return (-1);   /* ERROR */
	else return 0;=09
}


/***************************************************************************=
********************
 *									C.O.D. OPTION
 ***************************************************************************=
********************
 */
extern DllExport=20
int __stdcall COD_DLL(prem, s, k, r, q, vol, expd, callput, rvalues )
	double	prem, s, k, r, q, vol, expd, *rvalues;
	int		callput;
{
	if (!unauth_optlib_call(rvalues))
		codopt(prem, s, k, r, q, vol, expd, callput, rvalues);=09
	if (*rvalues <=3D ERR_RETVAL)
		return (-1);  /* ERROR */
	else return 0;
}
=09

extern DllExport=20
int __stdcall CODPREM_DLL(s, k, r, q, vol, expd, callput, result)=20
	double	s, k, r, q, vol, expd;
	int		callput;
	double * result;
{
	double retval;

	if (!unauth_optlib_call(&retval))
		retval =3D codpremium(s, k, r, q, vol, expd, callput);
	*result =3D retval;
	if (retval < 0)  /* premium cannot be negative */
		return (-1);  /* ERROR */
	else return 0;
}
=09

/***************************************************************************=
********************
 *									COMPOUND OPTION
 ***************************************************************************=
********************
 */
extern DllExport=20
int __stdcall COMPOUND_DLL(double price, double k_over, double k_under, doub=
le t_over, double t_under,=20
					double intr, double q, double volab, double volb, int type, int valtype=
,
					double * result)
{
	double retval;

	if (!unauth_optlib_call(&retval))
	   retval =3D compvopt(price, k_over, k_under, t_over, t_under, intr,q,vola=
b,volb,type,valtype);
	*result =3D retval;
	if (retval <=3D ERR_RETVAL)
		return (-1);
	else return 0;
}

/***************************************************************************=
********************
 *									DSTRIP & EUROPEAN OPTIONS
 ***************************************************************************=
********************
 */
extern DllExport=20
int __stdcall DSTRIP_DLL(Fwd, Strike, PerDays, StDays, EndDays, IntRt, Yield=
, Vol, Callflag, Index,
							result)							=09
	double Fwd, Strike, PerDays, StDays, EndDays, IntRt, Yield, Vol;
	int	Callflag, Index;
	double * result;
{
	double retval;

	if (!unauth_optlib_call(&retval)) {
		if (Vol=3D=3D0.0 ||  StDays>=3DEndDays || Fwd=3D=3D0.0) {
		    retval =3D 0.0;
		}=20
		else
			retval =3D  eurostrip(Fwd, Strike, PerDays, StDays, EndDays, IntRt, Yield=
, Vol, Callflag, Index);
	}
	*result =3D retval;
	if (retval <=3D ERR_RETVAL)
		return (-1); /* ERROR */
	else return 0;
}

extern DllExport=20
int __stdcall EURO_DLL(Fwd, Strike, ExpDt, IntRt, Yield, Vol, Callflag, Inde=
x, result)
							=09
	double Fwd, Strike, ExpDt, IntRt, Yield, Vol;
	int	Callflag, Index;
	double * result;
{
	double retval;

	if (!unauth_optlib_call(&retval)) {
		if(  Fwd<=3D0.0 )=20
		    retval =3D 0.0;
		else
			retval =3D  euroopt(Fwd, Strike, ExpDt/DAYS_YR, IntRt, Yield, Vol, Callfl=
ag, Index);
	}
	*result =3D retval;
	if (retval <=3D ERR_RETVAL)
		return (-1); /* ERROR */
	else return 0;
}


/***************************************************************************=
********************
 *									LOOKBACK OPTION
 ***************************************************************************=
********************
 */
extern DllExport=20
int __stdcall LOOKBACK_DLL(s, k, r, q, vol, expd, call, rvalues)
	double	s, k, r, q, vol, expd, rvalues[];
	int		call;
{
	if (!unauth_optlib_call(&rvalues[0]))=20
		lookback(s, k, r, q, vol, expd, call, DAYS_YR, rvalues);
	if (rvalues[0] < 0)  /* premium cannot be negative */
		return (-1);  /* ERROR */
	else return 0;
}
=09

/***************************************************************************=
********************
 *									RAINBOW & SPREAD OPTIONS & WILCOX SPREAD
 ***************************************************************************=
********************
 */
extern DllExport=20
int __stdcall RAINBOW_DLL( sa, sb, K, r, vola, volb, corr, expyrs, opttype, =
valtype,
							 result)
	double sa,sb, K, r, expyrs, vola, volb, corr;=20

	/* double qa, qb; */

	int opttype, valtype;
	double * result;
{
	double retval;

	if (!unauth_optlib_call(&retval))=20
		retval =3D rainbowopt(sa, sb, K, r, r, r, expyrs, vola, volb, corr, opttyp=
e, valtype);
	*result =3D retval;
	if (retval <=3D ERR_RETVAL)
		return (-1);  /* ERROR */
	else return 0;
}

extern DllExport=20
int __stdcall SPRDOPT_DLL(x, y, k, r, volx, voly, corr, time, cflag, rettype=
, result)
	double  x, y, k, r, volx, voly, corr, time;
	int	cflag, rettype;
	double * result;
{
	double  retval;

	if (!unauth_optlib_call(&retval)) {
		retval =3D Spread(x, y, k, r, volx, voly, corr, time/DAYS_YR, cflag, retty=
pe);
	}
	*result =3D retval;
	if (retval <=3D ERR_RETVAL)
		return (-1);  /* ERROR */
	else return 0;
}

/* Spread option assuming the spread is normal distributed RN */

extern DllExport=20
double __stdcall WSPRDOPT_DLL(F, K, r, vol, time, cflag, rettype)
	double   F, K, r, vol, time;
	int	cflag, rettype;
{
	double  retval;

	if (!unauth_optlib_call(&retval)) {
		retval =3D wcxspread(F, K, r, vol, time, cflag, rettype);
	}
	return(retval);
}

/***************************************************************************=
********************
 *									OPTION ON A COLLAR
 ***************************************************************************=
********************
 */
extern DllExport=20
int __stdcall XCOL_DLL(s, rates, vol2, tmat2, vol, spread, tmat, cap, floor,=
 r, nsteps, nmonths,
						  result)
	double	*s, *rates, *vol2, *tmat2, vol,	spread,	tmat, cap, floor,r;
	int		nsteps, nmonths;
	double * result;
{
	double retval;
=09
	if (!unauth_optlib_call(&retval))
		retval =3D opoptree(s, rates, vol2, tmat2, vol, spread, tmat, cap, floor, =
r, nsteps, nmonths);
	*result =3D retval;
	if (retval < 0)  /* premium cannot be negative */
		return (-1);  /* ERROR */
	else return 0;
}


/***************************************************************************=
********************
 *									YEAR STRIP OPTION=20
 ***************************************************************************=
********************
 */
extern DllExport=20
int __stdcall YRSTRIP_DLL(s, k, r, vol, tosetdate, begin, end, dailyqty, ann=
optq, callflag, maxmon, flag,
							 result)
	double *s, *k, *r, *vol, *tosetdate, *begin, *end, *dailyqty, annoptq;
	int    callflag, maxmon, flag;
	double * result;
{   =20
	double retval;

	if (!unauth_optlib_call(&retval))
		retval =3D annualstrip2(s, k, r, vol, tosetdate, begin, end, dailyqty, ann=
optq, callflag, maxmon, flag);
	*result =3D retval;
	if (retval <=3D ERR_RETVAL)
		return (-1);  /* ERROR */
	else return 0;
}
--------------000506070003020302060604--
